
SH100_control.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00001d71  2**0
                  ALLOC, LOAD, DATA
  1 .text         000000cc  00000000  00000000  00000154  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000085  00800100  00800100  00001d71  2**0
                  ALLOC
  3 .comment      0000002f  00000000  00000000  00001d71  2**0
                  CONTENTS, READONLY
  4 .stack.descriptors.hdr 000000a8  00000000  00000000  00001da0  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000003f0  00000000  00000000  00001e48  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00007782  00000000  00000000  00002238  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000013af  00000000  00000000  000099ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000023ae  00000000  00000000  0000ad69  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000007e8  00000000  00000000  0000d118  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000858  00000000  00000000  0000d900  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001cc4  00000000  00000000  0000e158  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002b8  00000000  00000000  0000fe1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .text         00000002  00001bf8  00001bf8  00001d4c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000100d4  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .text.FSW_Init 00000056  0000130a  0000130a  0000145e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.FSW_SetMode 0000000e  00001b24  00001b24  00001c78  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.FSW_MainTask 0000020a  00000564  00000564  000006b8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.FSW_BlockFrontControls 0000001c  000019e2  000019e2  00001b36  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .data.zzCh34  00000001  0080019d  00001c1a  00001d6e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 20 .bss.zzCh12   00000001  0080019e  0080019e  00001d71  2**0
                  ALLOC
 21 .text.FBTNS_MainTask 0000024e  000000d0  000000d0  00000224  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .bss.abSwitched 00000001  0080019f  0080019f  00001d71  2**0
                  ALLOC
 23 .bss.loopSwitched 00000001  008001a0  008001a0  00001d71  2**0
                  ALLOC
 24 .bss.setFSWRelayMode_cnt 00000001  008001a1  008001a1  00001d71  2**0
                  ALLOC
 25 .bss.setFSWZigzagMode_cnt 00000001  008001a2  008001a2  00001d71  2**0
                  ALLOC
 26 .bss.setFSWRingMode_cnt 00000001  008001a3  008001a3  00001d71  2**0
                  ALLOC
 27 .bss.leaveDefSettings_cnt 00000001  008001a4  008001a4  00001d71  2**0
                  ALLOC
 28 .bss.swProgrammingMode_cnt 00000001  008001a5  008001a5  00001d71  2**0
                  ALLOC
 29 .data.protectionInterval_cnt 00000001  008001a6  00001c1b  00001d6f  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 30 .text.__portable_avr_delay_cycles 00000016  00001ab0  00001ab0  00001c04  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.initTest 000000d8  00000c62  00000c62  00000db6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.ISRInit 0000002a  000018ae  000018ae  00001a02  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.main    00000014  00001ac6  00001ac6  00001c1a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.__vector_16 000000b2  00000dfc  00000dfc  00000f50  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .text.__vector_21 000000c2  00000d3a  00000d3a  00000e8e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .text.__vector_4 00000048  0000149a  0000149a  000015ee  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .bss.measSwitch 00000001  008001a7  008001a7  00001d71  2**0
                  ALLOC
 38 .bss.isAmpStarted 00000001  008001a8  008001a8  00001d71  2**0
                  ALLOC
 39 .text.MIDI_IsStatusWord 00000008  00001bae  00001bae  00001d02  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .text.MIDI_IsSysRealTime 0000000c  00001b6a  00001b6a  00001cbe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .text.MIDI_GetStatusType 00000070  0000110a  0000110a  0000125e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .text.isEqualCommands 00000042  00001570  00001570  000016c4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .text.loadCommSetFromMemory 0000007a  00000eae  00000eae  00001002  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .text.setMidiLeds 00000052  00001360  00001360  000014b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .text.MIDICTRL_Init 0000000e  00001b32  00001b32  00001c86  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .text.MIDICTRL_MidiMode 00000006  00001bbe  00001bbe  00001d12  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .text.MIDICTRL_SetProgrammingButton 0000002e  000017f8  000017f8  0000194c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .text.MIDICTRL_EnterProgrammingMode 00000038  000016f0  000016f0  00001844  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .text.MIDICTRL_SetMidiChannel 00000006  00001bc4  00001bc4  00001d18  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .text.MIDICTRL_OmniModeEn 00000006  00001bca  00001bca  00001d1e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .text.MIDICTRL_MuteCommEn 00000006  00001bd0  00001bd0  00001d24  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .text.programmBtn 0000004c  0000144e  0000144e  000015a2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .text.MIDICTRL_SendSwChComm 0000006a  0000117a  0000117a  000012ce  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .text.MIDICTRL_SendLoopEnComm 0000002a  000018d8  000018d8  00001a2c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 55 .text.MIDICTRL_SendSwABComm 0000002a  00001902  00001902  00001a56  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 56 .text.MIDICTRL_StoreUserCommands 0000003e  00001676  00001676  000017ca  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 57 .text.MIDICTRL_DiscardCommands 00000022  0000199e  0000199e  00001af2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .text.indicateMidiError 00000038  00001728  00001728  0000187c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .text.MIDICTRL_HandleCommand 000001f2  0000076e  0000076e  000008c2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .text.__vector_13 00000064  000011e4  000011e4  00001338  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .data.defaultCommands 00000018  00800185  00001c02  00001d56  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 62 .progmemx.data.muteCommand 00000004  000000cc  000000cc  00000220  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 63 .bss.channelNum 00000001  008001a9  008001a9  00001d71  2**0
                  ALLOC
 64 .bss.muteCommandEnabled 00000001  008001aa  008001aa  00001d71  2**0
                  ALLOC
 65 .bss.omniModeEnabled 00000001  008001ab  008001ab  00001d71  2**0
                  ALLOC
 66 .text.handleRealTimeStatus 00000004  00001bf4  00001bf4  00001d48  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .text.MIDI_ParserTask 00000142  00000b20  00000b20  00000c74  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .text.MIDI_SetRetranslateState 00000006  00001bd6  00001bd6  00001d2a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .text.MIDI_SendCommand 00000078  00000fa2  00000fa2  000010f6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .bss.state    00000001  008001ac  008001ac  00001d71  2**0
                  ALLOC
 71 .data.retranslate 00000001  008001ad  00001c1c  00001d70  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 72 .text.SH100CTRL_GetAmpState 00000042  000015b2  000015b2  00001706  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 73 .text.setChannelLeds 00000022  000019c0  000019c0  00001b14  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 74 .text.SH100CTRL_SetAmpLeds 0000002e  00001826  00001826  0000197a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 75 .text.SH100CTRL_StoreAmpState 0000001c  000019fe  000019fe  00001b52  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 76 .text.SH100CTRL_SetLoop 0000002a  0000192c  0000192c  00001a80  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 77 .text.SH100CTRL_SetChannel 0000002e  00001854  00001854  000019a8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 78 .text.SH100CTRL_SwLoop 00000014  00001ada  00001ada  00001c2e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 79 .text.SH100CTRL_BtnSwChannel 00000010  00001b14  00001b14  00001c68  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 80 .text.SH100CTRL_SetAB 00000024  00001956  00001956  00001aaa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 81 .text.SH100CTRL_SetAmpState 00000032  00001794  00001794  000018e8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 82 .text.SH100CTRL_Init 00000078  0000101a  0000101a  0000116e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 83 .text.SH100CTRL_SwAB 0000000c  00001b76  00001b76  00001cca  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 84 .text.SH100CTRL_MuteAmp 00000006  00001bdc  00001bdc  00001d30  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 85 .text.SH100CTRL_UnmuteAmp 0000000c  00001b82  00001b82  00001cd6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 86 .text.SH100CTRL_CheckOutputJacks 00000078  00001092  00001092  000011e6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 87 .text.SH100HW_Init 00000062  00001248  00001248  0000139c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 88 .text.SH100HW_SetPAFailure 0000000e  00001b40  00001b40  00001c94  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 89 .text.SH100HW_GetPAFailure 0000000a  00001b9a  00001b9a  00001cee  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 90 .text.SH100HW_SetCh 0000004e  000013b2  000013b2  00001506  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 91 .text.SH100HW_LoopEn 00000018  00001a50  00001a50  00001ba4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 92 .text.SH100HW_SetAB 00000006  00001be2  00001be2  00001d36  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 93 .text.SH100HW_SetNewLedState 0000002c  00001882  00001882  000019d6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 94 .text.SH100HW_SetPreviousLedState 00000018  00001a68  00001a68  00001bbc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 95 .text.SH100HW_SetLedBlinkCount 00000040  00001636  00001636  0000178a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 96 .text.SH100HW_GetOutputJacks 00000018  00001a80  00001a80  00001bd4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 97 .text.SH100HW_SetPAState 0000003c  000016b4  000016b4  00001808  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 98 .text.SH100HW_SetOutputMode 00000006  00001be8  00001be8  00001d3c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 99 .text.SH100HW_StartADConvertion 00000014  00001aee  00001aee  00001c42  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
100 .text.SH100HW_GetControlsState 000001c0  00000960  00000960  00000ab4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
101 .text.writeShiftRegs 00000042  000015f4  000015f4  00001748  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
102 .text.SH100HW_MainTask 00000246  0000031e  0000031e  00000472  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
103 .bss.fastBlink 00000001  008001ae  008001ae  00001d71  2**0
                  ALLOC
104 .bss.slowBlink 00000001  008001af  008001af  00001d71  2**0
                  ALLOC
105 .bss.blinkCounter 00000001  008001b0  008001b0  00001d71  2**0
                  ALLOC
106 .text.UART_init 00000018  00001a98  00001a98  00001bec  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
107 .text.__vector_18 00000060  000012aa  000012aa  000013fe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
108 .text.UART_PopWord 00000034  00001760  00001760  000018b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
109 .text.UART_RxBufferNotEmpty 0000000e  00001b4e  00001b4e  00001ca2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
110 .text.__vector_20 0000004e  00001400  00001400  00001554  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
111 .text.UART_PushWord 00000046  0000152a  0000152a  0000167e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
112 .text         0000007a  00000f28  00000f28  0000107c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
113 .text         00000008  00001bb6  00001bb6  00001d0a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
114 .text         00000048  000014e2  000014e2  00001636  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
115 .text.libgcc  0000001a  00001a36  00001a36  00001b8a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
116 .text.__dummy_fini 00000002  00001bfa  00001bfa  00001d4e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
117 .text.__dummy_funcs_on_exit 00000002  00001bfc  00001bfc  00001d50  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
118 .text.__dummy_simulator_exit 00000002  00001bfe  00001bfe  00001d52  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
119 .text.exit    0000000e  00001b5c  00001b5c  00001cb0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
120 .text._Exit   00000002  00001c00  00001c00  00001d54  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
121 .text.avrlibc 00000024  0000197a  0000197a  00001ace  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
122 .text.avrlibc 00000012  00001b02  00001b02  00001c56  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
123 .text.avrlibc 0000000c  00001b8e  00001b8e  00001ce2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
124 .text.avrlibc 00000032  000017c6  000017c6  0000191a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
125 .text.avrlibc 0000001c  00001a1a  00001a1a  00001b6e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
126 .text.avrlibc 00000006  00001bee  00001bee  00001d42  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
127 .text.libgcc  0000000a  00001ba4  00001ba4  00001cf8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	3d c0       	rjmp	.+122    	; 0x7c <__ctors_end>
   2:	fa cd       	rjmp	.-1036   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
   4:	f9 cd       	rjmp	.-1038   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
   6:	f8 cd       	rjmp	.-1040   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
   8:	48 ca       	rjmp	.-2928   	; 0xfffff49a <__eeprom_end+0xff7ef49a>
   a:	f6 cd       	rjmp	.-1044   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
   c:	f5 cd       	rjmp	.-1046   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
   e:	f4 cd       	rjmp	.-1048   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  10:	f3 cd       	rjmp	.-1050   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  12:	f2 cd       	rjmp	.-1052   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  14:	f1 cd       	rjmp	.-1054   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  16:	f0 cd       	rjmp	.-1056   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  18:	ef cd       	rjmp	.-1058   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  1a:	e4 c8       	rjmp	.-3640   	; 0xfffff1e4 <__eeprom_end+0xff7ef1e4>
  1c:	ed cd       	rjmp	.-1062   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  1e:	ec cd       	rjmp	.-1064   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  20:	ed c6       	rjmp	.+3546   	; 0xdfc <__vector_16>
  22:	ea cd       	rjmp	.-1068   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  24:	42 c9       	rjmp	.-3452   	; 0xfffff2aa <__eeprom_end+0xff7ef2aa>
  26:	e8 cd       	rjmp	.-1072   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  28:	eb c9       	rjmp	.-3114   	; 0xfffff400 <__eeprom_end+0xff7ef400>
  2a:	87 c6       	rjmp	.+3342   	; 0xd3a <__vector_21>
  2c:	e5 cd       	rjmp	.-1078   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  2e:	e4 cd       	rjmp	.-1080   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  30:	e3 cd       	rjmp	.-1082   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  32:	e2 cd       	rjmp	.-1084   	; 0xfffffbf8 <__eeprom_end+0xff7efbf8>
  34:	81 c5       	rjmp	.+2818   	; 0xb38 <MIDI_ParserTask+0x18>
  36:	8d c5       	rjmp	.+2842   	; 0xb52 <MIDI_ParserTask+0x32>
  38:	cc c5       	rjmp	.+2968   	; 0xbd2 <MIDI_ParserTask+0xb2>
  3a:	fa c5       	rjmp	.+3060   	; 0xc30 <MIDI_ParserTask+0x110>
  3c:	df c5       	rjmp	.+3006   	; 0xbfc <MIDI_ParserTask+0xdc>
  3e:	04 c6       	rjmp	.+3080   	; 0xc48 <MIDI_ParserTask+0x128>
  40:	07 c6       	rjmp	.+3086   	; 0xc50 <MIDI_ParserTask+0x130>
  42:	9d c4       	rjmp	.+2362   	; 0x97e <SH100HW_GetControlsState+0x1e>
  44:	b2 c4       	rjmp	.+2404   	; 0x9aa <SH100HW_GetControlsState+0x4a>
  46:	cb c4       	rjmp	.+2454   	; 0x9de <SH100HW_GetControlsState+0x7e>
  48:	e4 c4       	rjmp	.+2504   	; 0xa12 <SH100HW_GetControlsState+0xb2>
  4a:	f9 c4       	rjmp	.+2546   	; 0xa3e <SH100HW_GetControlsState+0xde>
  4c:	12 c5       	rjmp	.+2596   	; 0xa72 <SH100HW_GetControlsState+0x112>
  4e:	21 c5       	rjmp	.+2626   	; 0xa92 <SH100HW_GetControlsState+0x132>
  50:	3a c5       	rjmp	.+2676   	; 0xac6 <SH100HW_GetControlsState+0x166>

00000052 <.dinit>:
  52:	01 00       	.word	0x0001	; ????
  54:	01 85       	ldd	r16, Z+9	; 0x09
  56:	80 01       	movw	r16, r0
  58:	85 01       	movw	r16, r10
  5a:	9e 00       	.word	0x009e	; ????
  5c:	1c 02       	muls	r17, r28
  5e:	01 9e       	mul	r0, r17
  60:	01 a6       	std	Z+41, r0	; 0x29
  62:	80 01       	movw	r16, r0
  64:	a6 01       	movw	r20, r12
  66:	a7 00       	.word	0x00a7	; ????
  68:	1c 1b       	sub	r17, r28
  6a:	01 a7       	std	Z+41, r16	; 0x29
  6c:	01 ad       	ldd	r16, Z+57	; 0x39
  6e:	80 01       	movw	r16, r0
  70:	ad 01       	movw	r20, r26
  72:	ae 00       	.word	0x00ae	; ????
  74:	1c 1c       	adc	r1, r12
  76:	01 ae       	std	Z+57, r0	; 0x39
  78:	01 b1       	in	r16, 0x01	; 1
  7a:	80 00       	.word	0x0080	; ????

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d4 e0       	ldi	r29, 0x04	; 4
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
  88:	e2 e5       	ldi	r30, 0x52	; 82
  8a:	f0 e0       	ldi	r31, 0x00	; 0
  8c:	40 e0       	ldi	r20, 0x00	; 0
  8e:	17 c0       	rjmp	.+46     	; 0xbe <__do_clear_bss+0x8>
  90:	b5 91       	lpm	r27, Z+
  92:	a5 91       	lpm	r26, Z+
  94:	35 91       	lpm	r19, Z+
  96:	25 91       	lpm	r18, Z+
  98:	05 91       	lpm	r16, Z+
  9a:	07 fd       	sbrc	r16, 7
  9c:	0c c0       	rjmp	.+24     	; 0xb6 <__do_clear_bss>
  9e:	95 91       	lpm	r25, Z+
  a0:	85 91       	lpm	r24, Z+
  a2:	ef 01       	movw	r28, r30
  a4:	f9 2f       	mov	r31, r25
  a6:	e8 2f       	mov	r30, r24
  a8:	05 90       	lpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a2 17       	cp	r26, r18
  ae:	b3 07       	cpc	r27, r19
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x20>
  b2:	fe 01       	movw	r30, r28
  b4:	04 c0       	rjmp	.+8      	; 0xbe <__do_clear_bss+0x8>

000000b6 <__do_clear_bss>:
  b6:	1d 92       	st	X+, r1
  b8:	a2 17       	cp	r26, r18
  ba:	b3 07       	cpc	r27, r19
  bc:	e1 f7       	brne	.-8      	; 0xb6 <__do_clear_bss>
  be:	eb 37       	cpi	r30, 0x7B	; 123
  c0:	f4 07       	cpc	r31, r20
  c2:	31 f7       	brne	.-52     	; 0x90 <__do_copy_data+0x8>
  c4:	00 dd       	rcall	.-1536   	; 0xfffffac6 <__eeprom_end+0xff7efac6>
  c6:	4a cd       	rjmp	.-1388   	; 0xfffffb5c <__eeprom_end+0xff7efb5c>

000000c8 <_exit>:
  c8:	f8 94       	cli

000000ca <__stop_program>:
  ca:	ff cf       	rjmp	.-2      	; 0xca <__stop_program>

Disassembly of section .text:

00001bf8 <__bad_interrupt>:
    1bf8:	03 c2       	rjmp	.+1030   	; 0x2000 <__TEXT_REGION_LENGTH__>

Disassembly of section .text.FSW_Init:

0000130a <FSW_Init>:
FSW_SwitchMode_t switchMode;
SH100HW_Controls_t ctrlsPrevState;
uint8_t protectionInterval_cnt;

void FSW_Init()
{
    130a:	cf 93       	push	r28
    130c:	df 93       	push	r29
    130e:	cd b7       	in	r28, 0x3d	; 61
    1310:	de b7       	in	r29, 0x3e	; 62
    1312:	2f 97       	sbiw	r28, 0x0f	; 15
    1314:	0f b6       	in	r0, 0x3f	; 63
    1316:	f8 94       	cli
    1318:	de bf       	out	0x3e, r29	; 62
    131a:	0f be       	out	0x3f, r0	; 63
    131c:	cd bf       	out	0x3d, r28	; 61
	switchMode = eeprom_read_byte((uint8_t*)MEMORY_FSW_MODE_OFFSET);
    131e:	67 e0       	ldi	r22, 0x07	; 7
    1320:	70 e0       	ldi	r23, 0x00	; 0
    1322:	80 e8       	ldi	r24, 0x80	; 128
    1324:	ee d3       	rcall	.+2012   	; 0x1b02 <eeprom_read_byte>
    1326:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
	
	if(switchMode > 2) switchMode = 0;
    132a:	83 30       	cpi	r24, 0x03	; 3
    132c:	10 f0       	brcs	.+4      	; 0x1332 <FSW_Init+0x28>
    132e:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__DATA_REGION_ORIGIN__>
	
	ctrlsPrevState = SH100HW_GetControlsState();
    1332:	ce 01       	movw	r24, r28
    1334:	01 96       	adiw	r24, 0x01	; 1
    1336:	14 db       	rcall	.-2520   	; 0x960 <SH100HW_GetControlsState>
    1338:	8f e0       	ldi	r24, 0x0F	; 15
    133a:	fe 01       	movw	r30, r28
    133c:	31 96       	adiw	r30, 0x01	; 1
    133e:	a1 e0       	ldi	r26, 0x01	; 1
    1340:	b1 e0       	ldi	r27, 0x01	; 1
    1342:	01 90       	ld	r0, Z+
    1344:	0d 92       	st	X+, r0
    1346:	8a 95       	dec	r24
    1348:	e1 f7       	brne	.-8      	; 0x1342 <FSW_Init+0x38>
	protectionInterval_cnt = 0;
    134a:	10 92 a6 01 	sts	0x01A6, r1	; 0x8001a6 <protectionInterval_cnt>
}
    134e:	2f 96       	adiw	r28, 0x0f	; 15
    1350:	0f b6       	in	r0, 0x3f	; 63
    1352:	f8 94       	cli
    1354:	de bf       	out	0x3e, r29	; 62
    1356:	0f be       	out	0x3f, r0	; 63
    1358:	cd bf       	out	0x3d, r28	; 61
    135a:	df 91       	pop	r29
    135c:	cf 91       	pop	r28
    135e:	08 95       	ret

Disassembly of section .text.FSW_SetMode:

00001b24 <FSW_SetMode>:

void FSW_SetMode(FSW_SwitchMode_t newSwitchMode)
{
	switchMode = newSwitchMode;
    1b24:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
	eeprom_write_byte((uint8_t*)MEMORY_FSW_MODE_OFFSET, switchMode);
    1b28:	68 2f       	mov	r22, r24
    1b2a:	87 e0       	ldi	r24, 0x07	; 7
    1b2c:	90 e0       	ldi	r25, 0x00	; 0
    1b2e:	75 df       	rcall	.-278    	; 0x1a1a <eeprom_write_byte>
    1b30:	08 95       	ret

Disassembly of section .text.FSW_MainTask:

00000564 <FSW_MainTask>:

#define FSW_PROTECTION_INTERVAL 20
uint8_t zzCh12 = SH100_CHANNEL1;
uint8_t zzCh34 = SH100_CHANNEL3;
void FSW_MainTask(const SH100HW_Controls_t* activatedCtrls)
{
 564:	cf 92       	push	r12
 566:	df 92       	push	r13
 568:	ef 92       	push	r14
 56a:	0f 93       	push	r16
 56c:	1f 93       	push	r17
 56e:	cf 93       	push	r28
 570:	df 93       	push	r29
 572:	cd b7       	in	r28, 0x3d	; 61
 574:	de b7       	in	r29, 0x3e	; 62
 576:	62 97       	sbiw	r28, 0x12	; 18
 578:	0f b6       	in	r0, 0x3f	; 63
 57a:	f8 94       	cli
 57c:	de bf       	out	0x3e, r29	; 62
 57e:	0f be       	out	0x3f, r0	; 63
 580:	cd bf       	out	0x3d, r28	; 61
 582:	6b 01       	movw	r12, r22
 584:	e8 2e       	mov	r14, r24
	if(protectionInterval_cnt == 0)
 586:	80 91 a6 01 	lds	r24, 0x01A6	; 0x8001a6 <protectionInterval_cnt>
 58a:	81 11       	cpse	r24, r1
 58c:	df c0       	rjmp	.+446    	; 0x74c <FSW_MainTask+0x1e8>
	{		
		if (activatedCtrls->FS1_presence == BT_ON)
 58e:	ae 2d       	mov	r26, r14
 590:	c6 01       	movw	r24, r12
 592:	0b 96       	adiw	r24, 0x0b	; 11
 594:	a1 1d       	adc	r26, r1
 596:	fc 01       	movw	r30, r24
 598:	84 91       	lpm	r24, Z
 59a:	a7 fd       	sbrc	r26, 7
 59c:	80 81       	ld	r24, Z
 59e:	81 11       	cpse	r24, r1
 5a0:	a4 c0       	rjmp	.+328    	; 0x6ea <FSW_MainTask+0x186>
		{
			switch(switchMode)
 5a2:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 5a6:	81 30       	cpi	r24, 0x01	; 1
 5a8:	09 f4       	brne	.+2      	; 0x5ac <FSW_MainTask+0x48>
 5aa:	63 c0       	rjmp	.+198    	; 0x672 <FSW_MainTask+0x10e>
 5ac:	48 f1       	brcs	.+82     	; 0x600 <FSW_MainTask+0x9c>
 5ae:	82 30       	cpi	r24, 0x02	; 2
 5b0:	09 f0       	breq	.+2      	; 0x5b4 <FSW_MainTask+0x50>
 5b2:	9b c0       	rjmp	.+310    	; 0x6ea <FSW_MainTask+0x186>
			{		
				case FSW_RELAY:
				{
					uint8_t channelNum = (!(activatedCtrls->FS1_sleeve) << 1) | (!(activatedCtrls->FS1_tip));
 5b4:	ae 2d       	mov	r26, r14
 5b6:	c6 01       	movw	r24, r12
 5b8:	09 96       	adiw	r24, 0x09	; 9
 5ba:	a1 1d       	adc	r26, r1
 5bc:	fc 01       	movw	r30, r24
 5be:	84 91       	lpm	r24, Z
 5c0:	a7 fd       	sbrc	r26, 7
 5c2:	80 81       	ld	r24, Z
 5c4:	81 11       	cpse	r24, r1
 5c6:	02 c0       	rjmp	.+4      	; 0x5cc <FSW_MainTask+0x68>
 5c8:	12 e0       	ldi	r17, 0x02	; 2
 5ca:	01 c0       	rjmp	.+2      	; 0x5ce <FSW_MainTask+0x6a>
 5cc:	10 e0       	ldi	r17, 0x00	; 0
 5ce:	ae 2d       	mov	r26, r14
 5d0:	c6 01       	movw	r24, r12
 5d2:	0a 96       	adiw	r24, 0x0a	; 10
 5d4:	a1 1d       	adc	r26, r1
 5d6:	fc 01       	movw	r30, r24
 5d8:	94 91       	lpm	r25, Z
 5da:	a7 fd       	sbrc	r26, 7
 5dc:	90 81       	ld	r25, Z
 5de:	81 e0       	ldi	r24, 0x01	; 1
 5e0:	91 11       	cpse	r25, r1
 5e2:	80 e0       	ldi	r24, 0x00	; 0
 5e4:	18 2b       	or	r17, r24
			
					if(SH100CTRL_GetAmpState().channelNum != channelNum)
 5e6:	e5 d7       	rcall	.+4042   	; 0x15b2 <SH100CTRL_GetAmpState>
 5e8:	2d 87       	std	Y+13, r18	; 0x0d
 5ea:	3e 87       	std	Y+14, r19	; 0x0e
 5ec:	4f 87       	std	Y+15, r20	; 0x0f
 5ee:	58 8b       	std	Y+16, r21	; 0x10
 5f0:	69 8b       	std	Y+17, r22	; 0x11
 5f2:	7a 8b       	std	Y+18, r23	; 0x12
 5f4:	12 17       	cp	r17, r18
 5f6:	09 f4       	brne	.+2      	; 0x5fa <FSW_MainTask+0x96>
 5f8:	78 c0       	rjmp	.+240    	; 0x6ea <FSW_MainTask+0x186>
					{
						SH100CTRL_SetChannel(channelNum); // send midi comm only once
 5fa:	81 2f       	mov	r24, r17
 5fc:	2b d9       	rcall	.-3498   	; 0xfffff854 <__eeprom_end+0xff7ef854>
 5fe:	75 c0       	rjmp	.+234    	; 0x6ea <FSW_MainTask+0x186>
					}		
					break;	
				}
				case FSW_RING:
				{
					uint8_t currentChannel = SH100CTRL_GetAmpState().channelNum;
 600:	d8 d7       	rcall	.+4016   	; 0x15b2 <SH100CTRL_GetAmpState>
 602:	12 2f       	mov	r17, r18
 604:	2f 83       	std	Y+7, r18	; 0x07
 606:	38 87       	std	Y+8, r19	; 0x08
 608:	49 87       	std	Y+9, r20	; 0x09
 60a:	5a 87       	std	Y+10, r21	; 0x0a
 60c:	6b 87       	std	Y+11, r22	; 0x0b
 60e:	7c 87       	std	Y+12, r23	; 0x0c
 610:	02 2f       	mov	r16, r18
					if(ctrlsPrevState.FS1_tip != activatedCtrls->FS1_tip)
 612:	20 91 0b 01 	lds	r18, 0x010B	; 0x80010b <ctrlsPrevState+0xa>
 616:	ae 2d       	mov	r26, r14
 618:	c6 01       	movw	r24, r12
 61a:	0a 96       	adiw	r24, 0x0a	; 10
 61c:	a1 1d       	adc	r26, r1
 61e:	fc 01       	movw	r30, r24
 620:	84 91       	lpm	r24, Z
 622:	a7 fd       	sbrc	r26, 7
 624:	80 81       	ld	r24, Z
 626:	28 17       	cp	r18, r24
 628:	59 f0       	breq	.+22     	; 0x640 <FSW_MainTask+0xdc>
					{
						protectionInterval_cnt = FSW_PROTECTION_INTERVAL;
 62a:	84 e1       	ldi	r24, 0x14	; 20
 62c:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
											
						if(currentChannel > SH100_CHANNEL1) SH100CTRL_SetChannel(currentChannel-1);
 630:	11 23       	and	r17, r17
 632:	21 f0       	breq	.+8      	; 0x63c <FSW_MainTask+0xd8>
 634:	8f ef       	ldi	r24, 0xFF	; 255
 636:	81 0f       	add	r24, r17
 638:	0d d9       	rcall	.-3558   	; 0xfffff854 <__eeprom_end+0xff7ef854>
 63a:	02 c0       	rjmp	.+4      	; 0x640 <FSW_MainTask+0xdc>
						else SH100CTRL_SetChannel(SH100_CHANNEL4);
 63c:	83 e0       	ldi	r24, 0x03	; 3
 63e:	0a d9       	rcall	.-3564   	; 0xfffff854 <__eeprom_end+0xff7ef854>
					}
			
					if(ctrlsPrevState.FS1_sleeve != activatedCtrls->FS1_sleeve)
 640:	20 91 0a 01 	lds	r18, 0x010A	; 0x80010a <ctrlsPrevState+0x9>
 644:	ae 2d       	mov	r26, r14
 646:	c6 01       	movw	r24, r12
 648:	09 96       	adiw	r24, 0x09	; 9
 64a:	a1 1d       	adc	r26, r1
 64c:	fc 01       	movw	r30, r24
 64e:	84 91       	lpm	r24, Z
 650:	a7 fd       	sbrc	r26, 7
 652:	80 81       	ld	r24, Z
 654:	28 17       	cp	r18, r24
 656:	09 f4       	brne	.+2      	; 0x65a <FSW_MainTask+0xf6>
 658:	48 c0       	rjmp	.+144    	; 0x6ea <FSW_MainTask+0x186>
					{
						protectionInterval_cnt = FSW_PROTECTION_INTERVAL;
 65a:	84 e1       	ldi	r24, 0x14	; 20
 65c:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
						
						if(currentChannel < SH100_CHANNEL4) SH100CTRL_SetChannel(currentChannel+1);
 660:	03 30       	cpi	r16, 0x03	; 3
 662:	20 f4       	brcc	.+8      	; 0x66c <FSW_MainTask+0x108>
 664:	81 e0       	ldi	r24, 0x01	; 1
 666:	81 0f       	add	r24, r17
 668:	f5 d8       	rcall	.-3606   	; 0xfffff854 <__eeprom_end+0xff7ef854>
 66a:	3f c0       	rjmp	.+126    	; 0x6ea <FSW_MainTask+0x186>
						else SH100CTRL_SetChannel(SH100_CHANNEL1);
 66c:	80 e0       	ldi	r24, 0x00	; 0
 66e:	f2 d8       	rcall	.-3612   	; 0xfffff854 <__eeprom_end+0xff7ef854>
 670:	3c c0       	rjmp	.+120    	; 0x6ea <FSW_MainTask+0x186>
					}
					break;
				}
				case FSW_ZIGZAG:
				{
					uint8_t currentChannel = SH100CTRL_GetAmpState().channelNum;
 672:	9f d7       	rcall	.+3902   	; 0x15b2 <SH100CTRL_GetAmpState>
 674:	29 83       	std	Y+1, r18	; 0x01
 676:	3a 83       	std	Y+2, r19	; 0x02
 678:	4b 83       	std	Y+3, r20	; 0x03
 67a:	5c 83       	std	Y+4, r21	; 0x04
 67c:	6d 83       	std	Y+5, r22	; 0x05
 67e:	7e 83       	std	Y+6, r23	; 0x06
 680:	12 2f       	mov	r17, r18
					if(ctrlsPrevState.FS1_tip != activatedCtrls->FS1_tip)
 682:	20 91 0b 01 	lds	r18, 0x010B	; 0x80010b <ctrlsPrevState+0xa>
 686:	ae 2d       	mov	r26, r14
 688:	c6 01       	movw	r24, r12
 68a:	0a 96       	adiw	r24, 0x0a	; 10
 68c:	a1 1d       	adc	r26, r1
 68e:	fc 01       	movw	r30, r24
 690:	84 91       	lpm	r24, Z
 692:	a7 fd       	sbrc	r26, 7
 694:	80 81       	ld	r24, Z
 696:	28 17       	cp	r18, r24
 698:	69 f0       	breq	.+26     	; 0x6b4 <FSW_MainTask+0x150>
					{
						protectionInterval_cnt = FSW_PROTECTION_INTERVAL;
 69a:	84 e1       	ldi	r24, 0x14	; 20
 69c:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
						if(currentChannel < SH100_CHANNEL2)
 6a0:	11 11       	cpse	r17, r1
 6a2:	05 c0       	rjmp	.+10     	; 0x6ae <FSW_MainTask+0x14a>
						{
							zzCh12 = (currentChannel == SH100_CHANNEL1) ? SH100_CHANNEL2 : SH100_CHANNEL1;
 6a4:	81 e0       	ldi	r24, 0x01	; 1
 6a6:	11 11       	cpse	r17, r1
 6a8:	80 e0       	ldi	r24, 0x00	; 0
 6aa:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <zzCh12>
						}					
						SH100CTRL_SetChannel(zzCh12);
 6ae:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <zzCh12>
 6b2:	d0 d8       	rcall	.-3680   	; 0xfffff854 <__eeprom_end+0xff7ef854>
					}
				
					if(ctrlsPrevState.FS1_sleeve != activatedCtrls->FS1_sleeve)
 6b4:	20 91 0a 01 	lds	r18, 0x010A	; 0x80010a <ctrlsPrevState+0x9>
 6b8:	ae 2d       	mov	r26, r14
 6ba:	c6 01       	movw	r24, r12
 6bc:	09 96       	adiw	r24, 0x09	; 9
 6be:	a1 1d       	adc	r26, r1
 6c0:	fc 01       	movw	r30, r24
 6c2:	84 91       	lpm	r24, Z
 6c4:	a7 fd       	sbrc	r26, 7
 6c6:	80 81       	ld	r24, Z
 6c8:	28 17       	cp	r18, r24
 6ca:	79 f0       	breq	.+30     	; 0x6ea <FSW_MainTask+0x186>
					{
						protectionInterval_cnt = FSW_PROTECTION_INTERVAL;
 6cc:	84 e1       	ldi	r24, 0x14	; 20
 6ce:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
						if(currentChannel > SH100_CHANNEL3)
 6d2:	13 30       	cpi	r17, 0x03	; 3
 6d4:	38 f0       	brcs	.+14     	; 0x6e4 <FSW_MainTask+0x180>
						{
							zzCh34 = (currentChannel == SH100_CHANNEL3) ? SH100_CHANNEL4 : SH100_CHANNEL3;
 6d6:	12 30       	cpi	r17, 0x02	; 2
 6d8:	11 f4       	brne	.+4      	; 0x6de <FSW_MainTask+0x17a>
 6da:	83 e0       	ldi	r24, 0x03	; 3
 6dc:	01 c0       	rjmp	.+2      	; 0x6e0 <FSW_MainTask+0x17c>
 6de:	82 e0       	ldi	r24, 0x02	; 2
 6e0:	80 93 9d 01 	sts	0x019D, r24	; 0x80019d <zzCh34>
						}
						SH100CTRL_SetChannel(zzCh34);
 6e4:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <zzCh34>
 6e8:	b5 d8       	rcall	.-3734   	; 0xfffff854 <__eeprom_end+0xff7ef854>
					break;
				}
			}
		}

		if (activatedCtrls->FS2_presence == BT_ON)
 6ea:	ae 2d       	mov	r26, r14
 6ec:	c6 01       	movw	r24, r12
 6ee:	0e 96       	adiw	r24, 0x0e	; 14
 6f0:	a1 1d       	adc	r26, r1
 6f2:	fc 01       	movw	r30, r24
 6f4:	84 91       	lpm	r24, Z
 6f6:	a7 fd       	sbrc	r26, 7
 6f8:	80 81       	ld	r24, Z
 6fa:	81 11       	cpse	r24, r1
 6fc:	20 c0       	rjmp	.+64     	; 0x73e <FSW_MainTask+0x1da>
		{
			if(ctrlsPrevState.FS2_tip != activatedCtrls->FS2_tip)
 6fe:	20 91 0e 01 	lds	r18, 0x010E	; 0x80010e <ctrlsPrevState+0xd>
 702:	ae 2d       	mov	r26, r14
 704:	c6 01       	movw	r24, r12
 706:	0d 96       	adiw	r24, 0x0d	; 13
 708:	a1 1d       	adc	r26, r1
 70a:	fc 01       	movw	r30, r24
 70c:	84 91       	lpm	r24, Z
 70e:	a7 fd       	sbrc	r26, 7
 710:	80 81       	ld	r24, Z
 712:	28 17       	cp	r18, r24
 714:	21 f0       	breq	.+8      	; 0x71e <FSW_MainTask+0x1ba>
			{
				protectionInterval_cnt = FSW_PROTECTION_INTERVAL;
 716:	84 e1       	ldi	r24, 0x14	; 20
 718:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
				SH100CTRL_SwLoop();
 71c:	de d9       	rcall	.-3140   	; 0xfffffada <__eeprom_end+0xff7efada>
			}
		
			if (ctrlsPrevState.FS2_sleeve != activatedCtrls->FS2_sleeve)
 71e:	20 91 0d 01 	lds	r18, 0x010D	; 0x80010d <ctrlsPrevState+0xc>
 722:	ae 2d       	mov	r26, r14
 724:	c6 01       	movw	r24, r12
 726:	0c 96       	adiw	r24, 0x0c	; 12
 728:	a1 1d       	adc	r26, r1
 72a:	fc 01       	movw	r30, r24
 72c:	84 91       	lpm	r24, Z
 72e:	a7 fd       	sbrc	r26, 7
 730:	80 81       	ld	r24, Z
 732:	28 17       	cp	r18, r24
 734:	21 f0       	breq	.+8      	; 0x73e <FSW_MainTask+0x1da>
			{
				protectionInterval_cnt = FSW_PROTECTION_INTERVAL;
 736:	84 e1       	ldi	r24, 0x14	; 20
 738:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
				SH100CTRL_SwAB();
 73c:	1c da       	rcall	.-3016   	; 0xfffffb76 <__eeprom_end+0xff7efb76>
			}
		}
	
		ctrlsPrevState = *activatedCtrls;
 73e:	8f e0       	ldi	r24, 0x0F	; 15
 740:	f6 01       	movw	r30, r12
 742:	a1 e0       	ldi	r26, 0x01	; 1
 744:	b1 e0       	ldi	r27, 0x01	; 1
 746:	7e 2d       	mov	r23, r14
 748:	76 d9       	rcall	.-3348   	; 0xfffffa36 <__eeprom_end+0xff7efa36>
 74a:	03 c0       	rjmp	.+6      	; 0x752 <FSW_MainTask+0x1ee>
	}
	else
	{
		protectionInterval_cnt--;
 74c:	81 50       	subi	r24, 0x01	; 1
 74e:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
	}
}
 752:	62 96       	adiw	r28, 0x12	; 18
 754:	0f b6       	in	r0, 0x3f	; 63
 756:	f8 94       	cli
 758:	de bf       	out	0x3e, r29	; 62
 75a:	0f be       	out	0x3f, r0	; 63
 75c:	cd bf       	out	0x3d, r28	; 61
 75e:	df 91       	pop	r29
 760:	cf 91       	pop	r28
 762:	1f 91       	pop	r17
 764:	0f 91       	pop	r16
 766:	ef 90       	pop	r14
 768:	df 90       	pop	r13
 76a:	cf 90       	pop	r12
 76c:	08 95       	ret

Disassembly of section .text.FSW_BlockFrontControls:

000019e2 <FSW_BlockFrontControls>:

bool FSW_BlockFrontControls()
{
	return ((switchMode == FSW_RELAY) && (ctrlsPrevState.FS1_presence == BT_ON));
    19e2:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
    19e6:	82 30       	cpi	r24, 0x02	; 2
    19e8:	31 f4       	brne	.+12     	; 0x19f6 <FSW_BlockFrontControls+0x14>
    19ea:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <ctrlsPrevState+0xb>
    19ee:	88 23       	and	r24, r24
    19f0:	21 f0       	breq	.+8      	; 0x19fa <FSW_BlockFrontControls+0x18>
    19f2:	80 e0       	ldi	r24, 0x00	; 0
    19f4:	08 95       	ret
    19f6:	80 e0       	ldi	r24, 0x00	; 0
    19f8:	08 95       	ret
    19fa:	81 e0       	ldi	r24, 0x01	; 1
    19fc:	08 95       	ret

Disassembly of section .text.FBTNS_MainTask:

000000d0 <FBTNS_MainTask>:

bool loopSwitched = false;
bool abSwitched = false;

void FBTNS_MainTask(const SH100HW_Controls_t* pressedButtons)
{
  d0:	cf 92       	push	r12
  d2:	df 92       	push	r13
  d4:	ef 92       	push	r14
  d6:	9b 01       	movw	r18, r22
  d8:	48 2f       	mov	r20, r24
	if(protectionInterval_cnt == 0)
  da:	80 91 a6 01 	lds	r24, 0x01A6	; 0x8001a6 <protectionInterval_cnt>
  de:	81 11       	cpse	r24, r1
  e0:	17 c1       	rjmp	.+558    	; 0x310 <__EEPROM_REGION_LENGTH__+0x110>
  e2:	69 01       	movw	r12, r18
  e4:	e4 2e       	mov	r14, r20
	{
		if(FSW_BlockFrontControls()) return;
  e6:	7d dc       	rcall	.-1798   	; 0xfffff9e2 <__eeprom_end+0xff7ef9e2>
  e8:	81 11       	cpse	r24, r1
  ea:	15 c1       	rjmp	.+554    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		
		//=============BTN CH1==========================
		if(pressedButtons->btnCh1 == BT_ON)
  ec:	ae 2d       	mov	r26, r14
  ee:	c6 01       	movw	r24, r12
  f0:	03 96       	adiw	r24, 0x03	; 3
  f2:	a1 1d       	adc	r26, r1
  f4:	fc 01       	movw	r30, r24
  f6:	84 91       	lpm	r24, Z
  f8:	a7 fd       	sbrc	r26, 7
  fa:	80 81       	ld	r24, Z
  fc:	81 11       	cpse	r24, r1
  fe:	24 c0       	rjmp	.+72     	; 0x148 <FBTNS_MainTask+0x78>
		{
			protectionInterval_cnt = BTN_PROTECTION_INTERVAL;
 100:	84 e1       	ldi	r24, 0x14	; 20
 102:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
			if(swProgrammingMode_cnt == SWITCH_MODE_DELAY)
 106:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <swProgrammingMode_cnt>
 10a:	8a 30       	cpi	r24, 0x0A	; 10
 10c:	51 f4       	brne	.+20     	; 0x122 <FBTNS_MainTask+0x52>
			{
				//enter prog mode, or save settings
				if(MIDICTRL_MidiMode() == RUNNING)
 10e:	57 dd       	rcall	.-1362   	; 0xfffffbbe <__eeprom_end+0xff7efbbe>
 110:	81 11       	cpse	r24, r1
 112:	03 c0       	rjmp	.+6      	; 0x11a <FBTNS_MainTask+0x4a>
				{
					MIDICTRL_EnterProgrammingMode();
 114:	ed da       	rcall	.-2598   	; 0xfffff6f0 <__eeprom_end+0xff7ef6f0>
					SH100CTRL_MuteAmp();
 116:	62 dd       	rcall	.-1340   	; 0xfffffbdc <__eeprom_end+0xff7efbdc>
 118:	11 c0       	rjmp	.+34     	; 0x13c <FBTNS_MainTask+0x6c>
				}
				else
				{
					MIDICTRL_StoreUserCommands();
 11a:	ad da       	rcall	.-2726   	; 0xfffff676 <__eeprom_end+0xff7ef676>
					SH100CTRL_SetAmpLeds();
 11c:	84 db       	rcall	.-2296   	; 0xfffff826 <__eeprom_end+0xff7ef826>
					SH100CTRL_UnmuteAmp();
 11e:	31 dd       	rcall	.-1438   	; 0xfffffb82 <__eeprom_end+0xff7efb82>
 120:	0d c0       	rjmp	.+26     	; 0x13c <FBTNS_MainTask+0x6c>
				}
			}
			else
			{
				if(swProgrammingMode_cnt == 0)
 122:	81 11       	cpse	r24, r1
 124:	0b c0       	rjmp	.+22     	; 0x13c <FBTNS_MainTask+0x6c>
				{
					switch(MIDICTRL_MidiMode())
 126:	4b dd       	rcall	.-1386   	; 0xfffffbbe <__eeprom_end+0xff7efbbe>
 128:	88 23       	and	r24, r24
 12a:	19 f0       	breq	.+6      	; 0x132 <FBTNS_MainTask+0x62>
 12c:	81 30       	cpi	r24, 0x01	; 1
 12e:	21 f0       	breq	.+8      	; 0x138 <FBTNS_MainTask+0x68>
 130:	05 c0       	rjmp	.+10     	; 0x13c <FBTNS_MainTask+0x6c>
					{
						case RUNNING: SH100CTRL_BtnSwChannel(SH100_CHANNEL1); break;
 132:	80 e0       	ldi	r24, 0x00	; 0
 134:	ef dc       	rcall	.-1570   	; 0xfffffb14 <__eeprom_end+0xff7efb14>
 136:	02 c0       	rjmp	.+4      	; 0x13c <FBTNS_MainTask+0x6c>
						case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH1); break;
 138:	80 e0       	ldi	r24, 0x00	; 0
 13a:	5e db       	rcall	.-2372   	; 0xfffff7f8 <__eeprom_end+0xff7ef7f8>
					}
				}
				
			}
			swProgrammingMode_cnt++;
 13c:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <swProgrammingMode_cnt>
 140:	8f 5f       	subi	r24, 0xFF	; 255
 142:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <swProgrammingMode_cnt>
			return;
 146:	e7 c0       	rjmp	.+462    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		}
		else swProgrammingMode_cnt=0;
 148:	10 92 a5 01 	sts	0x01A5, r1	; 0x8001a5 <swProgrammingMode_cnt>
		
		//=============BTN CH2==========================
		if(pressedButtons->btnCh2 == BT_ON)
 14c:	ae 2d       	mov	r26, r14
 14e:	c6 01       	movw	r24, r12
 150:	04 96       	adiw	r24, 0x04	; 4
 152:	a1 1d       	adc	r26, r1
 154:	fc 01       	movw	r30, r24
 156:	84 91       	lpm	r24, Z
 158:	a7 fd       	sbrc	r26, 7
 15a:	80 81       	ld	r24, Z
 15c:	81 11       	cpse	r24, r1
 15e:	23 c0       	rjmp	.+70     	; 0x1a6 <FBTNS_MainTask+0xd6>
		{
			protectionInterval_cnt = BTN_PROTECTION_INTERVAL;
 160:	84 e1       	ldi	r24, 0x14	; 20
 162:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
			if(setFSWRelayMode_cnt == SWITCH_MODE_DELAY)
 166:	80 91 a1 01 	lds	r24, 0x01A1	; 0x8001a1 <setFSWRelayMode_cnt>
 16a:	8a 30       	cpi	r24, 0x0A	; 10
 16c:	49 f4       	brne	.+18     	; 0x180 <FBTNS_MainTask+0xb0>
			{
				if(MIDICTRL_MidiMode() == RUNNING)
 16e:	27 dd       	rcall	.-1458   	; 0xfffffbbe <__eeprom_end+0xff7efbbe>
 170:	81 11       	cpse	r24, r1
 172:	13 c0       	rjmp	.+38     	; 0x19a <FBTNS_MainTask+0xca>
				{
					FSW_SetMode(FSW_RELAY);
 174:	82 e0       	ldi	r24, 0x02	; 2
 176:	d6 dc       	rcall	.-1620   	; 0xfffffb24 <__eeprom_end+0xff7efb24>
					SH100HW_SetLedBlinkCount(LED_CH2, 2);
 178:	62 e0       	ldi	r22, 0x02	; 2
 17a:	81 e0       	ldi	r24, 0x01	; 1
 17c:	5c da       	rcall	.-2888   	; 0xfffff636 <__eeprom_end+0xff7ef636>
 17e:	0d c0       	rjmp	.+26     	; 0x19a <FBTNS_MainTask+0xca>
				}				
			}
			else
			{
				if(setFSWRelayMode_cnt == 0)
 180:	81 11       	cpse	r24, r1
 182:	0b c0       	rjmp	.+22     	; 0x19a <FBTNS_MainTask+0xca>
				{
					switch(MIDICTRL_MidiMode())
 184:	1c dd       	rcall	.-1480   	; 0xfffffbbe <__eeprom_end+0xff7efbbe>
 186:	88 23       	and	r24, r24
 188:	19 f0       	breq	.+6      	; 0x190 <FBTNS_MainTask+0xc0>
 18a:	81 30       	cpi	r24, 0x01	; 1
 18c:	21 f0       	breq	.+8      	; 0x196 <FBTNS_MainTask+0xc6>
 18e:	05 c0       	rjmp	.+10     	; 0x19a <FBTNS_MainTask+0xca>
					{
						case RUNNING: SH100CTRL_BtnSwChannel(SH100_CHANNEL2); break;
 190:	81 e0       	ldi	r24, 0x01	; 1
 192:	c0 dc       	rcall	.-1664   	; 0xfffffb14 <__eeprom_end+0xff7efb14>
 194:	02 c0       	rjmp	.+4      	; 0x19a <FBTNS_MainTask+0xca>
						case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH2); break;
 196:	81 e0       	ldi	r24, 0x01	; 1
 198:	2f db       	rcall	.-2466   	; 0xfffff7f8 <__eeprom_end+0xff7ef7f8>
					}
				}
			}
			setFSWRelayMode_cnt++;
 19a:	80 91 a1 01 	lds	r24, 0x01A1	; 0x8001a1 <setFSWRelayMode_cnt>
 19e:	8f 5f       	subi	r24, 0xFF	; 255
 1a0:	80 93 a1 01 	sts	0x01A1, r24	; 0x8001a1 <setFSWRelayMode_cnt>
			return;
 1a4:	b8 c0       	rjmp	.+368    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		}
		else setFSWRelayMode_cnt = 0;
 1a6:	10 92 a1 01 	sts	0x01A1, r1	; 0x8001a1 <setFSWRelayMode_cnt>
		
		//=============BTN CH3==========================
		if(pressedButtons->btnCh3 == BT_ON)
 1aa:	ae 2d       	mov	r26, r14
 1ac:	c6 01       	movw	r24, r12
 1ae:	05 96       	adiw	r24, 0x05	; 5
 1b0:	a1 1d       	adc	r26, r1
 1b2:	fc 01       	movw	r30, r24
 1b4:	84 91       	lpm	r24, Z
 1b6:	a7 fd       	sbrc	r26, 7
 1b8:	80 81       	ld	r24, Z
 1ba:	81 11       	cpse	r24, r1
 1bc:	22 c0       	rjmp	.+68     	; 0x202 <__EEPROM_REGION_LENGTH__+0x2>
		{
			protectionInterval_cnt = BTN_PROTECTION_INTERVAL;
 1be:	84 e1       	ldi	r24, 0x14	; 20
 1c0:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
			if(setFSWRingMode_cnt == SWITCH_MODE_DELAY)
 1c4:	80 91 a3 01 	lds	r24, 0x01A3	; 0x8001a3 <setFSWRingMode_cnt>
 1c8:	8a 30       	cpi	r24, 0x0A	; 10
 1ca:	41 f4       	brne	.+16     	; 0x1dc <FBTNS_MainTask+0x10c>
			{
				if(MIDICTRL_MidiMode() == RUNNING)
 1cc:	f8 dc       	rcall	.-1552   	; 0xfffffbbe <__eeprom_end+0xff7efbbe>
 1ce:	81 11       	cpse	r24, r1
 1d0:	12 c0       	rjmp	.+36     	; 0x1f6 <FBTNS_MainTask+0x126>
				{
					FSW_SetMode(FSW_RING);
 1d2:	a8 dc       	rcall	.-1712   	; 0xfffffb24 <__eeprom_end+0xff7efb24>
					SH100HW_SetLedBlinkCount(LED_CH3, 2);
 1d4:	62 e0       	ldi	r22, 0x02	; 2
 1d6:	82 e0       	ldi	r24, 0x02	; 2
 1d8:	2e da       	rcall	.-2980   	; 0xfffff636 <__eeprom_end+0xff7ef636>
 1da:	0d c0       	rjmp	.+26     	; 0x1f6 <FBTNS_MainTask+0x126>
				}
			}
			else
			{
				if(setFSWRingMode_cnt == 0)
 1dc:	81 11       	cpse	r24, r1
 1de:	0b c0       	rjmp	.+22     	; 0x1f6 <FBTNS_MainTask+0x126>
				{
					switch(MIDICTRL_MidiMode())
 1e0:	ee dc       	rcall	.-1572   	; 0xfffffbbe <__eeprom_end+0xff7efbbe>
 1e2:	88 23       	and	r24, r24
 1e4:	19 f0       	breq	.+6      	; 0x1ec <FBTNS_MainTask+0x11c>
 1e6:	81 30       	cpi	r24, 0x01	; 1
 1e8:	21 f0       	breq	.+8      	; 0x1f2 <FBTNS_MainTask+0x122>
 1ea:	05 c0       	rjmp	.+10     	; 0x1f6 <FBTNS_MainTask+0x126>
					{
						case RUNNING: SH100CTRL_BtnSwChannel(SH100_CHANNEL3); break;
 1ec:	82 e0       	ldi	r24, 0x02	; 2
 1ee:	92 dc       	rcall	.-1756   	; 0xfffffb14 <__eeprom_end+0xff7efb14>
 1f0:	02 c0       	rjmp	.+4      	; 0x1f6 <FBTNS_MainTask+0x126>
						case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH3); break;
 1f2:	82 e0       	ldi	r24, 0x02	; 2
 1f4:	01 db       	rcall	.-2558   	; 0xfffff7f8 <__eeprom_end+0xff7ef7f8>
					}
				}				
			}
			setFSWRingMode_cnt++;
 1f6:	80 91 a3 01 	lds	r24, 0x01A3	; 0x8001a3 <setFSWRingMode_cnt>
 1fa:	8f 5f       	subi	r24, 0xFF	; 255
 1fc:	80 93 a3 01 	sts	0x01A3, r24	; 0x8001a3 <setFSWRingMode_cnt>
			return;			
 200:	8a c0       	rjmp	.+276    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		}
		else setFSWRingMode_cnt = 0;
 202:	10 92 a3 01 	sts	0x01A3, r1	; 0x8001a3 <setFSWRingMode_cnt>
		
		//=============BTN CH4==========================
		if(pressedButtons->btnCh4 == BT_ON)
 206:	ae 2d       	mov	r26, r14
 208:	c6 01       	movw	r24, r12
 20a:	06 96       	adiw	r24, 0x06	; 6
 20c:	a1 1d       	adc	r26, r1
 20e:	fc 01       	movw	r30, r24
 210:	84 91       	lpm	r24, Z
 212:	a7 fd       	sbrc	r26, 7
 214:	80 81       	ld	r24, Z
 216:	81 11       	cpse	r24, r1
 218:	23 c0       	rjmp	.+70     	; 0x260 <__EEPROM_REGION_LENGTH__+0x60>
		{
			protectionInterval_cnt = BTN_PROTECTION_INTERVAL;
 21a:	84 e1       	ldi	r24, 0x14	; 20
 21c:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
			if(setFSWZigzagMode_cnt == SWITCH_MODE_DELAY)
 220:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <setFSWZigzagMode_cnt>
 224:	8a 30       	cpi	r24, 0x0A	; 10
 226:	49 f4       	brne	.+18     	; 0x23a <__EEPROM_REGION_LENGTH__+0x3a>
			{
				if(MIDICTRL_MidiMode() == RUNNING)
 228:	ca dc       	rcall	.-1644   	; 0xfffffbbe <__eeprom_end+0xff7efbbe>
 22a:	81 11       	cpse	r24, r1
 22c:	13 c0       	rjmp	.+38     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
				{
					FSW_SetMode(FSW_ZIGZAG);
 22e:	81 e0       	ldi	r24, 0x01	; 1
 230:	79 dc       	rcall	.-1806   	; 0xfffffb24 <__eeprom_end+0xff7efb24>
					SH100HW_SetLedBlinkCount(LED_CH4, 2);
 232:	62 e0       	ldi	r22, 0x02	; 2
 234:	83 e0       	ldi	r24, 0x03	; 3
 236:	ff d9       	rcall	.-3074   	; 0xfffff636 <__eeprom_end+0xff7ef636>
 238:	0d c0       	rjmp	.+26     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
				}
			}
			else
			{
				if(setFSWZigzagMode_cnt == 0)
 23a:	81 11       	cpse	r24, r1
 23c:	0b c0       	rjmp	.+22     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
				{
					switch(MIDICTRL_MidiMode())
 23e:	bf dc       	rcall	.-1666   	; 0xfffffbbe <__eeprom_end+0xff7efbbe>
 240:	88 23       	and	r24, r24
 242:	19 f0       	breq	.+6      	; 0x24a <__EEPROM_REGION_LENGTH__+0x4a>
 244:	81 30       	cpi	r24, 0x01	; 1
 246:	21 f0       	breq	.+8      	; 0x250 <__EEPROM_REGION_LENGTH__+0x50>
 248:	05 c0       	rjmp	.+10     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
					{
						case RUNNING: SH100CTRL_BtnSwChannel(SH100_CHANNEL4); break;
 24a:	83 e0       	ldi	r24, 0x03	; 3
 24c:	63 dc       	rcall	.-1850   	; 0xfffffb14 <__eeprom_end+0xff7efb14>
 24e:	02 c0       	rjmp	.+4      	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
						case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH4); break;
 250:	83 e0       	ldi	r24, 0x03	; 3
 252:	d2 da       	rcall	.-2652   	; 0xfffff7f8 <__eeprom_end+0xff7ef7f8>
					}
				}	
			}
			setFSWZigzagMode_cnt++;	
 254:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <setFSWZigzagMode_cnt>
 258:	8f 5f       	subi	r24, 0xFF	; 255
 25a:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <setFSWZigzagMode_cnt>
			return;
 25e:	5b c0       	rjmp	.+182    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		}
		else setFSWZigzagMode_cnt = 0;
 260:	10 92 a2 01 	sts	0x01A2, r1	; 0x8001a2 <setFSWZigzagMode_cnt>
		
		//=============BTN LOOP=========================
		if(pressedButtons->btnLoop == BT_ON)
 264:	ae 2d       	mov	r26, r14
 266:	c6 01       	movw	r24, r12
 268:	08 96       	adiw	r24, 0x08	; 8
 26a:	a1 1d       	adc	r26, r1
 26c:	fc 01       	movw	r30, r24
 26e:	84 91       	lpm	r24, Z
 270:	a7 fd       	sbrc	r26, 7
 272:	80 81       	ld	r24, Z
 274:	81 11       	cpse	r24, r1
 276:	15 c0       	rjmp	.+42     	; 0x2a2 <__EEPROM_REGION_LENGTH__+0xa2>
		{
			protectionInterval_cnt = BTN_PROTECTION_INTERVAL;
 278:	84 e1       	ldi	r24, 0x14	; 20
 27a:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>

			switch(MIDICTRL_MidiMode())
 27e:	9f dc       	rcall	.-1730   	; 0xfffffbbe <__eeprom_end+0xff7efbbe>
 280:	88 23       	and	r24, r24
 282:	19 f0       	breq	.+6      	; 0x28a <__EEPROM_REGION_LENGTH__+0x8a>
 284:	81 30       	cpi	r24, 0x01	; 1
 286:	51 f0       	breq	.+20     	; 0x29c <__EEPROM_REGION_LENGTH__+0x9c>
 288:	46 c0       	rjmp	.+140    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
			{
				case RUNNING:
				{
					if(!loopSwitched) SH100CTRL_SwLoop();
 28a:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <loopSwitched>
 28e:	81 11       	cpse	r24, r1
 290:	01 c0       	rjmp	.+2      	; 0x294 <__EEPROM_REGION_LENGTH__+0x94>
 292:	23 dc       	rcall	.-1978   	; 0xfffffada <__eeprom_end+0xff7efada>
					loopSwitched = true;
 294:	81 e0       	ldi	r24, 0x01	; 1
 296:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <loopSwitched>
					break;
 29a:	3d c0       	rjmp	.+122    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
				}
				case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_LOOP); break;
 29c:	84 e0       	ldi	r24, 0x04	; 4
 29e:	ac da       	rcall	.-2728   	; 0xfffff7f8 <__eeprom_end+0xff7ef7f8>
 2a0:	3a c0       	rjmp	.+116    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
			}
			return;
		}
		else loopSwitched = false;
 2a2:	10 92 a0 01 	sts	0x01A0, r1	; 0x8001a0 <loopSwitched>
		
		//=============BTN AB===========================
		if(pressedButtons->btnAB == BT_ON)
 2a6:	4e 2d       	mov	r20, r14
 2a8:	96 01       	movw	r18, r12
 2aa:	29 5f       	subi	r18, 0xF9	; 249
 2ac:	3f 4f       	sbci	r19, 0xFF	; 255
 2ae:	4f 4f       	sbci	r20, 0xFF	; 255
 2b0:	f9 01       	movw	r30, r18
 2b2:	84 91       	lpm	r24, Z
 2b4:	47 fd       	sbrc	r20, 7
 2b6:	80 81       	ld	r24, Z
 2b8:	81 11       	cpse	r24, r1
 2ba:	25 c0       	rjmp	.+74     	; 0x306 <__EEPROM_REGION_LENGTH__+0x106>
		{
			protectionInterval_cnt = BTN_PROTECTION_INTERVAL;
 2bc:	84 e1       	ldi	r24, 0x14	; 20
 2be:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
			if(leaveDefSettings_cnt == SWITCH_MODE_DELAY)
 2c2:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <leaveDefSettings_cnt>
 2c6:	8a 30       	cpi	r24, 0x0A	; 10
 2c8:	39 f4       	brne	.+14     	; 0x2d8 <__EEPROM_REGION_LENGTH__+0xd8>
			{
				if(MIDICTRL_MidiMode() == PROGRAMMING)
 2ca:	79 dc       	rcall	.-1806   	; 0xfffffbbe <__eeprom_end+0xff7efbbe>
 2cc:	81 30       	cpi	r24, 0x01	; 1
 2ce:	a9 f4       	brne	.+42     	; 0x2fa <__EEPROM_REGION_LENGTH__+0xfa>
				{
					MIDICTRL_DiscardCommands();
 2d0:	66 db       	rcall	.-2356   	; 0xfffff99e <__eeprom_end+0xff7ef99e>
					SH100CTRL_SetAmpLeds();
 2d2:	a9 da       	rcall	.-2734   	; 0xfffff826 <__eeprom_end+0xff7ef826>
					SH100CTRL_UnmuteAmp();
 2d4:	56 dc       	rcall	.-1876   	; 0xfffffb82 <__eeprom_end+0xff7efb82>
 2d6:	11 c0       	rjmp	.+34     	; 0x2fa <__EEPROM_REGION_LENGTH__+0xfa>
				}
			}
			else
			{				
				switch(MIDICTRL_MidiMode())
 2d8:	72 dc       	rcall	.-1820   	; 0xfffffbbe <__eeprom_end+0xff7efbbe>
 2da:	88 23       	and	r24, r24
 2dc:	19 f0       	breq	.+6      	; 0x2e4 <__EEPROM_REGION_LENGTH__+0xe4>
 2de:	81 30       	cpi	r24, 0x01	; 1
 2e0:	51 f0       	breq	.+20     	; 0x2f6 <__EEPROM_REGION_LENGTH__+0xf6>
 2e2:	0b c0       	rjmp	.+22     	; 0x2fa <__EEPROM_REGION_LENGTH__+0xfa>
				{
					case RUNNING:
					{
						if(!abSwitched) SH100CTRL_SwAB();
 2e4:	80 91 9f 01 	lds	r24, 0x019F	; 0x80019f <abSwitched>
 2e8:	81 11       	cpse	r24, r1
 2ea:	01 c0       	rjmp	.+2      	; 0x2ee <__EEPROM_REGION_LENGTH__+0xee>
 2ec:	44 dc       	rcall	.-1912   	; 0xfffffb76 <__eeprom_end+0xff7efb76>
						abSwitched = true;
 2ee:	81 e0       	ldi	r24, 0x01	; 1
 2f0:	80 93 9f 01 	sts	0x019F, r24	; 0x80019f <abSwitched>
						break;
 2f4:	02 c0       	rjmp	.+4      	; 0x2fa <__EEPROM_REGION_LENGTH__+0xfa>
					}
					case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_AB); break;
 2f6:	85 e0       	ldi	r24, 0x05	; 5
 2f8:	7f da       	rcall	.-2818   	; 0xfffff7f8 <__eeprom_end+0xff7ef7f8>
				}
			}
			leaveDefSettings_cnt++;
 2fa:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <leaveDefSettings_cnt>
 2fe:	8f 5f       	subi	r24, 0xFF	; 255
 300:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <leaveDefSettings_cnt>
			return;
 304:	08 c0       	rjmp	.+16     	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		}
		else 
		{
			leaveDefSettings_cnt=0;
 306:	10 92 a4 01 	sts	0x01A4, r1	; 0x8001a4 <leaveDefSettings_cnt>
			abSwitched = false;
 30a:	10 92 9f 01 	sts	0x019F, r1	; 0x80019f <abSwitched>
 30e:	03 c0       	rjmp	.+6      	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		}
	}
	else
	{
		protectionInterval_cnt--;
 310:	81 50       	subi	r24, 0x01	; 1
 312:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
	}
 316:	ef 90       	pop	r14
 318:	df 90       	pop	r13
 31a:	cf 90       	pop	r12
 31c:	08 95       	ret

Disassembly of section .text.__portable_avr_delay_cycles:

00001ab0 <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
    1ab0:	04 c0       	rjmp	.+8      	; 0x1aba <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
    1ab2:	61 50       	subi	r22, 0x01	; 1
    1ab4:	71 09       	sbc	r23, r1
    1ab6:	81 09       	sbc	r24, r1
    1ab8:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
    1aba:	61 15       	cp	r22, r1
    1abc:	71 05       	cpc	r23, r1
    1abe:	81 05       	cpc	r24, r1
    1ac0:	91 05       	cpc	r25, r1
    1ac2:	b9 f7       	brne	.-18     	; 0x1ab2 <__portable_avr_delay_cycles+0x2>
    1ac4:	08 95       	ret

Disassembly of section .text.initTest:

00000c62 <initTest>:
bool isAmpStarted = false;
int16_t negVdd;
int16_t posVdd;
void initTest()
{
	SH100HW_SetNewLedState(LED_PWR_GRN, LED_FAST_BLINKING);
 c62:	62 e0       	ldi	r22, 0x02	; 2
 c64:	87 e0       	ldi	r24, 0x07	; 7
 c66:	0d d6       	rcall	.+3098   	; 0x1882 <SH100HW_SetNewLedState>
	delay_ms(20000);
 c68:	66 ed       	ldi	r22, 0xD6	; 214
 c6a:	7c ed       	ldi	r23, 0xDC	; 220
 c6c:	82 e3       	ldi	r24, 0x32	; 50
 c6e:	90 e0       	ldi	r25, 0x00	; 0
 c70:	1f d7       	rcall	.+3646   	; 0x1ab0 <__portable_avr_delay_cycles>
	
	SH100HW_StartADConvertion(ADC_V_SIGNAL);
 c72:	86 e0       	ldi	r24, 0x06	; 6
 c74:	3c d7       	rcall	.+3704   	; 0x1aee <SH100HW_StartADConvertion>
	while(ADCSRA & (1<<ADSC)){}
 c76:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7fe07a>
 c7a:	86 fd       	sbrc	r24, 6
 c7c:	fc cf       	rjmp	.-8      	; 0xc76 <initTest+0x14>
		
	int32_t outLineValue = ADC;
 c7e:	60 91 78 00 	lds	r22, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7fe078>
 c82:	70 91 79 00 	lds	r23, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7fe079>
 c86:	cb 01       	movw	r24, r22
 c88:	a0 e0       	ldi	r26, 0x00	; 0
 c8a:	b0 e0       	ldi	r27, 0x00	; 0
	
	if(fabs(outLineValue - 0x3FF/2) > 100)
 c8c:	bc 01       	movw	r22, r24
 c8e:	cd 01       	movw	r24, r26
 c90:	6f 5f       	subi	r22, 0xFF	; 255
 c92:	71 40       	sbci	r23, 0x01	; 1
 c94:	81 09       	sbc	r24, r1
 c96:	91 09       	sbc	r25, r1
 c98:	49 d1       	rcall	.+658    	; 0xf2c <__floatsisf>
 c9a:	9f 77       	andi	r25, 0x7F	; 127
 c9c:	20 e0       	ldi	r18, 0x00	; 0
 c9e:	30 e0       	ldi	r19, 0x00	; 0
 ca0:	48 ec       	ldi	r20, 0xC8	; 200
 ca2:	52 e4       	ldi	r21, 0x42	; 66
 ca4:	88 d7       	rcall	.+3856   	; 0x1bb6 <__gesf2>
 ca6:	18 16       	cp	r1, r24
 ca8:	4c f4       	brge	.+18     	; 0xcbc <initTest+0x5a>
	{
		// DC on output!
		SH100HW_SetPAFailure(true);
 caa:	81 e0       	ldi	r24, 0x01	; 1
 cac:	49 d7       	rcall	.+3730   	; 0x1b40 <SH100HW_SetPAFailure>
		SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
 cae:	60 e0       	ldi	r22, 0x00	; 0
 cb0:	87 e0       	ldi	r24, 0x07	; 7
 cb2:	e7 d5       	rcall	.+3022   	; 0x1882 <SH100HW_SetNewLedState>
		SH100HW_SetNewLedState(LED_PWR_RED, LED_FAST_BLINKING);
 cb4:	62 e0       	ldi	r22, 0x02	; 2
 cb6:	88 e0       	ldi	r24, 0x08	; 8
 cb8:	e4 d5       	rcall	.+3016   	; 0x1882 <SH100HW_SetNewLedState>
 cba:	ff cf       	rjmp	.-2      	; 0xcba <initTest+0x58>
		while(1) {}
	}
	
	SH100HW_StartADConvertion(ADC_V_NEGATIVE);
 cbc:	87 e0       	ldi	r24, 0x07	; 7
 cbe:	17 d7       	rcall	.+3630   	; 0x1aee <SH100HW_StartADConvertion>
	while(ADCSRA & (1<<ADSC)){}
 cc0:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7fe07a>
 cc4:	86 fd       	sbrc	r24, 6
 cc6:	fc cf       	rjmp	.-8      	; 0xcc0 <initTest+0x5e>
		
	negVdd = ADC;
 cc8:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7fe078>
 ccc:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7fe079>
 cd0:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <negVdd+0x1>
 cd4:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <negVdd>
	
	SH100HW_StartADConvertion(ADC_V_POSITIVE);
 cd8:	80 e0       	ldi	r24, 0x00	; 0
 cda:	09 d7       	rcall	.+3602   	; 0x1aee <SH100HW_StartADConvertion>
	while(ADCSRA & (1<<ADSC)){}
 cdc:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7fe07a>
 ce0:	86 fd       	sbrc	r24, 6
 ce2:	fc cf       	rjmp	.-8      	; 0xcdc <initTest+0x7a>
		
	posVdd = ADC;
 ce4:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7fe078>
 ce8:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7fe079>
 cec:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <posVdd+0x1>
 cf0:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <posVdd>
	
	if(fabs(negVdd-posVdd) > 100)
 cf4:	60 91 10 01 	lds	r22, 0x0110	; 0x800110 <negVdd>
 cf8:	70 91 11 01 	lds	r23, 0x0111	; 0x800111 <negVdd+0x1>
 cfc:	68 1b       	sub	r22, r24
 cfe:	79 0b       	sbc	r23, r25
 d00:	07 2e       	mov	r0, r23
 d02:	00 0c       	add	r0, r0
 d04:	88 0b       	sbc	r24, r24
 d06:	99 0b       	sbc	r25, r25
 d08:	11 d1       	rcall	.+546    	; 0xf2c <__floatsisf>
 d0a:	9f 77       	andi	r25, 0x7F	; 127
 d0c:	20 e0       	ldi	r18, 0x00	; 0
 d0e:	30 e0       	ldi	r19, 0x00	; 0
 d10:	48 ec       	ldi	r20, 0xC8	; 200
 d12:	52 e4       	ldi	r21, 0x42	; 66
 d14:	50 d7       	rcall	.+3744   	; 0x1bb6 <__gesf2>
 d16:	18 16       	cp	r1, r24
 d18:	4c f4       	brge	.+18     	; 0xd2c <initTest+0xca>
	{
		// one of Vdd rail is out
		SH100HW_SetPAFailure(true);
 d1a:	81 e0       	ldi	r24, 0x01	; 1
 d1c:	11 d7       	rcall	.+3618   	; 0x1b40 <SH100HW_SetPAFailure>
		SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
 d1e:	60 e0       	ldi	r22, 0x00	; 0
 d20:	87 e0       	ldi	r24, 0x07	; 7
 d22:	af d5       	rcall	.+2910   	; 0x1882 <SH100HW_SetNewLedState>
		SH100HW_SetNewLedState(LED_PWR_RED, LED_FAST_BLINKING);
 d24:	62 e0       	ldi	r22, 0x02	; 2
 d26:	88 e0       	ldi	r24, 0x08	; 8
 d28:	ac d5       	rcall	.+2904   	; 0x1882 <SH100HW_SetNewLedState>
 d2a:	ff cf       	rjmp	.-2      	; 0xd2a <initTest+0xc8>
		while(1) {}
	}
		
	SH100HW_SetPAFailure(false);
 d2c:	80 e0       	ldi	r24, 0x00	; 0
 d2e:	08 d7       	rcall	.+3600   	; 0x1b40 <SH100HW_SetPAFailure>
	SH100CTRL_CheckOutputJacks();
 d30:	b0 d1       	rcall	.+864    	; 0x1092 <SH100CTRL_CheckOutputJacks>
	isAmpStarted = true;
 d32:	81 e0       	ldi	r24, 0x01	; 1
 d34:	80 93 a8 01 	sts	0x01A8, r24	; 0x8001a8 <isAmpStarted>
 d38:	08 95       	ret

Disassembly of section .text.ISRInit:

000018ae <ISRInit>:

#define MAIN_TIMER_PERIOD 97
void ISRInit()
{
	// Timer0 init. For main task
	TCCR0B |= 0x05; // psc = 1024
    18ae:	85 b5       	in	r24, 0x25	; 37
    18b0:	85 60       	ori	r24, 0x05	; 5
    18b2:	85 bd       	out	0x25, r24	; 37
	TIMSK0 |= 0x01; // OVF INT enable, count pulse = 100us
    18b4:	ee e6       	ldi	r30, 0x6E	; 110
    18b6:	f0 e0       	ldi	r31, 0x00	; 0
    18b8:	80 81       	ld	r24, Z
    18ba:	81 60       	ori	r24, 0x01	; 1
    18bc:	80 83       	st	Z, r24
	TCNT0 = 0xFF - MAIN_TIMER_PERIOD;
    18be:	8e e9       	ldi	r24, 0x9E	; 158
    18c0:	86 bd       	out	0x26, r24	; 38
		
	// PCINT10, interrupt for PC2 pin(SW detect)
	PCICR |= 0x02;
    18c2:	e8 e6       	ldi	r30, 0x68	; 104
    18c4:	f0 e0       	ldi	r31, 0x00	; 0
    18c6:	80 81       	ld	r24, Z
    18c8:	82 60       	ori	r24, 0x02	; 2
    18ca:	80 83       	st	Z, r24
	PCMSK1 |= 0x04;
    18cc:	ec e6       	ldi	r30, 0x6C	; 108
    18ce:	f0 e0       	ldi	r31, 0x00	; 0
    18d0:	80 81       	ld	r24, Z
    18d2:	84 60       	ori	r24, 0x04	; 4
    18d4:	80 83       	st	Z, r24
    18d6:	08 95       	ret

Disassembly of section .text.main:

00001ac6 <main>:
}

int main(void)
{
	UART_init();
    1ac6:	e8 df       	rcall	.-48     	; 0x1a98 <UART_init>
	SH100HW_Init();
    1ac8:	bf db       	rcall	.-2178   	; 0x1248 <SH100HW_Init>
	SH100CTRL_Init();
    1aca:	a7 da       	rcall	.-2738   	; 0x101a <SH100CTRL_Init>
	MIDICTRL_Init();
    1acc:	32 d0       	rcall	.+100    	; 0x1b32 <MIDICTRL_Init>
	FSW_Init();
    1ace:	1d dc       	rcall	.-1990   	; 0x130a <FSW_Init>
	
	ISRInit();	
    1ad0:	ee de       	rcall	.-548    	; 0x18ae <ISRInit>
	cpu_irq_enable();
    1ad2:	78 94       	sei
	
	initTest();
    1ad4:	c6 d8       	rcall	.-3700   	; 0xc62 <initTest>
		
    while(1)
    {
		MIDI_ParserTask();
    1ad6:	24 d8       	rcall	.-4024   	; 0xb20 <MIDI_ParserTask>
    1ad8:	fe cf       	rjmp	.-4      	; 0x1ad6 <main+0x10>

Disassembly of section .text.__vector_16:

00000dfc <__vector_16>:
	}
}

//==========================Main AMP task=======================================
ISR(TIMER0_OVF_vect)
{
 dfc:	1f 92       	push	r1
 dfe:	0f 92       	push	r0
 e00:	0f b6       	in	r0, 0x3f	; 63
 e02:	0f 92       	push	r0
 e04:	11 24       	eor	r1, r1
 e06:	cf 92       	push	r12
 e08:	df 92       	push	r13
 e0a:	ef 92       	push	r14
 e0c:	0f 93       	push	r16
 e0e:	1f 93       	push	r17
 e10:	2f 93       	push	r18
 e12:	3f 93       	push	r19
 e14:	4f 93       	push	r20
 e16:	5f 93       	push	r21
 e18:	6f 93       	push	r22
 e1a:	7f 93       	push	r23
 e1c:	8f 93       	push	r24
 e1e:	9f 93       	push	r25
 e20:	af 93       	push	r26
 e22:	bf 93       	push	r27
 e24:	ef 93       	push	r30
 e26:	ff 93       	push	r31
 e28:	cf 93       	push	r28
 e2a:	df 93       	push	r29
 e2c:	cd b7       	in	r28, 0x3d	; 61
 e2e:	de b7       	in	r29, 0x3e	; 62
 e30:	2f 97       	sbiw	r28, 0x0f	; 15
 e32:	de bf       	out	0x3e, r29	; 62
 e34:	cd bf       	out	0x3d, r28	; 61
	SH100HW_MainTask();
 e36:	73 da       	rcall	.-2842   	; 0x31e <SH100HW_MainTask>
	
	if(isAmpStarted)
 e38:	80 91 a8 01 	lds	r24, 0x01A8	; 0x8001a8 <isAmpStarted>
 e3c:	88 23       	and	r24, r24
 e3e:	19 f0       	breq	.+6      	; 0xe46 <__vector_16+0x4a>
	{
		SH100CTRL_CheckOutputJacks();
 e40:	28 d1       	rcall	.+592    	; 0x1092 <SH100CTRL_CheckOutputJacks>
		SH100HW_StartADConvertion(ADC_V_NEGATIVE);
 e42:	87 e0       	ldi	r24, 0x07	; 7
 e44:	54 d6       	rcall	.+3240   	; 0x1aee <SH100HW_StartADConvertion>
	}
	
	SH100HW_Controls_t pressedButtons = SH100HW_GetControlsState();
 e46:	8e 01       	movw	r16, r28
 e48:	0f 5f       	subi	r16, 0xFF	; 255
 e4a:	1f 4f       	sbci	r17, 0xFF	; 255
 e4c:	c8 01       	movw	r24, r16
 e4e:	88 dd       	rcall	.-1264   	; 0x960 <SH100HW_GetControlsState>
	
	MIDICTRL_SetMidiChannel(pressedButtons.midiChNum);
 e50:	89 81       	ldd	r24, Y+1	; 0x01
 e52:	b8 d6       	rcall	.+3440   	; 0x1bc4 <MIDICTRL_SetMidiChannel>
	MIDICTRL_OmniModeEn(pressedButtons.midiOmni);
 e54:	8a 81       	ldd	r24, Y+2	; 0x02
 e56:	b9 d6       	rcall	.+3442   	; 0x1bca <MIDICTRL_OmniModeEn>
	MIDICTRL_MuteCommEn(pressedButtons.midiMuteComm);
 e58:	8b 81       	ldd	r24, Y+3	; 0x03
 e5a:	ba d6       	rcall	.+3444   	; 0x1bd0 <MIDICTRL_MuteCommEn>
	
	FBTNS_MainTask(&pressedButtons);
 e5c:	68 01       	movw	r12, r16
 e5e:	80 e8       	ldi	r24, 0x80	; 128
 e60:	e8 2e       	mov	r14, r24
 e62:	8e 2d       	mov	r24, r14
 e64:	b6 01       	movw	r22, r12
 e66:	34 d9       	rcall	.-3480   	; 0xd0 <FBTNS_MainTask>
	FSW_MainTask(&pressedButtons);
 e68:	8e 2d       	mov	r24, r14
 e6a:	b6 01       	movw	r22, r12
 e6c:	7b db       	rcall	.-2314   	; 0x564 <FSW_MainTask>
	
	TCNT0 = 0xFF - MAIN_TIMER_PERIOD;
 e6e:	8e e9       	ldi	r24, 0x9E	; 158
 e70:	86 bd       	out	0x26, r24	; 38
}
 e72:	2f 96       	adiw	r28, 0x0f	; 15
 e74:	0f b6       	in	r0, 0x3f	; 63
 e76:	f8 94       	cli
 e78:	de bf       	out	0x3e, r29	; 62
 e7a:	0f be       	out	0x3f, r0	; 63
 e7c:	cd bf       	out	0x3d, r28	; 61
 e7e:	df 91       	pop	r29
 e80:	cf 91       	pop	r28
 e82:	ff 91       	pop	r31
 e84:	ef 91       	pop	r30
 e86:	bf 91       	pop	r27
 e88:	af 91       	pop	r26
 e8a:	9f 91       	pop	r25
 e8c:	8f 91       	pop	r24
 e8e:	7f 91       	pop	r23
 e90:	6f 91       	pop	r22
 e92:	5f 91       	pop	r21
 e94:	4f 91       	pop	r20
 e96:	3f 91       	pop	r19
 e98:	2f 91       	pop	r18
 e9a:	1f 91       	pop	r17
 e9c:	0f 91       	pop	r16
 e9e:	ef 90       	pop	r14
 ea0:	df 90       	pop	r13
 ea2:	cf 90       	pop	r12
 ea4:	0f 90       	pop	r0
 ea6:	0f be       	out	0x3f, r0	; 63
 ea8:	0f 90       	pop	r0
 eaa:	1f 90       	pop	r1
 eac:	18 95       	reti

Disassembly of section .text.__vector_21:

00000d3a <__vector_21>:

int16_t negVdd;
int16_t posVdd;
bool measSwitch = false;
ISR(ADC_vect)
{
 d3a:	1f 92       	push	r1
 d3c:	0f 92       	push	r0
 d3e:	0f b6       	in	r0, 0x3f	; 63
 d40:	0f 92       	push	r0
 d42:	11 24       	eor	r1, r1
 d44:	2f 93       	push	r18
 d46:	3f 93       	push	r19
 d48:	4f 93       	push	r20
 d4a:	5f 93       	push	r21
 d4c:	6f 93       	push	r22
 d4e:	7f 93       	push	r23
 d50:	8f 93       	push	r24
 d52:	9f 93       	push	r25
 d54:	af 93       	push	r26
 d56:	bf 93       	push	r27
 d58:	ef 93       	push	r30
 d5a:	ff 93       	push	r31
	if(isAmpStarted)
 d5c:	80 91 a8 01 	lds	r24, 0x01A8	; 0x8001a8 <isAmpStarted>
 d60:	88 23       	and	r24, r24
 d62:	d9 f1       	breq	.+118    	; 0xdda <__vector_21+0xa0>
	{
		if(measSwitch)
 d64:	80 91 a7 01 	lds	r24, 0x01A7	; 0x8001a7 <measSwitch>
 d68:	88 23       	and	r24, r24
 d6a:	59 f0       	breq	.+22     	; 0xd82 <__vector_21+0x48>
		{
			posVdd = ADC;
 d6c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7fe078>
 d70:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7fe079>
 d74:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <posVdd+0x1>
 d78:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <posVdd>
			measSwitch = false;
 d7c:	10 92 a7 01 	sts	0x01A7, r1	; 0x8001a7 <measSwitch>
 d80:	0d c0       	rjmp	.+26     	; 0xd9c <__vector_21+0x62>
			//SH100HW_StartADConvertion(ADC_V_NEGATIVE);
		}
		else
		{
			negVdd = ADC;
 d82:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7fe078>
 d86:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7fe079>
 d8a:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <negVdd+0x1>
 d8e:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <negVdd>
			measSwitch = true;
 d92:	81 e0       	ldi	r24, 0x01	; 1
 d94:	80 93 a7 01 	sts	0x01A7, r24	; 0x8001a7 <measSwitch>
			SH100HW_StartADConvertion(ADC_V_POSITIVE);
 d98:	80 e0       	ldi	r24, 0x00	; 0
 d9a:	a9 d6       	rcall	.+3410   	; 0x1aee <SH100HW_StartADConvertion>
		}
		
		if(fabs(negVdd-posVdd) > 100)
 d9c:	60 91 10 01 	lds	r22, 0x0110	; 0x800110 <negVdd>
 da0:	70 91 11 01 	lds	r23, 0x0111	; 0x800111 <negVdd+0x1>
 da4:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <posVdd>
 da8:	90 91 13 01 	lds	r25, 0x0113	; 0x800113 <posVdd+0x1>
 dac:	68 1b       	sub	r22, r24
 dae:	79 0b       	sbc	r23, r25
 db0:	07 2e       	mov	r0, r23
 db2:	00 0c       	add	r0, r0
 db4:	88 0b       	sbc	r24, r24
 db6:	99 0b       	sbc	r25, r25
 db8:	b9 d0       	rcall	.+370    	; 0xf2c <__floatsisf>
 dba:	9f 77       	andi	r25, 0x7F	; 127
 dbc:	20 e0       	ldi	r18, 0x00	; 0
 dbe:	30 e0       	ldi	r19, 0x00	; 0
 dc0:	48 ec       	ldi	r20, 0xC8	; 200
 dc2:	52 e4       	ldi	r21, 0x42	; 66
 dc4:	f8 d6       	rcall	.+3568   	; 0x1bb6 <__gesf2>
 dc6:	18 16       	cp	r1, r24
 dc8:	44 f4       	brge	.+16     	; 0xdda <__vector_21+0xa0>
		{
			// one of Vdd rail is out
			SH100HW_SetPAFailure(true);
 dca:	81 e0       	ldi	r24, 0x01	; 1
 dcc:	b9 d6       	rcall	.+3442   	; 0x1b40 <SH100HW_SetPAFailure>
			SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
 dce:	60 e0       	ldi	r22, 0x00	; 0
 dd0:	87 e0       	ldi	r24, 0x07	; 7
 dd2:	57 d5       	rcall	.+2734   	; 0x1882 <SH100HW_SetNewLedState>
			SH100HW_SetNewLedState(LED_PWR_RED, LED_FAST_BLINKING);
 dd4:	62 e0       	ldi	r22, 0x02	; 2
 dd6:	88 e0       	ldi	r24, 0x08	; 8
 dd8:	54 d5       	rcall	.+2728   	; 0x1882 <SH100HW_SetNewLedState>
		}
	}
}
 dda:	ff 91       	pop	r31
 ddc:	ef 91       	pop	r30
 dde:	bf 91       	pop	r27
 de0:	af 91       	pop	r26
 de2:	9f 91       	pop	r25
 de4:	8f 91       	pop	r24
 de6:	7f 91       	pop	r23
 de8:	6f 91       	pop	r22
 dea:	5f 91       	pop	r21
 dec:	4f 91       	pop	r20
 dee:	3f 91       	pop	r19
 df0:	2f 91       	pop	r18
 df2:	0f 90       	pop	r0
 df4:	0f be       	out	0x3f, r0	; 63
 df6:	0f 90       	pop	r0
 df8:	1f 90       	pop	r1
 dfa:	18 95       	reti

Disassembly of section .text.__vector_4:

0000149a <__vector_4>:

//=========================PWR Turn off INT=================================
ISR(PCINT1_vect)
{
    149a:	1f 92       	push	r1
    149c:	0f 92       	push	r0
    149e:	0f b6       	in	r0, 0x3f	; 63
    14a0:	0f 92       	push	r0
    14a2:	11 24       	eor	r1, r1
    14a4:	2f 93       	push	r18
    14a6:	3f 93       	push	r19
    14a8:	4f 93       	push	r20
    14aa:	5f 93       	push	r21
    14ac:	6f 93       	push	r22
    14ae:	7f 93       	push	r23
    14b0:	8f 93       	push	r24
    14b2:	9f 93       	push	r25
    14b4:	af 93       	push	r26
    14b6:	bf 93       	push	r27
    14b8:	ef 93       	push	r30
    14ba:	ff 93       	push	r31
	SH100CTRL_StoreAmpState();
    14bc:	a0 d2       	rcall	.+1344   	; 0x19fe <SH100CTRL_StoreAmpState>
	SH100CTRL_MuteAmp();
    14be:	8e d3       	rcall	.+1820   	; 0x1bdc <SH100CTRL_MuteAmp>
}
    14c0:	ff 91       	pop	r31
    14c2:	ef 91       	pop	r30
    14c4:	bf 91       	pop	r27
    14c6:	af 91       	pop	r26
    14c8:	9f 91       	pop	r25
    14ca:	8f 91       	pop	r24
    14cc:	7f 91       	pop	r23
    14ce:	6f 91       	pop	r22
    14d0:	5f 91       	pop	r21
    14d2:	4f 91       	pop	r20
    14d4:	3f 91       	pop	r19
    14d6:	2f 91       	pop	r18
    14d8:	0f 90       	pop	r0
    14da:	0f be       	out	0x3f, r0	; 63
    14dc:	0f 90       	pop	r0
    14de:	1f 90       	pop	r1
    14e0:	18 95       	reti

Disassembly of section .text.MIDI_IsStatusWord:

00001bae <MIDI_IsStatusWord>:
#include "midi.h"

bool MIDI_IsStatusWord(uint8_t word)
{
	return (word & 0x80);
}
    1bae:	88 1f       	adc	r24, r24
    1bb0:	88 27       	eor	r24, r24
    1bb2:	88 1f       	adc	r24, r24
    1bb4:	08 95       	ret

Disassembly of section .text.MIDI_IsSysRealTime:

00001b6a <MIDI_IsSysRealTime>:

bool MIDI_IsSysRealTime(uint8_t word)
{
	return word > 0xF7;
    1b6a:	91 e0       	ldi	r25, 0x01	; 1
    1b6c:	88 3f       	cpi	r24, 0xF8	; 248
    1b6e:	08 f4       	brcc	.+2      	; 0x1b72 <MIDI_IsSysRealTime+0x8>
    1b70:	90 e0       	ldi	r25, 0x00	; 0
}
    1b72:	89 2f       	mov	r24, r25
    1b74:	08 95       	ret

Disassembly of section .text.MIDI_GetStatusType:

0000110a <MIDI_GetStatusType>:

MIDI_StatusType_t MIDI_GetStatusType(MIDI_Status_t status)
{
	switch(status)
    110a:	82 3f       	cpi	r24, 0xF2	; 242
    110c:	01 f1       	breq	.+64     	; 0x114e <MIDI_GetStatusType+0x44>
    110e:	68 f4       	brcc	.+26     	; 0x112a <MIDI_GetStatusType+0x20>
    1110:	8e 30       	cpi	r24, 0x0E	; 14
    1112:	28 f4       	brcc	.+10     	; 0x111e <MIDI_GetStatusType+0x14>
    1114:	8c 30       	cpi	r24, 0x0C	; 12
    1116:	78 f5       	brcc	.+94     	; 0x1176 <MIDI_GetStatusType+0x6c>
    1118:	88 30       	cpi	r24, 0x08	; 8
    111a:	c8 f4       	brcc	.+50     	; 0x114e <MIDI_GetStatusType+0x44>
    111c:	2a c0       	rjmp	.+84     	; 0x1172 <MIDI_GetStatusType+0x68>
    111e:	80 3f       	cpi	r24, 0xF0	; 240
    1120:	21 f1       	breq	.+72     	; 0x116a <MIDI_GetStatusType+0x60>
    1122:	48 f5       	brcc	.+82     	; 0x1176 <MIDI_GetStatusType+0x6c>
    1124:	8e 30       	cpi	r24, 0x0E	; 14
    1126:	99 f0       	breq	.+38     	; 0x114e <MIDI_GetStatusType+0x44>
    1128:	24 c0       	rjmp	.+72     	; 0x1172 <MIDI_GetStatusType+0x68>
    112a:	8a 3f       	cpi	r24, 0xFA	; 250
    112c:	a1 f0       	breq	.+40     	; 0x1156 <MIDI_GetStatusType+0x4c>
    112e:	38 f4       	brcc	.+14     	; 0x113e <MIDI_GetStatusType+0x34>
    1130:	87 3f       	cpi	r24, 0xF7	; 247
    1132:	e9 f0       	breq	.+58     	; 0x116e <MIDI_GetStatusType+0x64>
    1134:	88 3f       	cpi	r24, 0xF8	; 248
    1136:	69 f0       	breq	.+26     	; 0x1152 <MIDI_GetStatusType+0x48>
    1138:	83 3f       	cpi	r24, 0xF3	; 243
    113a:	e9 f0       	breq	.+58     	; 0x1176 <MIDI_GetStatusType+0x6c>
    113c:	1a c0       	rjmp	.+52     	; 0x1172 <MIDI_GetStatusType+0x68>
    113e:	8c 3f       	cpi	r24, 0xFC	; 252
    1140:	71 f0       	breq	.+28     	; 0x115e <MIDI_GetStatusType+0x54>
    1142:	58 f0       	brcs	.+22     	; 0x115a <MIDI_GetStatusType+0x50>
    1144:	8e 3f       	cpi	r24, 0xFE	; 254
    1146:	69 f0       	breq	.+26     	; 0x1162 <MIDI_GetStatusType+0x58>
    1148:	8f 3f       	cpi	r24, 0xFF	; 255
    114a:	69 f0       	breq	.+26     	; 0x1166 <MIDI_GetStatusType+0x5c>
    114c:	12 c0       	rjmp	.+36     	; 0x1172 <MIDI_GetStatusType+0x68>
	{
		// Status messages with 2 bytes
		case MIDI_COMM_NOTE_OFF: return MIDI_TYPE_TWO_BYTE;
    114e:	82 e0       	ldi	r24, 0x02	; 2
    1150:	08 95       	ret
		case MIDI_COMM_CHANNEL_PRESSURE: return MIDI_TYPE_ONE_BYTE;
		case MIDI_COMM_TIME_CODE: return MIDI_TYPE_ONE_BYTE;
		case MIDI_COMM_SONG_SELECT: return MIDI_TYPE_ONE_BYTE;

		// System real-time messages(no data bytes)
		case MIDI_COMM_TIMING_CLOCK: return MIDI_TYPE_REAL_TIME;
    1152:	83 e0       	ldi	r24, 0x03	; 3
    1154:	08 95       	ret
		case MIDI_COMM_START: return MIDI_TYPE_REAL_TIME;
    1156:	83 e0       	ldi	r24, 0x03	; 3
    1158:	08 95       	ret
		case MIDI_COMM_CONTINUE: return MIDI_TYPE_REAL_TIME;
    115a:	83 e0       	ldi	r24, 0x03	; 3
    115c:	08 95       	ret
		case MIDI_COMM_STO: return MIDI_TYPE_REAL_TIME;
    115e:	83 e0       	ldi	r24, 0x03	; 3
    1160:	08 95       	ret
		case MIDI_COMM_ACTIVE_SENSING: return MIDI_TYPE_REAL_TIME;
    1162:	83 e0       	ldi	r24, 0x03	; 3
    1164:	08 95       	ret
		case MIDI_COMM_SYSTEM_RESET: return MIDI_TYPE_REAL_TIME;
    1166:	83 e0       	ldi	r24, 0x03	; 3
    1168:	08 95       	ret

		// System exclusive
		case MIDI_COMM_START_SYS_EX: return MIDI_TYPE_START_SYS_EX;
    116a:	84 e0       	ldi	r24, 0x04	; 4
    116c:	08 95       	ret
		case MIDI_COMM_STOP_SYS_EX: return MIDI_TYPE_STOP_SYS_EX;
    116e:	85 e0       	ldi	r24, 0x05	; 5
    1170:	08 95       	ret
		
		default: return MIDI_TYPE_UNDEFINED;
    1172:	80 e0       	ldi	r24, 0x00	; 0
    1174:	08 95       	ret
		case MIDI_COMM_CONTROL_CHANGE: return MIDI_TYPE_TWO_BYTE;
		case MIDI_COMM_PITCH_BEND: return MIDI_TYPE_TWO_BYTE;
		case MIDI_COMM_SONG_POSITION: return MIDI_TYPE_TWO_BYTE;

		// Status messages with 1 byte
		case MIDI_COMM_PROGRAM_CHANGE: return MIDI_TYPE_ONE_BYTE;
    1176:	81 e0       	ldi	r24, 0x01	; 1
		case MIDI_COMM_START_SYS_EX: return MIDI_TYPE_START_SYS_EX;
		case MIDI_COMM_STOP_SYS_EX: return MIDI_TYPE_STOP_SYS_EX;
		
		default: return MIDI_TYPE_UNDEFINED;
	}
    1178:	08 95       	ret

Disassembly of section .text.isEqualCommands:

00001570 <isEqualCommands>:

void indicateMidiError();

bool isEqualCommands(const MIDI_Command_t* commandRecieved, const MIDI_Command_t* commandSaved)
{
	if(commandRecieved->status != commandSaved->status) return false;
    1570:	fb 01       	movw	r30, r22
    1572:	54 91       	lpm	r21, Z
    1574:	87 fd       	sbrc	r24, 7
    1576:	50 81       	ld	r21, Z
    1578:	f9 01       	movw	r30, r18
    157a:	94 91       	lpm	r25, Z
    157c:	47 fd       	sbrc	r20, 7
    157e:	90 81       	ld	r25, Z
    1580:	59 13       	cpse	r21, r25
    1582:	13 c0       	rjmp	.+38     	; 0x15aa <isEqualCommands+0x3a>
	if(commandRecieved->data1 != commandSaved->data1) return false;
    1584:	a8 2f       	mov	r26, r24
    1586:	cb 01       	movw	r24, r22
    1588:	02 96       	adiw	r24, 0x02	; 2
    158a:	a1 1d       	adc	r26, r1
    158c:	fc 01       	movw	r30, r24
    158e:	94 91       	lpm	r25, Z
    1590:	a7 fd       	sbrc	r26, 7
    1592:	90 81       	ld	r25, Z
    1594:	2e 5f       	subi	r18, 0xFE	; 254
    1596:	3f 4f       	sbci	r19, 0xFF	; 255
    1598:	4f 4f       	sbci	r20, 0xFF	; 255
    159a:	f9 01       	movw	r30, r18
    159c:	84 91       	lpm	r24, Z
    159e:	47 fd       	sbrc	r20, 7
    15a0:	80 81       	ld	r24, Z
    15a2:	98 17       	cp	r25, r24
    15a4:	21 f0       	breq	.+8      	; 0x15ae <isEqualCommands+0x3e>
    15a6:	80 e0       	ldi	r24, 0x00	; 0
    15a8:	08 95       	ret

void indicateMidiError();

bool isEqualCommands(const MIDI_Command_t* commandRecieved, const MIDI_Command_t* commandSaved)
{
	if(commandRecieved->status != commandSaved->status) return false;
    15aa:	80 e0       	ldi	r24, 0x00	; 0
    15ac:	08 95       	ret
	if(commandRecieved->data1 != commandSaved->data1) return false;
			
	return true;
    15ae:	81 e0       	ldi	r24, 0x01	; 1
}
    15b0:	08 95       	ret

Disassembly of section .text.loadCommSetFromMemory:

00000eae <loadCommSetFromMemory>:

void loadCommSetFromMemory()
{
 eae:	cf 93       	push	r28
 eb0:	df 93       	push	r29
 eb2:	cd b7       	in	r28, 0x3d	; 61
 eb4:	de b7       	in	r29, 0x3e	; 62
 eb6:	68 97       	sbiw	r28, 0x18	; 24
 eb8:	0f b6       	in	r0, 0x3f	; 63
 eba:	f8 94       	cli
 ebc:	de bf       	out	0x3e, r29	; 62
 ebe:	0f be       	out	0x3f, r0	; 63
 ec0:	cd bf       	out	0x3d, r28	; 61
	uint16_t readedMagicWord = eeprom_read_word((uint16_t*)0x02);
 ec2:	62 e0       	ldi	r22, 0x02	; 2
 ec4:	70 e0       	ldi	r23, 0x00	; 0
 ec6:	80 e8       	ldi	r24, 0x80	; 128
 ec8:	62 d6       	rcall	.+3268   	; 0x1b8e <eeprom_read_word>
		
	if(readedMagicWord == MEMORY_MAGIC_WORD)
 eca:	8b 3a       	cpi	r24, 0xAB	; 171
 ecc:	9c 4a       	sbci	r25, 0xAC	; 172
 ece:	c1 f4       	brne	.+48     	; 0xf00 <loadCommSetFromMemory+0x52>
	{
		// memory is not empty. Load EEPROM values
		uint8_t readedData[sizeof(MIDICTRL_CommandBlock_t)];
		eeprom_read_block(&readedData, (void*)MEMORY_USER_COMMANDS_OFFSET, sizeof(MIDICTRL_CommandBlock_t));
 ed0:	4f e0       	ldi	r20, 0x0F	; 15
 ed2:	50 e0       	ldi	r21, 0x00	; 0
 ed4:	60 e8       	ldi	r22, 0x80	; 128
 ed6:	28 e1       	ldi	r18, 0x18	; 24
 ed8:	30 e0       	ldi	r19, 0x00	; 0
 eda:	ce 01       	movw	r24, r28
 edc:	01 96       	adiw	r24, 0x01	; 1
 ede:	4d d5       	rcall	.+2714   	; 0x197a <eeprom_read_block>
		MIDICTRL_CommandBlock_t* userCommands_ptr = (MIDICTRL_CommandBlock_t*)readedData;
		userCommands = *userCommands_ptr;
 ee0:	88 e1       	ldi	r24, 0x18	; 24
 ee2:	fe 01       	movw	r30, r28
 ee4:	31 96       	adiw	r30, 0x01	; 1
 ee6:	ac e1       	ldi	r26, 0x1C	; 28
 ee8:	b1 e0       	ldi	r27, 0x01	; 1
 eea:	01 90       	ld	r0, Z+
 eec:	0d 92       	st	X+, r0
 eee:	8a 95       	dec	r24
 ef0:	e1 f7       	brne	.-8      	; 0xeea <loadCommSetFromMemory+0x3c>
			
		commandSet = eeprom_read_byte((uint8_t*)MEMORY_COMMAND_BLOCK_TYPE_OFFSET);
 ef2:	6e e0       	ldi	r22, 0x0E	; 14
 ef4:	70 e0       	ldi	r23, 0x00	; 0
 ef6:	80 e8       	ldi	r24, 0x80	; 128
 ef8:	04 d6       	rcall	.+3080   	; 0x1b02 <eeprom_read_byte>
 efa:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <commandSet>
 efe:	0b c0       	rjmp	.+22     	; 0xf16 <loadCommSetFromMemory+0x68>
	}
	else
	{
		// memory empty. Load default values
		userCommands = defaultCommands;
 f00:	88 e1       	ldi	r24, 0x18	; 24
 f02:	e5 e8       	ldi	r30, 0x85	; 133
 f04:	f1 e0       	ldi	r31, 0x01	; 1
 f06:	ac e1       	ldi	r26, 0x1C	; 28
 f08:	b1 e0       	ldi	r27, 0x01	; 1
 f0a:	01 90       	ld	r0, Z+
 f0c:	0d 92       	st	X+, r0
 f0e:	8a 95       	dec	r24
 f10:	e1 f7       	brne	.-8      	; 0xf0a <loadCommSetFromMemory+0x5c>
		commandSet = DEFAULT;
 f12:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <commandSet>
	}
}
 f16:	68 96       	adiw	r28, 0x18	; 24
 f18:	0f b6       	in	r0, 0x3f	; 63
 f1a:	f8 94       	cli
 f1c:	de bf       	out	0x3e, r29	; 62
 f1e:	0f be       	out	0x3f, r0	; 63
 f20:	cd bf       	out	0x3d, r28	; 61
 f22:	df 91       	pop	r29
 f24:	cf 91       	pop	r28
 f26:	08 95       	ret

Disassembly of section .text.setMidiLeds:

00001360 <setMidiLeds>:

void setMidiLeds()
{
    1360:	cf 93       	push	r28
	if(mode == PROGRAMMING)
    1362:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode>
    1366:	81 30       	cpi	r24, 0x01	; 1
    1368:	11 f5       	brne	.+68     	; 0x13ae <setMidiLeds+0x4e>
    136a:	18 c0       	rjmp	.+48     	; 0x139c <setMidiLeds+0x3c>
	{
		for(uint8_t i=0; i<MIDI_PROG_BTN_COUNT; i++)
		{
			switch(midiProgBtnState[i])
    136c:	ec 2f       	mov	r30, r28
    136e:	f0 e0       	ldi	r31, 0x00	; 0
    1370:	eb 5e       	subi	r30, 0xEB	; 235
    1372:	fe 4f       	sbci	r31, 0xFE	; 254
    1374:	80 81       	ld	r24, Z
    1376:	81 30       	cpi	r24, 0x01	; 1
    1378:	41 f0       	breq	.+16     	; 0x138a <setMidiLeds+0x2a>
    137a:	18 f0       	brcs	.+6      	; 0x1382 <setMidiLeds+0x22>
    137c:	82 30       	cpi	r24, 0x02	; 2
    137e:	49 f0       	breq	.+18     	; 0x1392 <setMidiLeds+0x32>
    1380:	0b c0       	rjmp	.+22     	; 0x1398 <setMidiLeds+0x38>
			{
				case PROG_CLEAR: SH100HW_SetNewLedState(i, LED_OFF); break;
    1382:	60 e0       	ldi	r22, 0x00	; 0
    1384:	8c 2f       	mov	r24, r28
    1386:	7d d2       	rcall	.+1274   	; 0x1882 <SH100HW_SetNewLedState>
    1388:	07 c0       	rjmp	.+14     	; 0x1398 <setMidiLeds+0x38>
				case PROG_ACTING: SH100HW_SetNewLedState(i, LED_FAST_BLINKING); break;
    138a:	62 e0       	ldi	r22, 0x02	; 2
    138c:	8c 2f       	mov	r24, r28
    138e:	79 d2       	rcall	.+1266   	; 0x1882 <SH100HW_SetNewLedState>
    1390:	03 c0       	rjmp	.+6      	; 0x1398 <setMidiLeds+0x38>
				case PROG_PROGRAMMED: SH100HW_SetNewLedState(i, LED_ON); break;
    1392:	61 e0       	ldi	r22, 0x01	; 1
    1394:	8c 2f       	mov	r24, r28
    1396:	75 d2       	rcall	.+1258   	; 0x1882 <SH100HW_SetNewLedState>

void setMidiLeds()
{
	if(mode == PROGRAMMING)
	{
		for(uint8_t i=0; i<MIDI_PROG_BTN_COUNT; i++)
    1398:	cf 5f       	subi	r28, 0xFF	; 255
    139a:	01 c0       	rjmp	.+2      	; 0x139e <setMidiLeds+0x3e>
    139c:	c0 e0       	ldi	r28, 0x00	; 0
    139e:	c6 30       	cpi	r28, 0x06	; 6
    13a0:	28 f3       	brcs	.-54     	; 0x136c <setMidiLeds+0xc>
				case PROG_ACTING: SH100HW_SetNewLedState(i, LED_FAST_BLINKING); break;
				case PROG_PROGRAMMED: SH100HW_SetNewLedState(i, LED_ON); break;
			}
		}
		
		if(currentErrBtnId != MIDI_PROG_BTN_UNDEFINED)
    13a2:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <currentErrBtnId>
    13a6:	8f 3f       	cpi	r24, 0xFF	; 255
    13a8:	11 f0       	breq	.+4      	; 0x13ae <setMidiLeds+0x4e>
		{
			SH100HW_SetNewLedState(currentErrBtnId, LED_ON);
    13aa:	61 e0       	ldi	r22, 0x01	; 1
    13ac:	6a d2       	rcall	.+1236   	; 0x1882 <SH100HW_SetNewLedState>
		}
	}
}
    13ae:	cf 91       	pop	r28
    13b0:	08 95       	ret

Disassembly of section .text.MIDICTRL_Init:

00001b32 <MIDICTRL_Init>:

void MIDICTRL_Init()
{	
	currentErrBtnId = MIDI_PROG_BTN_UNDEFINED;
    1b32:	8f ef       	ldi	r24, 0xFF	; 255
    1b34:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <currentErrBtnId>
	
	loadCommSetFromMemory();
    1b38:	ba d9       	rcall	.-3212   	; 0xeae <loadCommSetFromMemory>
	mode = RUNNING;
    1b3a:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <mode>
    1b3e:	08 95       	ret

Disassembly of section .text.MIDICTRL_MidiMode:

00001bbe <MIDICTRL_MidiMode>:
}

MIDICTRL_Mode_t MIDICTRL_MidiMode()
{
	return mode;
}
    1bbe:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode>
    1bc2:	08 95       	ret

Disassembly of section .text.MIDICTRL_SetProgrammingButton:

000017f8 <MIDICTRL_SetProgrammingButton>:

void MIDICTRL_SetProgrammingButton(uint8_t progBtnId)
{
	if(midiProgBtnState[currentProgBtn] == PROG_ACTING) 
    17f8:	20 91 34 01 	lds	r18, 0x0134	; 0x800134 <currentProgBtn>
    17fc:	30 e0       	ldi	r19, 0x00	; 0
    17fe:	f9 01       	movw	r30, r18
    1800:	eb 5e       	subi	r30, 0xEB	; 235
    1802:	fe 4f       	sbci	r31, 0xFE	; 254
    1804:	90 81       	ld	r25, Z
    1806:	91 30       	cpi	r25, 0x01	; 1
    1808:	21 f4       	brne	.+8      	; 0x1812 <MIDICTRL_SetProgrammingButton+0x1a>
	{
		midiProgBtnState[currentProgBtn] = PROG_CLEAR;
    180a:	f9 01       	movw	r30, r18
    180c:	eb 5e       	subi	r30, 0xEB	; 235
    180e:	fe 4f       	sbci	r31, 0xFE	; 254
    1810:	10 82       	st	Z, r1
	}
	
	currentProgBtn = progBtnId;
    1812:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <currentProgBtn>
	midiProgBtnState[currentProgBtn] = PROG_ACTING;
    1816:	e8 2f       	mov	r30, r24
    1818:	f0 e0       	ldi	r31, 0x00	; 0
    181a:	eb 5e       	subi	r30, 0xEB	; 235
    181c:	fe 4f       	sbci	r31, 0xFE	; 254
    181e:	81 e0       	ldi	r24, 0x01	; 1
    1820:	80 83       	st	Z, r24
	setMidiLeds();
    1822:	9e dd       	rcall	.-1220   	; 0x1360 <setMidiLeds>
    1824:	08 95       	ret

Disassembly of section .text.MIDICTRL_EnterProgrammingMode:

000016f0 <MIDICTRL_EnterProgrammingMode>:
	mode = RUNNING;
}

void MIDICTRL_EnterProgrammingMode()
{	
	mode = PROGRAMMING;
    16f0:	81 e0       	ldi	r24, 0x01	; 1
    16f2:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <mode>
	MIDI_SetRetranslateState(false);
    16f6:	80 e0       	ldi	r24, 0x00	; 0
    16f8:	6e d2       	rcall	.+1244   	; 0x1bd6 <MIDI_SetRetranslateState>
	
	for(uint8_t i=0; i<MIDI_PROG_BTN_COUNT;i++)
    16fa:	80 e0       	ldi	r24, 0x00	; 0
    16fc:	06 c0       	rjmp	.+12     	; 0x170a <MIDICTRL_EnterProgrammingMode+0x1a>
		midiProgBtnState[i] = PROG_CLEAR;
    16fe:	e8 2f       	mov	r30, r24
    1700:	f0 e0       	ldi	r31, 0x00	; 0
    1702:	eb 5e       	subi	r30, 0xEB	; 235
    1704:	fe 4f       	sbci	r31, 0xFE	; 254
    1706:	10 82       	st	Z, r1
void MIDICTRL_EnterProgrammingMode()
{	
	mode = PROGRAMMING;
	MIDI_SetRetranslateState(false);
	
	for(uint8_t i=0; i<MIDI_PROG_BTN_COUNT;i++)
    1708:	8f 5f       	subi	r24, 0xFF	; 255
    170a:	86 30       	cpi	r24, 0x06	; 6
    170c:	c0 f3       	brcs	.-16     	; 0x16fe <MIDICTRL_EnterProgrammingMode+0xe>
		midiProgBtnState[i] = PROG_CLEAR;
		
	SH100HW_SetNewLedState(LED_PWR_GRN, LED_SLOW_BLINKING);
    170e:	63 e0       	ldi	r22, 0x03	; 3
    1710:	87 e0       	ldi	r24, 0x07	; 7
    1712:	b7 d0       	rcall	.+366    	; 0x1882 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_PWR_RED, LED_SLOW_BLINKING);
    1714:	63 e0       	ldi	r22, 0x03	; 3
    1716:	88 e0       	ldi	r24, 0x08	; 8
    1718:	b4 d0       	rcall	.+360    	; 0x1882 <SH100HW_SetNewLedState>
	
	SH100HW_SetNewLedState(LED_B, LED_OFF);
    171a:	60 e0       	ldi	r22, 0x00	; 0
    171c:	86 e0       	ldi	r24, 0x06	; 6
    171e:	b1 d0       	rcall	.+354    	; 0x1882 <SH100HW_SetNewLedState>
	
	MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH1);	
    1720:	80 e0       	ldi	r24, 0x00	; 0
    1722:	6a d0       	rcall	.+212    	; 0x17f8 <MIDICTRL_SetProgrammingButton>
	setMidiLeds();
    1724:	1d de       	rcall	.-966    	; 0x1360 <setMidiLeds>
    1726:	08 95       	ret

Disassembly of section .text.MIDICTRL_SetMidiChannel:

00001bc4 <MIDICTRL_SetMidiChannel>:
	setMidiLeds();
}

void MIDICTRL_SetMidiChannel(uint8_t midiChNum)
{
	channelNum = midiChNum;
    1bc4:	80 93 a9 01 	sts	0x01A9, r24	; 0x8001a9 <channelNum>
    1bc8:	08 95       	ret

Disassembly of section .text.MIDICTRL_OmniModeEn:

00001bca <MIDICTRL_OmniModeEn>:
}

void MIDICTRL_OmniModeEn(bool isEnabled)
{
	omniModeEnabled = isEnabled;
    1bca:	80 93 ab 01 	sts	0x01AB, r24	; 0x8001ab <omniModeEnabled>
    1bce:	08 95       	ret

Disassembly of section .text.MIDICTRL_MuteCommEn:

00001bd0 <MIDICTRL_MuteCommEn>:
}

void MIDICTRL_MuteCommEn(bool isEnabled)
{
	muteCommandEnabled = isEnabled;
    1bd0:	80 93 aa 01 	sts	0x01AA, r24	; 0x8001aa <muteCommandEnabled>
    1bd4:	08 95       	ret

Disassembly of section .text.programmBtn:

0000144e <programmBtn>:
}

void programmBtn(MIDI_Command_t* targetComm, const MIDI_Command_t* srcComm, uint8_t targetBtnId)
{
    144e:	cf 92       	push	r12
    1450:	df 92       	push	r13
    1452:	ef 92       	push	r14
    1454:	dc 01       	movw	r26, r24
	if(midiProgBtnState[targetBtnId] == PROG_ACTING)
    1456:	30 e0       	ldi	r19, 0x00	; 0
    1458:	f9 01       	movw	r30, r18
    145a:	eb 5e       	subi	r30, 0xEB	; 235
    145c:	fe 4f       	sbci	r31, 0xFE	; 254
    145e:	90 81       	ld	r25, Z
    1460:	91 30       	cpi	r25, 0x01	; 1
    1462:	b9 f4       	brne	.+46     	; 0x1492 <programmBtn+0x44>
    1464:	6a 01       	movw	r12, r20
    1466:	e6 2e       	mov	r14, r22
	{
		targetComm->status = srcComm->status;
    1468:	fa 01       	movw	r30, r20
    146a:	84 91       	lpm	r24, Z
    146c:	e7 fc       	sbrc	r14, 7
    146e:	80 81       	ld	r24, Z
    1470:	8c 93       	st	X, r24
		targetComm->data1 = srcComm->data1;
    1472:	82 e0       	ldi	r24, 0x02	; 2
    1474:	c8 0e       	add	r12, r24
    1476:	d1 1c       	adc	r13, r1
    1478:	e1 1c       	adc	r14, r1
    147a:	f6 01       	movw	r30, r12
    147c:	84 91       	lpm	r24, Z
    147e:	e7 fc       	sbrc	r14, 7
    1480:	80 81       	ld	r24, Z
    1482:	12 96       	adiw	r26, 0x02	; 2
    1484:	8c 93       	st	X, r24
		midiProgBtnState[targetBtnId] = PROG_PROGRAMMED;
    1486:	f9 01       	movw	r30, r18
    1488:	eb 5e       	subi	r30, 0xEB	; 235
    148a:	fe 4f       	sbci	r31, 0xFE	; 254
    148c:	82 e0       	ldi	r24, 0x02	; 2
    148e:	80 83       	st	Z, r24
		setMidiLeds();
    1490:	67 df       	rcall	.-306    	; 0x1360 <setMidiLeds>
	}
}
    1492:	ef 90       	pop	r14
    1494:	df 90       	pop	r13
    1496:	cf 90       	pop	r12
    1498:	08 95       	ret

Disassembly of section .text.MIDICTRL_SendSwChComm:

0000117a <MIDICTRL_SendSwChComm>:

void MIDICTRL_SendSwChComm(uint8_t chNum)
{
	if(mode == RUNNING)
    117a:	90 91 1b 01 	lds	r25, 0x011B	; 0x80011b <mode>
    117e:	91 11       	cpse	r25, r1
    1180:	30 c0       	rjmp	.+96     	; 0x11e2 <MIDICTRL_SendSwChComm+0x68>
	{
		MIDICTRL_CommandBlock_t* currentCommandBlock;
		if(commandSet == USER) currentCommandBlock = &userCommands;
    1182:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <commandSet>
    1186:	91 30       	cpi	r25, 0x01	; 1
    1188:	19 f4       	brne	.+6      	; 0x1190 <MIDICTRL_SendSwChComm+0x16>
    118a:	ec e1       	ldi	r30, 0x1C	; 28
    118c:	f1 e0       	ldi	r31, 0x01	; 1
    118e:	02 c0       	rjmp	.+4      	; 0x1194 <MIDICTRL_SendSwChComm+0x1a>
		else currentCommandBlock = &defaultCommands;
    1190:	e5 e8       	ldi	r30, 0x85	; 133
    1192:	f1 e0       	ldi	r31, 0x01	; 1
		
		switch(chNum)
    1194:	81 30       	cpi	r24, 0x01	; 1
    1196:	71 f0       	breq	.+28     	; 0x11b4 <MIDICTRL_SendSwChComm+0x3a>
    1198:	28 f0       	brcs	.+10     	; 0x11a4 <MIDICTRL_SendSwChComm+0x2a>
    119a:	82 30       	cpi	r24, 0x02	; 2
    119c:	99 f0       	breq	.+38     	; 0x11c4 <MIDICTRL_SendSwChComm+0x4a>
    119e:	83 30       	cpi	r24, 0x03	; 3
    11a0:	c9 f0       	breq	.+50     	; 0x11d4 <MIDICTRL_SendSwChComm+0x5a>
    11a2:	08 95       	ret
		{
			case SH100_CHANNEL1: MIDI_SendCommand(currentCommandBlock->channel1, channelNum); break;
    11a4:	60 81       	ld	r22, Z
    11a6:	71 81       	ldd	r23, Z+1	; 0x01
    11a8:	82 81       	ldd	r24, Z+2	; 0x02
    11aa:	93 81       	ldd	r25, Z+3	; 0x03
    11ac:	40 91 a9 01 	lds	r20, 0x01A9	; 0x8001a9 <channelNum>
    11b0:	f8 de       	rcall	.-528    	; 0xfa2 <MIDI_SendCommand>
    11b2:	08 95       	ret
			case SH100_CHANNEL2: MIDI_SendCommand(currentCommandBlock->channel2, channelNum); break;
    11b4:	64 81       	ldd	r22, Z+4	; 0x04
    11b6:	75 81       	ldd	r23, Z+5	; 0x05
    11b8:	86 81       	ldd	r24, Z+6	; 0x06
    11ba:	97 81       	ldd	r25, Z+7	; 0x07
    11bc:	40 91 a9 01 	lds	r20, 0x01A9	; 0x8001a9 <channelNum>
    11c0:	f0 de       	rcall	.-544    	; 0xfa2 <MIDI_SendCommand>
    11c2:	08 95       	ret
			case SH100_CHANNEL3: MIDI_SendCommand(currentCommandBlock->channel3, channelNum); break;
    11c4:	60 85       	ldd	r22, Z+8	; 0x08
    11c6:	71 85       	ldd	r23, Z+9	; 0x09
    11c8:	82 85       	ldd	r24, Z+10	; 0x0a
    11ca:	93 85       	ldd	r25, Z+11	; 0x0b
    11cc:	40 91 a9 01 	lds	r20, 0x01A9	; 0x8001a9 <channelNum>
    11d0:	e8 de       	rcall	.-560    	; 0xfa2 <MIDI_SendCommand>
    11d2:	08 95       	ret
			case SH100_CHANNEL4: MIDI_SendCommand(currentCommandBlock->channel4, channelNum); break;
    11d4:	64 85       	ldd	r22, Z+12	; 0x0c
    11d6:	75 85       	ldd	r23, Z+13	; 0x0d
    11d8:	86 85       	ldd	r24, Z+14	; 0x0e
    11da:	97 85       	ldd	r25, Z+15	; 0x0f
    11dc:	40 91 a9 01 	lds	r20, 0x01A9	; 0x8001a9 <channelNum>
    11e0:	e0 de       	rcall	.-576    	; 0xfa2 <MIDI_SendCommand>
    11e2:	08 95       	ret

Disassembly of section .text.MIDICTRL_SendLoopEnComm:

000018d8 <MIDICTRL_SendLoopEnComm>:
	}
}

void MIDICTRL_SendLoopEnComm()
{
	if(mode == RUNNING)
    18d8:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode>
    18dc:	81 11       	cpse	r24, r1
    18de:	10 c0       	rjmp	.+32     	; 0x1900 <MIDICTRL_SendLoopEnComm+0x28>
	{
		MIDICTRL_CommandBlock_t* currentCommandBlock;
		if(commandSet == USER) currentCommandBlock = &userCommands;
    18e0:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <commandSet>
    18e4:	81 30       	cpi	r24, 0x01	; 1
    18e6:	19 f4       	brne	.+6      	; 0x18ee <MIDICTRL_SendLoopEnComm+0x16>
    18e8:	ec e1       	ldi	r30, 0x1C	; 28
    18ea:	f1 e0       	ldi	r31, 0x01	; 1
    18ec:	02 c0       	rjmp	.+4      	; 0x18f2 <MIDICTRL_SendLoopEnComm+0x1a>
		else currentCommandBlock = &defaultCommands;
    18ee:	e5 e8       	ldi	r30, 0x85	; 133
    18f0:	f1 e0       	ldi	r31, 0x01	; 1
		
		MIDI_SendCommand(currentCommandBlock->loopOn, channelNum);
    18f2:	60 89       	ldd	r22, Z+16	; 0x10
    18f4:	71 89       	ldd	r23, Z+17	; 0x11
    18f6:	82 89       	ldd	r24, Z+18	; 0x12
    18f8:	93 89       	ldd	r25, Z+19	; 0x13
    18fa:	40 91 a9 01 	lds	r20, 0x01A9	; 0x8001a9 <channelNum>
    18fe:	51 db       	rcall	.-2398   	; 0xfa2 <MIDI_SendCommand>
    1900:	08 95       	ret

Disassembly of section .text.MIDICTRL_SendSwABComm:

00001902 <MIDICTRL_SendSwABComm>:
	}
}

void MIDICTRL_SendSwABComm()
{
	if(mode == RUNNING)
    1902:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode>
    1906:	81 11       	cpse	r24, r1
    1908:	10 c0       	rjmp	.+32     	; 0x192a <MIDICTRL_SendSwABComm+0x28>
	{
		MIDICTRL_CommandBlock_t* currentCommandBlock;
		if(commandSet == USER) currentCommandBlock = &userCommands;
    190a:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <commandSet>
    190e:	81 30       	cpi	r24, 0x01	; 1
    1910:	19 f4       	brne	.+6      	; 0x1918 <MIDICTRL_SendSwABComm+0x16>
    1912:	ec e1       	ldi	r30, 0x1C	; 28
    1914:	f1 e0       	ldi	r31, 0x01	; 1
    1916:	02 c0       	rjmp	.+4      	; 0x191c <MIDICTRL_SendSwABComm+0x1a>
		else currentCommandBlock = &defaultCommands;
    1918:	e5 e8       	ldi	r30, 0x85	; 133
    191a:	f1 e0       	ldi	r31, 0x01	; 1
		
		MIDI_SendCommand(currentCommandBlock->outAB, channelNum);
    191c:	64 89       	ldd	r22, Z+20	; 0x14
    191e:	75 89       	ldd	r23, Z+21	; 0x15
    1920:	86 89       	ldd	r24, Z+22	; 0x16
    1922:	97 89       	ldd	r25, Z+23	; 0x17
    1924:	40 91 a9 01 	lds	r20, 0x01A9	; 0x8001a9 <channelNum>
    1928:	3c db       	rcall	.-2440   	; 0xfa2 <MIDI_SendCommand>
    192a:	08 95       	ret

Disassembly of section .text.MIDICTRL_StoreUserCommands:

00001676 <MIDICTRL_StoreUserCommands>:
	}	
}

void MIDICTRL_StoreUserCommands()
{
	if(mode == PROGRAMMING)
    1676:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode>
    167a:	81 30       	cpi	r24, 0x01	; 1
    167c:	d1 f4       	brne	.+52     	; 0x16b2 <MIDICTRL_StoreUserCommands+0x3c>
	{
		commandSet = USER;
    167e:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <commandSet>
		
		eeprom_write_word((uint16_t*)0x02, MEMORY_MAGIC_WORD);
    1682:	6b ea       	ldi	r22, 0xAB	; 171
    1684:	7c ea       	ldi	r23, 0xAC	; 172
    1686:	82 e0       	ldi	r24, 0x02	; 2
    1688:	90 e0       	ldi	r25, 0x00	; 0
    168a:	b1 d2       	rcall	.+1378   	; 0x1bee <eeprom_write_word>
		eeprom_write_byte((void*)MEMORY_COMMAND_BLOCK_TYPE_OFFSET, commandSet);
    168c:	60 91 35 01 	lds	r22, 0x0135	; 0x800135 <commandSet>
    1690:	8e e0       	ldi	r24, 0x0E	; 14
    1692:	90 e0       	ldi	r25, 0x00	; 0
    1694:	c2 d1       	rcall	.+900    	; 0x1a1a <eeprom_write_byte>
		eeprom_write_block(&userCommands, (void*)MEMORY_USER_COMMANDS_OFFSET, sizeof(MIDICTRL_CommandBlock_t));
    1696:	6c e1       	ldi	r22, 0x1C	; 28
    1698:	71 e0       	ldi	r23, 0x01	; 1
    169a:	80 e8       	ldi	r24, 0x80	; 128
    169c:	28 e1       	ldi	r18, 0x18	; 24
    169e:	30 e0       	ldi	r19, 0x00	; 0
    16a0:	4f e0       	ldi	r20, 0x0F	; 15
    16a2:	50 e0       	ldi	r21, 0x00	; 0
    16a4:	90 d0       	rcall	.+288    	; 0x17c6 <eeprom_write_block>
		
		SH100HW_SetPreviousLedState(LED_B);
    16a6:	86 e0       	ldi	r24, 0x06	; 6
    16a8:	df d1       	rcall	.+958    	; 0x1a68 <SH100HW_SetPreviousLedState>
		MIDI_SetRetranslateState(true);
    16aa:	81 e0       	ldi	r24, 0x01	; 1
    16ac:	94 d2       	rcall	.+1320   	; 0x1bd6 <MIDI_SetRetranslateState>
		
		mode = RUNNING;
    16ae:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <mode>
    16b2:	08 95       	ret

Disassembly of section .text.MIDICTRL_DiscardCommands:

0000199e <MIDICTRL_DiscardCommands>:
	}
}

void MIDICTRL_DiscardCommands()
{
	if(mode == PROGRAMMING)
    199e:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode>
    19a2:	81 30       	cpi	r24, 0x01	; 1
    19a4:	61 f4       	brne	.+24     	; 0x19be <MIDICTRL_DiscardCommands+0x20>
	{
		commandSet = DEFAULT;
    19a6:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <commandSet>
		eeprom_write_byte((void*)MEMORY_COMMAND_BLOCK_TYPE_OFFSET, commandSet);		
    19aa:	60 e0       	ldi	r22, 0x00	; 0
    19ac:	8e e0       	ldi	r24, 0x0E	; 14
    19ae:	90 e0       	ldi	r25, 0x00	; 0
    19b0:	34 d0       	rcall	.+104    	; 0x1a1a <eeprom_write_byte>
		
		SH100HW_SetPreviousLedState(LED_B);
    19b2:	86 e0       	ldi	r24, 0x06	; 6
    19b4:	59 d0       	rcall	.+178    	; 0x1a68 <SH100HW_SetPreviousLedState>
		MIDI_SetRetranslateState(true);
    19b6:	81 e0       	ldi	r24, 0x01	; 1
    19b8:	0e d1       	rcall	.+540    	; 0x1bd6 <MIDI_SetRetranslateState>
		
		mode = RUNNING;
    19ba:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <mode>
    19be:	08 95       	ret

Disassembly of section .text.indicateMidiError:

00001728 <indicateMidiError>:

//===================ERROR indication=================
#define MIDI_ERR_TIMER_PERIOD 9765
void indicateMidiError()
{
	TCNT1 = 0xFFFF - MIDI_ERR_TIMER_PERIOD;
    1728:	8a ed       	ldi	r24, 0xDA	; 218
    172a:	99 ed       	ldi	r25, 0xD9	; 217
    172c:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <__TEXT_REGION_LENGTH__+0x7fe085>
    1730:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <__TEXT_REGION_LENGTH__+0x7fe084>
	TIMSK1 |= 0x01; // OVF INT enable, count pulse = 100us
    1734:	ef e6       	ldi	r30, 0x6F	; 111
    1736:	f0 e0       	ldi	r31, 0x00	; 0
    1738:	80 81       	ld	r24, Z
    173a:	81 60       	ori	r24, 0x01	; 1
    173c:	80 83       	st	Z, r24
	TCCR1B |= 0x05; // psc = 1024, timer on
    173e:	e1 e8       	ldi	r30, 0x81	; 129
    1740:	f0 e0       	ldi	r31, 0x00	; 0
    1742:	80 81       	ld	r24, Z
    1744:	85 60       	ori	r24, 0x05	; 5
    1746:	80 83       	st	Z, r24
	currentErrBtnId = currentProgBtn;
    1748:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <currentProgBtn>
    174c:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <currentErrBtnId>
	setMidiLeds();
    1750:	07 de       	rcall	.-1010   	; 0x1360 <setMidiLeds>
	
	SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
    1752:	60 e0       	ldi	r22, 0x00	; 0
    1754:	87 e0       	ldi	r24, 0x07	; 7
    1756:	95 d0       	rcall	.+298    	; 0x1882 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_PWR_RED, LED_ON);
    1758:	61 e0       	ldi	r22, 0x01	; 1
    175a:	88 e0       	ldi	r24, 0x08	; 8
    175c:	92 d0       	rcall	.+292    	; 0x1882 <SH100HW_SetNewLedState>
    175e:	08 95       	ret

Disassembly of section .text.MIDICTRL_HandleCommand:

0000076e <MIDICTRL_HandleCommand>:
		MIDI_SendCommand(currentCommandBlock->outAB, channelNum);
	}
}

void MIDICTRL_HandleCommand(const MIDI_Command_t* command)
{
 76e:	cf 92       	push	r12
 770:	df 92       	push	r13
 772:	ef 92       	push	r14
 774:	cf 93       	push	r28
 776:	df 93       	push	r29
 778:	6b 01       	movw	r12, r22
 77a:	e8 2e       	mov	r14, r24
	if(FSW_BlockFrontControls()) return;
 77c:	32 d9       	rcall	.-3484   	; 0xfffff9e2 <__eeprom_end+0xff7ef9e2>
 77e:	81 11       	cpse	r24, r1
 780:	e9 c0       	rjmp	.+466    	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
	
	switch(mode)
 782:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode>
 786:	88 23       	and	r24, r24
 788:	21 f0       	breq	.+8      	; 0x792 <MIDICTRL_HandleCommand+0x24>
 78a:	81 30       	cpi	r24, 0x01	; 1
 78c:	09 f4       	brne	.+2      	; 0x790 <MIDICTRL_HandleCommand+0x22>
 78e:	8f c0       	rjmp	.+286    	; 0x8ae <MIDICTRL_HandleCommand+0x140>
 790:	e1 c0       	rjmp	.+450    	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
	{
		case RUNNING:
		{
			if(!omniModeEnabled)
 792:	80 91 ab 01 	lds	r24, 0x01AB	; 0x8001ab <omniModeEnabled>
 796:	81 11       	cpse	r24, r1
 798:	0c c0       	rjmp	.+24     	; 0x7b2 <MIDICTRL_HandleCommand+0x44>
			{
				if(channelNum != command->channel_type) return;
 79a:	ae 2d       	mov	r26, r14
 79c:	c6 01       	movw	r24, r12
 79e:	01 96       	adiw	r24, 0x01	; 1
 7a0:	a1 1d       	adc	r26, r1
 7a2:	fc 01       	movw	r30, r24
 7a4:	94 91       	lpm	r25, Z
 7a6:	a7 fd       	sbrc	r26, 7
 7a8:	90 81       	ld	r25, Z
 7aa:	80 91 a9 01 	lds	r24, 0x01A9	; 0x8001a9 <channelNum>
 7ae:	98 13       	cpse	r25, r24
 7b0:	d1 c0       	rjmp	.+418    	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
			}
			
			if(muteCommandEnabled)
 7b2:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <muteCommandEnabled>
 7b6:	88 23       	and	r24, r24
 7b8:	a9 f0       	breq	.+42     	; 0x7e4 <MIDICTRL_HandleCommand+0x76>
			{
				if(isEqualCommands(command, &muteCommand)) 
 7ba:	2c ec       	ldi	r18, 0xCC	; 204
 7bc:	30 e0       	ldi	r19, 0x00	; 0
 7be:	40 e0       	ldi	r20, 0x00	; 0
 7c0:	8e 2d       	mov	r24, r14
 7c2:	b6 01       	movw	r22, r12
 7c4:	d5 d6       	rcall	.+3498   	; 0x1570 <isEqualCommands>
 7c6:	88 23       	and	r24, r24
 7c8:	69 f0       	breq	.+26     	; 0x7e4 <MIDICTRL_HandleCommand+0x76>
				{
					if((command->data2>63) ? 1 : 0) SH100CTRL_MuteAmp();
 7ca:	ae 2d       	mov	r26, r14
 7cc:	c6 01       	movw	r24, r12
 7ce:	03 96       	adiw	r24, 0x03	; 3
 7d0:	a1 1d       	adc	r26, r1
 7d2:	fc 01       	movw	r30, r24
 7d4:	84 91       	lpm	r24, Z
 7d6:	a7 fd       	sbrc	r26, 7
 7d8:	80 81       	ld	r24, Z
 7da:	80 34       	cpi	r24, 0x40	; 64
 7dc:	10 f0       	brcs	.+4      	; 0x7e2 <MIDICTRL_HandleCommand+0x74>
 7de:	fe d9       	rcall	.-3076   	; 0xfffffbdc <__eeprom_end+0xff7efbdc>
 7e0:	01 c0       	rjmp	.+2      	; 0x7e4 <MIDICTRL_HandleCommand+0x76>
					else SH100CTRL_UnmuteAmp();
 7e2:	cf d9       	rcall	.-3170   	; 0xfffffb82 <__eeprom_end+0xff7efb82>
				}
			}
			
			MIDICTRL_CommandBlock_t* currentCommandBlock;
			if(commandSet == USER) currentCommandBlock = &userCommands;
 7e4:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <commandSet>
 7e8:	81 30       	cpi	r24, 0x01	; 1
 7ea:	19 f4       	brne	.+6      	; 0x7f2 <MIDICTRL_HandleCommand+0x84>
 7ec:	cc e1       	ldi	r28, 0x1C	; 28
 7ee:	d1 e0       	ldi	r29, 0x01	; 1
 7f0:	02 c0       	rjmp	.+4      	; 0x7f6 <MIDICTRL_HandleCommand+0x88>
			else currentCommandBlock = &defaultCommands;
 7f2:	c5 e8       	ldi	r28, 0x85	; 133
 7f4:	d1 e0       	ldi	r29, 0x01	; 1
			
			// priority ch1, ch2, ch3, ch4, loop, AB. After handling, return. Only one switch by one command
			if(isEqualCommands(command, &(currentCommandBlock->channel1))) 
 7f6:	9e 01       	movw	r18, r28
 7f8:	40 e8       	ldi	r20, 0x80	; 128
 7fa:	8e 2d       	mov	r24, r14
 7fc:	b6 01       	movw	r22, r12
 7fe:	b8 d6       	rcall	.+3440   	; 0x1570 <isEqualCommands>
 800:	88 23       	and	r24, r24
 802:	19 f0       	breq	.+6      	; 0x80a <MIDICTRL_HandleCommand+0x9c>
			{
				SH100CTRL_SetChannel(0); 
 804:	80 e0       	ldi	r24, 0x00	; 0
 806:	26 d8       	rcall	.-4020   	; 0xfffff854 <__eeprom_end+0xff7ef854>
				return;
 808:	a5 c0       	rjmp	.+330    	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
			}
			if(isEqualCommands(command, &(currentCommandBlock->channel2))) 
 80a:	9e 01       	movw	r18, r28
 80c:	2c 5f       	subi	r18, 0xFC	; 252
 80e:	3f 4f       	sbci	r19, 0xFF	; 255
 810:	40 e8       	ldi	r20, 0x80	; 128
 812:	8e 2d       	mov	r24, r14
 814:	b6 01       	movw	r22, r12
 816:	ac d6       	rcall	.+3416   	; 0x1570 <isEqualCommands>
 818:	88 23       	and	r24, r24
 81a:	19 f0       	breq	.+6      	; 0x822 <MIDICTRL_HandleCommand+0xb4>
			{
				SH100CTRL_SetChannel(1); 
 81c:	81 e0       	ldi	r24, 0x01	; 1
 81e:	1a d8       	rcall	.-4044   	; 0xfffff854 <__eeprom_end+0xff7ef854>
				return;
 820:	99 c0       	rjmp	.+306    	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
			}
			if(isEqualCommands(command, &(currentCommandBlock->channel3))) 
 822:	9e 01       	movw	r18, r28
 824:	28 5f       	subi	r18, 0xF8	; 248
 826:	3f 4f       	sbci	r19, 0xFF	; 255
 828:	40 e8       	ldi	r20, 0x80	; 128
 82a:	8e 2d       	mov	r24, r14
 82c:	b6 01       	movw	r22, r12
 82e:	a0 d6       	rcall	.+3392   	; 0x1570 <isEqualCommands>
 830:	88 23       	and	r24, r24
 832:	19 f0       	breq	.+6      	; 0x83a <MIDICTRL_HandleCommand+0xcc>
			{
				SH100CTRL_SetChannel(2); 
 834:	82 e0       	ldi	r24, 0x02	; 2
 836:	0e d8       	rcall	.-4068   	; 0xfffff854 <__eeprom_end+0xff7ef854>
				return;
 838:	8d c0       	rjmp	.+282    	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
			}
			if(isEqualCommands(command, &(currentCommandBlock->channel4))) 
 83a:	9e 01       	movw	r18, r28
 83c:	24 5f       	subi	r18, 0xF4	; 244
 83e:	3f 4f       	sbci	r19, 0xFF	; 255
 840:	40 e8       	ldi	r20, 0x80	; 128
 842:	8e 2d       	mov	r24, r14
 844:	b6 01       	movw	r22, r12
 846:	94 d6       	rcall	.+3368   	; 0x1570 <isEqualCommands>
 848:	88 23       	and	r24, r24
 84a:	19 f0       	breq	.+6      	; 0x852 <MIDICTRL_HandleCommand+0xe4>
			{
				SH100CTRL_SetChannel(3); 
 84c:	83 e0       	ldi	r24, 0x03	; 3
 84e:	02 d8       	rcall	.-4092   	; 0xfffff854 <__eeprom_end+0xff7ef854>
				return;
 850:	81 c0       	rjmp	.+258    	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
			}		
			if(isEqualCommands(command, &(currentCommandBlock->loopOn))) 
 852:	9e 01       	movw	r18, r28
 854:	20 5f       	subi	r18, 0xF0	; 240
 856:	3f 4f       	sbci	r19, 0xFF	; 255
 858:	40 e8       	ldi	r20, 0x80	; 128
 85a:	8e 2d       	mov	r24, r14
 85c:	b6 01       	movw	r22, r12
 85e:	88 d6       	rcall	.+3344   	; 0x1570 <isEqualCommands>
 860:	88 23       	and	r24, r24
 862:	71 f0       	breq	.+28     	; 0x880 <MIDICTRL_HandleCommand+0x112>
			{
				SH100CTRL_SetLoop((command->data2>63) ? 1 : 0); 
 864:	83 e0       	ldi	r24, 0x03	; 3
 866:	c8 0e       	add	r12, r24
 868:	d1 1c       	adc	r13, r1
 86a:	e1 1c       	adc	r14, r1
 86c:	f6 01       	movw	r30, r12
 86e:	94 91       	lpm	r25, Z
 870:	e7 fc       	sbrc	r14, 7
 872:	90 81       	ld	r25, Z
 874:	81 e0       	ldi	r24, 0x01	; 1
 876:	90 34       	cpi	r25, 0x40	; 64
 878:	08 f4       	brcc	.+2      	; 0x87c <MIDICTRL_HandleCommand+0x10e>
 87a:	80 e0       	ldi	r24, 0x00	; 0
 87c:	57 d8       	rcall	.-3922   	; 0xfffff92c <__eeprom_end+0xff7ef92c>
				return;
 87e:	6a c0       	rjmp	.+212    	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
			}
			if(isEqualCommands(command, &(currentCommandBlock->outAB))) 
 880:	64 96       	adiw	r28, 0x14	; 20
 882:	9e 01       	movw	r18, r28
 884:	40 e8       	ldi	r20, 0x80	; 128
 886:	8e 2d       	mov	r24, r14
 888:	b6 01       	movw	r22, r12
 88a:	72 d6       	rcall	.+3300   	; 0x1570 <isEqualCommands>
 88c:	88 23       	and	r24, r24
 88e:	09 f4       	brne	.+2      	; 0x892 <MIDICTRL_HandleCommand+0x124>
 890:	61 c0       	rjmp	.+194    	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
			{
				SH100CTRL_SetAB((command->data2>63) ? 1 : 0); 
 892:	83 e0       	ldi	r24, 0x03	; 3
 894:	c8 0e       	add	r12, r24
 896:	d1 1c       	adc	r13, r1
 898:	e1 1c       	adc	r14, r1
 89a:	f6 01       	movw	r30, r12
 89c:	94 91       	lpm	r25, Z
 89e:	e7 fc       	sbrc	r14, 7
 8a0:	90 81       	ld	r25, Z
 8a2:	81 e0       	ldi	r24, 0x01	; 1
 8a4:	90 34       	cpi	r25, 0x40	; 64
 8a6:	08 f4       	brcc	.+2      	; 0x8aa <MIDICTRL_HandleCommand+0x13c>
 8a8:	80 e0       	ldi	r24, 0x00	; 0
 8aa:	55 d8       	rcall	.-3926   	; 0xfffff956 <__eeprom_end+0xff7ef956>
				return;
 8ac:	53 c0       	rjmp	.+166    	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
			break;
		}
		
		case PROGRAMMING:
		{
			if(command->status == MIDI_COMM_PROGRAM_CHANGE)
 8ae:	f6 01       	movw	r30, r12
 8b0:	84 91       	lpm	r24, Z
 8b2:	e7 fc       	sbrc	r14, 7
 8b4:	80 81       	ld	r24, Z
 8b6:	8c 30       	cpi	r24, 0x0C	; 12
 8b8:	41 f5       	brne	.+80     	; 0x90a <MIDICTRL_HandleCommand+0x19c>
			{
				switch(currentProgBtn)
 8ba:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <currentProgBtn>
 8be:	81 30       	cpi	r24, 0x01	; 1
 8c0:	69 f0       	breq	.+26     	; 0x8dc <MIDICTRL_HandleCommand+0x16e>
 8c2:	28 f0       	brcs	.+10     	; 0x8ce <MIDICTRL_HandleCommand+0x160>
 8c4:	82 30       	cpi	r24, 0x02	; 2
 8c6:	89 f0       	breq	.+34     	; 0x8ea <MIDICTRL_HandleCommand+0x17c>
 8c8:	83 30       	cpi	r24, 0x03	; 3
 8ca:	b1 f0       	breq	.+44     	; 0x8f8 <MIDICTRL_HandleCommand+0x18a>
 8cc:	1c c0       	rjmp	.+56     	; 0x906 <MIDICTRL_HandleCommand+0x198>
				{
					case MIDI_PROG_BTN_CH1: programmBtn(&(userCommands.channel1), command, MIDI_PROG_BTN_CH1); break;
 8ce:	20 e0       	ldi	r18, 0x00	; 0
 8d0:	6e 2d       	mov	r22, r14
 8d2:	a6 01       	movw	r20, r12
 8d4:	8c e1       	ldi	r24, 0x1C	; 28
 8d6:	91 e0       	ldi	r25, 0x01	; 1
 8d8:	ba d5       	rcall	.+2932   	; 0x144e <programmBtn>
 8da:	3c c0       	rjmp	.+120    	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
					case MIDI_PROG_BTN_CH2: programmBtn(&(userCommands.channel2), command, MIDI_PROG_BTN_CH2); break;
 8dc:	21 e0       	ldi	r18, 0x01	; 1
 8de:	6e 2d       	mov	r22, r14
 8e0:	a6 01       	movw	r20, r12
 8e2:	80 e2       	ldi	r24, 0x20	; 32
 8e4:	91 e0       	ldi	r25, 0x01	; 1
 8e6:	b3 d5       	rcall	.+2918   	; 0x144e <programmBtn>
 8e8:	35 c0       	rjmp	.+106    	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
					case MIDI_PROG_BTN_CH3: programmBtn(&(userCommands.channel3), command, MIDI_PROG_BTN_CH3); break;
 8ea:	22 e0       	ldi	r18, 0x02	; 2
 8ec:	6e 2d       	mov	r22, r14
 8ee:	a6 01       	movw	r20, r12
 8f0:	84 e2       	ldi	r24, 0x24	; 36
 8f2:	91 e0       	ldi	r25, 0x01	; 1
 8f4:	ac d5       	rcall	.+2904   	; 0x144e <programmBtn>
 8f6:	2e c0       	rjmp	.+92     	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
					case MIDI_PROG_BTN_CH4: programmBtn(&(userCommands.channel4), command, MIDI_PROG_BTN_CH4); break;
 8f8:	23 e0       	ldi	r18, 0x03	; 3
 8fa:	6e 2d       	mov	r22, r14
 8fc:	a6 01       	movw	r20, r12
 8fe:	88 e2       	ldi	r24, 0x28	; 40
 900:	91 e0       	ldi	r25, 0x01	; 1
 902:	a5 d5       	rcall	.+2890   	; 0x144e <programmBtn>
 904:	27 c0       	rjmp	.+78     	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
					default: indicateMidiError(); break; 
 906:	10 d7       	rcall	.+3616   	; 0x1728 <indicateMidiError>
 908:	25 c0       	rjmp	.+74     	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
				}
			}
			else if(command->status == MIDI_COMM_CONTROL_CHANGE)
 90a:	8b 30       	cpi	r24, 0x0B	; 11
 90c:	11 f5       	brne	.+68     	; 0x952 <MIDICTRL_HandleCommand+0x1e4>
			{
				if(command->data1 == muteCommand.data1)
 90e:	ae 2d       	mov	r26, r14
 910:	c6 01       	movw	r24, r12
 912:	02 96       	adiw	r24, 0x02	; 2
 914:	a1 1d       	adc	r26, r1
 916:	fc 01       	movw	r30, r24
 918:	84 91       	lpm	r24, Z
 91a:	a7 fd       	sbrc	r26, 7
 91c:	80 81       	ld	r24, Z
 91e:	87 30       	cpi	r24, 0x07	; 7
 920:	11 f4       	brne	.+4      	; 0x926 <MIDICTRL_HandleCommand+0x1b8>
				{
					indicateMidiError();
 922:	02 d7       	rcall	.+3588   	; 0x1728 <indicateMidiError>
 924:	17 c0       	rjmp	.+46     	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
				}
				else
				{
					switch(currentProgBtn)
 926:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <currentProgBtn>
 92a:	84 30       	cpi	r24, 0x04	; 4
 92c:	49 f0       	breq	.+18     	; 0x940 <MIDICTRL_HandleCommand+0x1d2>
 92e:	85 30       	cpi	r24, 0x05	; 5
 930:	71 f4       	brne	.+28     	; 0x94e <MIDICTRL_HandleCommand+0x1e0>
					{
						case MIDI_PROG_BTN_AB: programmBtn(&(userCommands.outAB), command, MIDI_PROG_BTN_AB); break;
 932:	25 e0       	ldi	r18, 0x05	; 5
 934:	6e 2d       	mov	r22, r14
 936:	a6 01       	movw	r20, r12
 938:	80 e3       	ldi	r24, 0x30	; 48
 93a:	91 e0       	ldi	r25, 0x01	; 1
 93c:	88 d5       	rcall	.+2832   	; 0x144e <programmBtn>
 93e:	0a c0       	rjmp	.+20     	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
						case MIDI_PROG_BTN_LOOP: programmBtn(&(userCommands.loopOn), command, MIDI_PROG_BTN_LOOP); break;
 940:	24 e0       	ldi	r18, 0x04	; 4
 942:	6e 2d       	mov	r22, r14
 944:	a6 01       	movw	r20, r12
 946:	8c e2       	ldi	r24, 0x2C	; 44
 948:	91 e0       	ldi	r25, 0x01	; 1
 94a:	81 d5       	rcall	.+2818   	; 0x144e <programmBtn>
 94c:	03 c0       	rjmp	.+6      	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
						default: indicateMidiError(); break;
 94e:	ec d6       	rcall	.+3544   	; 0x1728 <indicateMidiError>
 950:	01 c0       	rjmp	.+2      	; 0x954 <MIDICTRL_HandleCommand+0x1e6>
					}
				}
			}
			else
			{
				indicateMidiError();
 952:	ea d6       	rcall	.+3540   	; 0x1728 <indicateMidiError>
			}			
			break;
		}
	}	
}
 954:	df 91       	pop	r29
 956:	cf 91       	pop	r28
 958:	ef 90       	pop	r14
 95a:	df 90       	pop	r13
 95c:	cf 90       	pop	r12
 95e:	08 95       	ret

Disassembly of section .text.__vector_13:

000011e4 <__vector_13>:
	SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
	SH100HW_SetNewLedState(LED_PWR_RED, LED_ON);
}

ISR(TIMER1_OVF_vect)
{
    11e4:	1f 92       	push	r1
    11e6:	0f 92       	push	r0
    11e8:	0f b6       	in	r0, 0x3f	; 63
    11ea:	0f 92       	push	r0
    11ec:	11 24       	eor	r1, r1
    11ee:	2f 93       	push	r18
    11f0:	3f 93       	push	r19
    11f2:	4f 93       	push	r20
    11f4:	5f 93       	push	r21
    11f6:	6f 93       	push	r22
    11f8:	7f 93       	push	r23
    11fa:	8f 93       	push	r24
    11fc:	9f 93       	push	r25
    11fe:	af 93       	push	r26
    1200:	bf 93       	push	r27
    1202:	ef 93       	push	r30
    1204:	ff 93       	push	r31
	TIMSK1 |= 0x00; // OVF INT disable
    1206:	ef e6       	ldi	r30, 0x6F	; 111
    1208:	f0 e0       	ldi	r31, 0x00	; 0
    120a:	80 81       	ld	r24, Z
    120c:	80 83       	st	Z, r24
	TCCR1B |= 0x00; // psc = 0, timer off
    120e:	e1 e8       	ldi	r30, 0x81	; 129
    1210:	f0 e0       	ldi	r31, 0x00	; 0
    1212:	80 81       	ld	r24, Z
    1214:	80 83       	st	Z, r24
	currentErrBtnId = MIDI_PROG_BTN_UNDEFINED;
    1216:	8f ef       	ldi	r24, 0xFF	; 255
    1218:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <currentErrBtnId>
	setMidiLeds();
    121c:	a1 d0       	rcall	.+322    	; 0x1360 <setMidiLeds>
	
	SH100HW_SetPreviousLedState(LED_PWR_GRN);
    121e:	87 e0       	ldi	r24, 0x07	; 7
    1220:	23 d4       	rcall	.+2118   	; 0x1a68 <SH100HW_SetPreviousLedState>
	SH100HW_SetPreviousLedState(LED_PWR_RED);
    1222:	88 e0       	ldi	r24, 0x08	; 8
    1224:	21 d4       	rcall	.+2114   	; 0x1a68 <SH100HW_SetPreviousLedState>
    1226:	ff 91       	pop	r31
    1228:	ef 91       	pop	r30
    122a:	bf 91       	pop	r27
    122c:	af 91       	pop	r26
    122e:	9f 91       	pop	r25
    1230:	8f 91       	pop	r24
    1232:	7f 91       	pop	r23
    1234:	6f 91       	pop	r22
    1236:	5f 91       	pop	r21
    1238:	4f 91       	pop	r20
    123a:	3f 91       	pop	r19
    123c:	2f 91       	pop	r18
    123e:	0f 90       	pop	r0
    1240:	0f be       	out	0x3f, r0	; 63
    1242:	0f 90       	pop	r0
    1244:	1f 90       	pop	r1
    1246:	18 95       	reti

Disassembly of section .text.handleRealTimeStatus:

00001bf4 <handleRealTimeStatus>:
	HADLE_SYS_EX
}state = RESET;

void handleRealTimeStatus(MIDI_Status_t status)
{
	UART_PushWord(status);
    1bf4:	9a dc       	rcall	.-1740   	; 0x152a <UART_PushWord>
    1bf6:	08 95       	ret

Disassembly of section .text.MIDI_ParserTask:

00000b20 <MIDI_ParserTask>:
};

uint8_t recievedWord;
void MIDI_ParserTask()
{
	switch(state)
 b20:	e0 91 ac 01 	lds	r30, 0x01AC	; 0x8001ac <state>
 b24:	8e 2f       	mov	r24, r30
 b26:	90 e0       	ldi	r25, 0x00	; 0
 b28:	87 30       	cpi	r24, 0x07	; 7
 b2a:	91 05       	cpc	r25, r1
 b2c:	08 f0       	brcs	.+2      	; 0xb30 <MIDI_ParserTask+0x10>
 b2e:	98 c0       	rjmp	.+304    	; 0xc60 <MIDI_ParserTask+0x140>
 b30:	fc 01       	movw	r30, r24
 b32:	e6 5e       	subi	r30, 0xE6	; 230
 b34:	ff 4f       	sbci	r31, 0xFF	; 255
 b36:	09 94       	ijmp
	{
		case RESET:
		{
			currentCommand.status = MIDI_COMM_UNDEFINED;
 b38:	e8 e3       	ldi	r30, 0x38	; 56
 b3a:	f1 e0       	ldi	r31, 0x01	; 1
 b3c:	10 82       	st	Z, r1
			currentCommand.data1 = 0;
 b3e:	12 82       	std	Z+2, r1	; 0x02
			currentCommand.data2 = 0;
 b40:	13 82       	std	Z+3, r1	; 0x03
			currentStatusType = MIDI_TYPE_UNDEFINED;
 b42:	10 92 3c 01 	sts	0x013C, r1	; 0x80013c <currentStatusType>
			isSecondDataWord = false;
 b46:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <isSecondDataWord>
			state = WAIT_WORD;
 b4a:	81 e0       	ldi	r24, 0x01	; 1
 b4c:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
			break;
 b50:	08 95       	ret
		}
		
		case WAIT_WORD:
		{
			if(UART_RxBufferNotEmpty())
 b52:	fd d7       	rcall	.+4090   	; 0x1b4e <UART_RxBufferNotEmpty>
 b54:	88 23       	and	r24, r24
 b56:	09 f4       	brne	.+2      	; 0xb5a <MIDI_ParserTask+0x3a>
 b58:	83 c0       	rjmp	.+262    	; 0xc60 <MIDI_ParserTask+0x140>
			{
				recievedWord = UART_PopWord();
 b5a:	02 d6       	rcall	.+3076   	; 0x1760 <UART_PopWord>
 b5c:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <recievedWord>
				if(MIDI_IsSysRealTime(recievedWord))
 b60:	04 d8       	rcall	.-4088   	; 0xfffffb6a <__eeprom_end+0xff7efb6a>
 b62:	88 23       	and	r24, r24
 b64:	21 f0       	breq	.+8      	; 0xb6e <MIDI_ParserTask+0x4e>
				{ 
					handleRealTimeStatus((MIDI_Status_t)recievedWord);
 b66:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <recievedWord>
 b6a:	44 d8       	rcall	.-3960   	; 0xfffffbf4 <__eeprom_end+0xff7efbf4>
					return;
 b6c:	08 95       	ret
				}
				
				if(MIDI_IsStatusWord(recievedWord))
 b6e:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <recievedWord>
 b72:	1d d8       	rcall	.-4038   	; 0xfffffbae <__eeprom_end+0xff7efbae>
 b74:	88 23       	and	r24, r24
 b76:	21 f0       	breq	.+8      	; 0xb80 <MIDI_ParserTask+0x60>
				{					
					state = DISPATCH_STATUS;
 b78:	82 e0       	ldi	r24, 0x02	; 2
 b7a:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
 b7e:	20 c0       	rjmp	.+64     	; 0xbc0 <MIDI_ParserTask+0xa0>
				}
				else
				{
					switch(currentStatusType)
 b80:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <currentStatusType>
 b84:	82 30       	cpi	r24, 0x02	; 2
 b86:	49 f0       	breq	.+18     	; 0xb9a <MIDI_ParserTask+0x7a>
 b88:	18 f4       	brcc	.+6      	; 0xb90 <MIDI_ParserTask+0x70>
 b8a:	81 30       	cpi	r24, 0x01	; 1
 b8c:	51 f0       	breq	.+20     	; 0xba2 <MIDI_ParserTask+0x82>
 b8e:	15 c0       	rjmp	.+42     	; 0xbba <MIDI_ParserTask+0x9a>
 b90:	84 30       	cpi	r24, 0x04	; 4
 b92:	59 f0       	breq	.+22     	; 0xbaa <MIDI_ParserTask+0x8a>
 b94:	85 30       	cpi	r24, 0x05	; 5
 b96:	69 f0       	breq	.+26     	; 0xbb2 <MIDI_ParserTask+0x92>
 b98:	10 c0       	rjmp	.+32     	; 0xbba <MIDI_ParserTask+0x9a>
					{
						case MIDI_TYPE_TWO_BYTE: state = REC_TWO_BYTE; break;
 b9a:	84 e0       	ldi	r24, 0x04	; 4
 b9c:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
 ba0:	0f c0       	rjmp	.+30     	; 0xbc0 <MIDI_ParserTask+0xa0>
						case MIDI_TYPE_ONE_BYTE: state = REC_ONE_BYTE; break;
 ba2:	83 e0       	ldi	r24, 0x03	; 3
 ba4:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
 ba8:	0b c0       	rjmp	.+22     	; 0xbc0 <MIDI_ParserTask+0xa0>
						case MIDI_TYPE_START_SYS_EX: state = REC_SYS_EX; break;
 baa:	85 e0       	ldi	r24, 0x05	; 5
 bac:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
 bb0:	07 c0       	rjmp	.+14     	; 0xbc0 <MIDI_ParserTask+0xa0>
						case MIDI_TYPE_STOP_SYS_EX: state = HADLE_SYS_EX; break;
 bb2:	86 e0       	ldi	r24, 0x06	; 6
 bb4:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
 bb8:	03 c0       	rjmp	.+6      	; 0xbc0 <MIDI_ParserTask+0xa0>
						default: state = WAIT_WORD;
 bba:	81 e0       	ldi	r24, 0x01	; 1
 bbc:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
					}
				}
				
				if(retranslate)
 bc0:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <retranslate>
 bc4:	88 23       	and	r24, r24
 bc6:	09 f4       	brne	.+2      	; 0xbca <MIDI_ParserTask+0xaa>
 bc8:	4b c0       	rjmp	.+150    	; 0xc60 <MIDI_ParserTask+0x140>
				{
					UART_PushWord(recievedWord);
 bca:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <recievedWord>
 bce:	ad d4       	rcall	.+2394   	; 0x152a <UART_PushWord>
 bd0:	08 95       	ret
			break;
		}
		
		case DISPATCH_STATUS:
		{
			currentCommand.status = (MIDI_Status_t)((recievedWord & 0xF0) >> 4);
 bd2:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <recievedWord>
 bd6:	89 2f       	mov	r24, r25
 bd8:	82 95       	swap	r24
 bda:	8f 70       	andi	r24, 0x0F	; 15
 bdc:	e8 e3       	ldi	r30, 0x38	; 56
 bde:	f1 e0       	ldi	r31, 0x01	; 1
 be0:	80 83       	st	Z, r24
			currentCommand.channel_type = recievedWord & 0x0F;
 be2:	9f 70       	andi	r25, 0x0F	; 15
 be4:	91 83       	std	Z+1, r25	; 0x01
			currentCommand.data1 = 0;
 be6:	12 82       	std	Z+2, r1	; 0x02
			currentCommand.data2 = 0;
 be8:	13 82       	std	Z+3, r1	; 0x03
			currentStatusType = MIDI_GetStatusType(currentCommand.status);
 bea:	8f d2       	rcall	.+1310   	; 0x110a <MIDI_GetStatusType>
 bec:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <currentStatusType>
			isSecondDataWord = false;
 bf0:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <isSecondDataWord>
			state = WAIT_WORD;
 bf4:	81 e0       	ldi	r24, 0x01	; 1
 bf6:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
			break;
 bfa:	08 95       	ret
		}				
		
		case REC_TWO_BYTE:
		{
			if(isSecondDataWord)
 bfc:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <isSecondDataWord>
 c00:	88 23       	and	r24, r24
 c02:	59 f0       	breq	.+22     	; 0xc1a <MIDI_ParserTask+0xfa>
			{
				currentCommand.data2 = recievedWord;
 c04:	e8 e3       	ldi	r30, 0x38	; 56
 c06:	f1 e0       	ldi	r31, 0x01	; 1
 c08:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <recievedWord>
 c0c:	83 83       	std	Z+3, r24	; 0x03
				isSecondDataWord = false;			
 c0e:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <isSecondDataWord>
				MIDICTRL_HandleCommand(&currentCommand);
 c12:	bf 01       	movw	r22, r30
 c14:	80 e8       	ldi	r24, 0x80	; 128
 c16:	ab dd       	rcall	.-1194   	; 0x76e <MIDICTRL_HandleCommand>
 c18:	07 c0       	rjmp	.+14     	; 0xc28 <MIDI_ParserTask+0x108>
			}
			else
			{
				currentCommand.data1 = recievedWord;
 c1a:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <recievedWord>
 c1e:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <currentCommand+0x2>
				isSecondDataWord = true;
 c22:	81 e0       	ldi	r24, 0x01	; 1
 c24:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <isSecondDataWord>
			}
			state = WAIT_WORD;
 c28:	81 e0       	ldi	r24, 0x01	; 1
 c2a:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
			break;
 c2e:	08 95       	ret
		}
		
		case REC_ONE_BYTE:
		{
			currentCommand.data1 = recievedWord;
 c30:	e8 e3       	ldi	r30, 0x38	; 56
 c32:	f1 e0       	ldi	r31, 0x01	; 1
 c34:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <recievedWord>
 c38:	82 83       	std	Z+2, r24	; 0x02
			MIDICTRL_HandleCommand(&currentCommand);
 c3a:	bf 01       	movw	r22, r30
 c3c:	80 e8       	ldi	r24, 0x80	; 128
 c3e:	97 dd       	rcall	.-1234   	; 0x76e <MIDICTRL_HandleCommand>
			state = WAIT_WORD;
 c40:	81 e0       	ldi	r24, 0x01	; 1
 c42:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
			break;
 c46:	08 95       	ret
		}
		
		case REC_SYS_EX:
		{
			state = WAIT_WORD;
 c48:	81 e0       	ldi	r24, 0x01	; 1
 c4a:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
			break;
 c4e:	08 95       	ret
		}
		
		case HADLE_SYS_EX:
		{
			currentCommand.status = MIDI_COMM_UNDEFINED;
 c50:	e8 e3       	ldi	r30, 0x38	; 56
 c52:	f1 e0       	ldi	r31, 0x01	; 1
 c54:	10 82       	st	Z, r1
			currentCommand.data1 = 0;
 c56:	12 82       	std	Z+2, r1	; 0x02
			currentCommand.data2 = 0;
 c58:	13 82       	std	Z+3, r1	; 0x03
			state = WAIT_WORD;
 c5a:	81 e0       	ldi	r24, 0x01	; 1
 c5c:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
 c60:	08 95       	ret

Disassembly of section .text.MIDI_SetRetranslateState:

00001bd6 <MIDI_SetRetranslateState>:
	}
}

void MIDI_SetRetranslateState(bool enabled)
{
	retranslate = enabled;
    1bd6:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <retranslate>
    1bda:	08 95       	ret

Disassembly of section .text.MIDI_SendCommand:

00000fa2 <MIDI_SendCommand>:
}

void MIDI_SendCommand(MIDI_Command_t command, uint8_t channel)
{
     fa2:	0f 93       	push	r16
     fa4:	1f 93       	push	r17
     fa6:	cf 93       	push	r28
     fa8:	df 93       	push	r29
     faa:	c6 2f       	mov	r28, r22
     fac:	18 2f       	mov	r17, r24
     fae:	09 2f       	mov	r16, r25
     fb0:	d4 2f       	mov	r29, r20
	switch(MIDI_GetStatusType(command.status))
     fb2:	86 2f       	mov	r24, r22
     fb4:	aa d0       	rcall	.+340    	; 0x110a <MIDI_GetStatusType>
     fb6:	83 30       	cpi	r24, 0x03	; 3
     fb8:	59 f0       	breq	.+22     	; 0xfd0 <MIDI_SendCommand+0x2e>
     fba:	28 f4       	brcc	.+10     	; 0xfc6 <MIDI_SendCommand+0x24>
     fbc:	81 30       	cpi	r24, 0x01	; 1
     fbe:	59 f0       	breq	.+22     	; 0xfd6 <MIDI_SendCommand+0x34>
     fc0:	82 30       	cpi	r24, 0x02	; 2
     fc2:	a1 f0       	breq	.+40     	; 0xfec <MIDI_SendCommand+0x4a>
     fc4:	25 c0       	rjmp	.+74     	; 0x1010 <MIDI_SendCommand+0x6e>
     fc6:	84 30       	cpi	r24, 0x04	; 4
     fc8:	f1 f0       	breq	.+60     	; 0x1006 <MIDI_SendCommand+0x64>
     fca:	85 30       	cpi	r24, 0x05	; 5
     fcc:	f9 f0       	breq	.+62     	; 0x100c <MIDI_SendCommand+0x6a>
     fce:	20 c0       	rjmp	.+64     	; 0x1010 <MIDI_SendCommand+0x6e>
	{
		case MIDI_TYPE_REAL_TIME:
		{
			// second nymble!
			UART_PushWord(command.status);
     fd0:	8c 2f       	mov	r24, r28
     fd2:	ab d2       	rcall	.+1366   	; 0x152a <UART_PushWord>
			break;
     fd4:	1d c0       	rjmp	.+58     	; 0x1010 <MIDI_SendCommand+0x6e>
		}
		case MIDI_TYPE_ONE_BYTE:
		{
			UART_PushWord((command.status << 4) | (channel & 0xF));
     fd6:	80 e1       	ldi	r24, 0x10	; 16
     fd8:	c8 9f       	mul	r28, r24
     fda:	b0 01       	movw	r22, r0
     fdc:	11 24       	eor	r1, r1
     fde:	8d 2f       	mov	r24, r29
     fe0:	8f 70       	andi	r24, 0x0F	; 15
     fe2:	86 2b       	or	r24, r22
     fe4:	a2 d2       	rcall	.+1348   	; 0x152a <UART_PushWord>
			UART_PushWord(command.data1);
     fe6:	81 2f       	mov	r24, r17
     fe8:	a0 d2       	rcall	.+1344   	; 0x152a <UART_PushWord>
			break;
     fea:	12 c0       	rjmp	.+36     	; 0x1010 <MIDI_SendCommand+0x6e>
		}
		case MIDI_TYPE_TWO_BYTE:
		{
			UART_PushWord((command.status << 4) | (channel & 0xF));
     fec:	80 e1       	ldi	r24, 0x10	; 16
     fee:	c8 9f       	mul	r28, r24
     ff0:	b0 01       	movw	r22, r0
     ff2:	11 24       	eor	r1, r1
     ff4:	8d 2f       	mov	r24, r29
     ff6:	8f 70       	andi	r24, 0x0F	; 15
     ff8:	86 2b       	or	r24, r22
     ffa:	97 d2       	rcall	.+1326   	; 0x152a <UART_PushWord>
			UART_PushWord(command.data1);
     ffc:	81 2f       	mov	r24, r17
     ffe:	95 d2       	rcall	.+1322   	; 0x152a <UART_PushWord>
			UART_PushWord(command.data2);
    1000:	80 2f       	mov	r24, r16
    1002:	93 d2       	rcall	.+1318   	; 0x152a <UART_PushWord>
			break;
    1004:	05 c0       	rjmp	.+10     	; 0x1010 <MIDI_SendCommand+0x6e>
		}
		case MIDI_TYPE_START_SYS_EX:
		{
			// second nymble!
			UART_PushWord(command.status);
    1006:	8c 2f       	mov	r24, r28
    1008:	90 d2       	rcall	.+1312   	; 0x152a <UART_PushWord>
			break;
    100a:	02 c0       	rjmp	.+4      	; 0x1010 <MIDI_SendCommand+0x6e>
		}
		case MIDI_TYPE_STOP_SYS_EX:
		{
			// second nymble!!!
			UART_PushWord(command.status);
    100c:	8c 2f       	mov	r24, r28
    100e:	8d d2       	rcall	.+1306   	; 0x152a <UART_PushWord>
			break;
		}
		case MIDI_TYPE_UNDEFINED: break;
	}
    1010:	df 91       	pop	r29
    1012:	cf 91       	pop	r28
    1014:	1f 91       	pop	r17
    1016:	0f 91       	pop	r16
    1018:	08 95       	ret

Disassembly of section .text.SH100CTRL_GetAmpState:

000015b2 <SH100CTRL_GetAmpState>:
	SH100CTRL_SetLoop(ampState.loopOn[ampState.channelNum]);
	SH100CTRL_SetAB(ampState.swAB);
}

SH100_State_t SH100CTRL_GetAmpState()
{
    15b2:	cf 93       	push	r28
    15b4:	df 93       	push	r29
    15b6:	00 d0       	rcall	.+0      	; 0x15b8 <SH100CTRL_GetAmpState+0x6>
    15b8:	00 d0       	rcall	.+0      	; 0x15ba <SH100CTRL_GetAmpState+0x8>
    15ba:	00 d0       	rcall	.+0      	; 0x15bc <SH100CTRL_GetAmpState+0xa>
    15bc:	cd b7       	in	r28, 0x3d	; 61
    15be:	de b7       	in	r29, 0x3e	; 62
	return ampState;
    15c0:	86 e0       	ldi	r24, 0x06	; 6
    15c2:	ed e3       	ldi	r30, 0x3D	; 61
    15c4:	f1 e0       	ldi	r31, 0x01	; 1
    15c6:	de 01       	movw	r26, r28
    15c8:	11 96       	adiw	r26, 0x01	; 1
    15ca:	01 90       	ld	r0, Z+
    15cc:	0d 92       	st	X+, r0
    15ce:	8a 95       	dec	r24
    15d0:	e1 f7       	brne	.-8      	; 0x15ca <SH100CTRL_GetAmpState+0x18>
    15d2:	29 81       	ldd	r18, Y+1	; 0x01
    15d4:	3a 81       	ldd	r19, Y+2	; 0x02
    15d6:	4b 81       	ldd	r20, Y+3	; 0x03
    15d8:	5c 81       	ldd	r21, Y+4	; 0x04
    15da:	6d 81       	ldd	r22, Y+5	; 0x05
    15dc:	7e 81       	ldd	r23, Y+6	; 0x06
}
    15de:	80 e0       	ldi	r24, 0x00	; 0
    15e0:	90 e0       	ldi	r25, 0x00	; 0
    15e2:	26 96       	adiw	r28, 0x06	; 6
    15e4:	0f b6       	in	r0, 0x3f	; 63
    15e6:	f8 94       	cli
    15e8:	de bf       	out	0x3e, r29	; 62
    15ea:	0f be       	out	0x3f, r0	; 63
    15ec:	cd bf       	out	0x3d, r28	; 61
    15ee:	df 91       	pop	r29
    15f0:	cf 91       	pop	r28
    15f2:	08 95       	ret

Disassembly of section .text.setChannelLeds:

000019c0 <setChannelLeds>:

void setChannelLeds()
{
	SH100HW_SetNewLedState(LED_CH1, LED_OFF);
    19c0:	60 e0       	ldi	r22, 0x00	; 0
    19c2:	80 e0       	ldi	r24, 0x00	; 0
    19c4:	5e df       	rcall	.-324    	; 0x1882 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_CH2, LED_OFF);
    19c6:	60 e0       	ldi	r22, 0x00	; 0
    19c8:	81 e0       	ldi	r24, 0x01	; 1
    19ca:	5b df       	rcall	.-330    	; 0x1882 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_CH3, LED_OFF);
    19cc:	60 e0       	ldi	r22, 0x00	; 0
    19ce:	82 e0       	ldi	r24, 0x02	; 2
    19d0:	58 df       	rcall	.-336    	; 0x1882 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_CH4, LED_OFF);
    19d2:	60 e0       	ldi	r22, 0x00	; 0
    19d4:	83 e0       	ldi	r24, 0x03	; 3
    19d6:	55 df       	rcall	.-342    	; 0x1882 <SH100HW_SetNewLedState>
	
	SH100HW_SetNewLedState(ampState.channelNum, LED_ON);
    19d8:	61 e0       	ldi	r22, 0x01	; 1
    19da:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <ampState>
    19de:	51 df       	rcall	.-350    	; 0x1882 <SH100HW_SetNewLedState>
    19e0:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetAmpLeds:

00001826 <SH100CTRL_SetAmpLeds>:
}

void SH100CTRL_SetAmpLeds()
{
    1826:	cf 93       	push	r28
    1828:	df 93       	push	r29
	setChannelLeds();
    182a:	ca d0       	rcall	.+404    	; 0x19c0 <setChannelLeds>
	SH100HW_SetNewLedState(LED_LOOP, ampState.loopOn[ampState.channelNum]);
    182c:	cd e3       	ldi	r28, 0x3D	; 61
    182e:	d1 e0       	ldi	r29, 0x01	; 1
    1830:	e8 81       	ld	r30, Y
    1832:	f0 e0       	ldi	r31, 0x00	; 0
    1834:	e3 5c       	subi	r30, 0xC3	; 195
    1836:	fe 4f       	sbci	r31, 0xFE	; 254
    1838:	61 81       	ldd	r22, Z+1	; 0x01
    183a:	84 e0       	ldi	r24, 0x04	; 4
    183c:	22 d0       	rcall	.+68     	; 0x1882 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_A, !ampState.swAB);
    183e:	6d 81       	ldd	r22, Y+5	; 0x05
    1840:	81 e0       	ldi	r24, 0x01	; 1
    1842:	68 27       	eor	r22, r24
    1844:	85 e0       	ldi	r24, 0x05	; 5
    1846:	1d d0       	rcall	.+58     	; 0x1882 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_B, ampState.swAB);
    1848:	6d 81       	ldd	r22, Y+5	; 0x05
    184a:	86 e0       	ldi	r24, 0x06	; 6
    184c:	1a d0       	rcall	.+52     	; 0x1882 <SH100HW_SetNewLedState>
}
    184e:	df 91       	pop	r29
    1850:	cf 91       	pop	r28
    1852:	08 95       	ret

Disassembly of section .text.SH100CTRL_StoreAmpState:

000019fe <SH100CTRL_StoreAmpState>:

void SH100CTRL_StoreAmpState()
{
	eeprom_write_word(0x00, MEMORY_MAGIC_WORD);
    19fe:	6b ea       	ldi	r22, 0xAB	; 171
    1a00:	7c ea       	ldi	r23, 0xAC	; 172
    1a02:	80 e0       	ldi	r24, 0x00	; 0
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	f3 d0       	rcall	.+486    	; 0x1bee <eeprom_write_word>
	eeprom_write_block(&ampState, (void*)MEMORY_AMP_STATE_OFFSET, sizeof(SH100_State_t));
    1a08:	6d e3       	ldi	r22, 0x3D	; 61
    1a0a:	71 e0       	ldi	r23, 0x01	; 1
    1a0c:	80 e8       	ldi	r24, 0x80	; 128
    1a0e:	26 e0       	ldi	r18, 0x06	; 6
    1a10:	30 e0       	ldi	r19, 0x00	; 0
    1a12:	48 e0       	ldi	r20, 0x08	; 8
    1a14:	50 e0       	ldi	r21, 0x00	; 0
    1a16:	d7 de       	rcall	.-594    	; 0x17c6 <eeprom_write_block>
    1a18:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetLoop:

0000192c <SH100CTRL_SetLoop>:
{
	SH100CTRL_SetLoop(!ampState.loopOn[ampState.channelNum]);
}

void SH100CTRL_SetLoop(bool en)
{
    192c:	cf 93       	push	r28
    192e:	df 93       	push	r29
	ampState.loopOn[ampState.channelNum] = en;
    1930:	cd e3       	ldi	r28, 0x3D	; 61
    1932:	d1 e0       	ldi	r29, 0x01	; 1
    1934:	e8 81       	ld	r30, Y
    1936:	f0 e0       	ldi	r31, 0x00	; 0
    1938:	e3 5c       	subi	r30, 0xC3	; 195
    193a:	fe 4f       	sbci	r31, 0xFE	; 254
    193c:	81 83       	std	Z+1, r24	; 0x01
	SH100HW_LoopEn(ampState.loopOn[ampState.channelNum]);
    193e:	88 d0       	rcall	.+272    	; 0x1a50 <SH100HW_LoopEn>
	SH100HW_SetNewLedState(LED_LOOP, ampState.loopOn[ampState.channelNum]);
    1940:	e8 81       	ld	r30, Y
    1942:	f0 e0       	ldi	r31, 0x00	; 0
    1944:	e3 5c       	subi	r30, 0xC3	; 195
    1946:	fe 4f       	sbci	r31, 0xFE	; 254
    1948:	61 81       	ldd	r22, Z+1	; 0x01
    194a:	84 e0       	ldi	r24, 0x04	; 4
    194c:	9a df       	rcall	.-204    	; 0x1882 <SH100HW_SetNewLedState>
	
	MIDICTRL_SendLoopEnComm();
    194e:	c4 df       	rcall	.-120    	; 0x18d8 <MIDICTRL_SendLoopEnComm>
}
    1950:	df 91       	pop	r29
    1952:	cf 91       	pop	r28
    1954:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetChannel:

00001854 <SH100CTRL_SetChannel>:
		SH100CTRL_SwLoop();
	}
}

void SH100CTRL_SetChannel(uint8_t chNum)
{
    1854:	0f 93       	push	r16
    1856:	1f 93       	push	r17
    1858:	cf 93       	push	r28
    185a:	c8 2f       	mov	r28, r24
	ampState.channelNum = chNum;
    185c:	0d e3       	ldi	r16, 0x3D	; 61
    185e:	11 e0       	ldi	r17, 0x01	; 1
    1860:	d8 01       	movw	r26, r16
    1862:	8c 93       	st	X, r24
	
	SH100HW_SetCh(chNum);
    1864:	a6 dd       	rcall	.-1204   	; 0x13b2 <SH100HW_SetCh>
	SH100CTRL_SetLoop(ampState.loopOn[ampState.channelNum]);
    1866:	d8 01       	movw	r26, r16
    1868:	ec 91       	ld	r30, X
    186a:	f0 e0       	ldi	r31, 0x00	; 0
    186c:	e3 5c       	subi	r30, 0xC3	; 195
    186e:	fe 4f       	sbci	r31, 0xFE	; 254
    1870:	81 81       	ldd	r24, Z+1	; 0x01
    1872:	5c d0       	rcall	.+184    	; 0x192c <SH100CTRL_SetLoop>
	setChannelLeds();
    1874:	a5 d0       	rcall	.+330    	; 0x19c0 <setChannelLeds>
	
	MIDICTRL_SendSwChComm(chNum);
    1876:	8c 2f       	mov	r24, r28
    1878:	80 dc       	rcall	.-1792   	; 0x117a <MIDICTRL_SendSwChComm>
}
    187a:	cf 91       	pop	r28
    187c:	1f 91       	pop	r17
    187e:	0f 91       	pop	r16
    1880:	08 95       	ret

Disassembly of section .text.SH100CTRL_SwLoop:

00001ada <SH100CTRL_SwLoop>:

void SH100CTRL_SwLoop()
{
	SH100CTRL_SetLoop(!ampState.loopOn[ampState.channelNum]);
    1ada:	e0 91 3d 01 	lds	r30, 0x013D	; 0x80013d <ampState>
    1ade:	f0 e0       	ldi	r31, 0x00	; 0
    1ae0:	e3 5c       	subi	r30, 0xC3	; 195
    1ae2:	fe 4f       	sbci	r31, 0xFE	; 254
    1ae4:	91 81       	ldd	r25, Z+1	; 0x01
    1ae6:	81 e0       	ldi	r24, 0x01	; 1
    1ae8:	89 27       	eor	r24, r25
    1aea:	20 df       	rcall	.-448    	; 0x192c <SH100CTRL_SetLoop>
    1aec:	08 95       	ret

Disassembly of section .text.SH100CTRL_BtnSwChannel:

00001b14 <SH100CTRL_BtnSwChannel>:
	eeprom_write_block(&ampState, (void*)MEMORY_AMP_STATE_OFFSET, sizeof(SH100_State_t));
}

void SH100CTRL_BtnSwChannel(uint8_t chNum)
{
	if(ampState.channelNum != chNum)
    1b14:	90 91 3d 01 	lds	r25, 0x013D	; 0x80013d <ampState>
    1b18:	98 17       	cp	r25, r24
    1b1a:	11 f0       	breq	.+4      	; 0x1b20 <SH100CTRL_BtnSwChannel+0xc>
	{
		SH100CTRL_SetChannel(chNum);
    1b1c:	9b de       	rcall	.-714    	; 0x1854 <SH100CTRL_SetChannel>
    1b1e:	08 95       	ret
	}
	else
	{
		SH100CTRL_SwLoop();
    1b20:	dc df       	rcall	.-72     	; 0x1ada <SH100CTRL_SwLoop>
    1b22:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetAB:

00001956 <SH100CTRL_SetAB>:
{
	SH100CTRL_SetAB(!ampState.swAB);
}

void SH100CTRL_SetAB(bool isB)
{
    1956:	cf 93       	push	r28
    1958:	df 93       	push	r29
	ampState.swAB = isB;
    195a:	cd e3       	ldi	r28, 0x3D	; 61
    195c:	d1 e0       	ldi	r29, 0x01	; 1
    195e:	8d 83       	std	Y+5, r24	; 0x05
	SH100HW_SetAB(ampState.swAB);
    1960:	40 d1       	rcall	.+640    	; 0x1be2 <SH100HW_SetAB>
	SH100HW_SetNewLedState(LED_A, !ampState.swAB);
    1962:	6d 81       	ldd	r22, Y+5	; 0x05
    1964:	81 e0       	ldi	r24, 0x01	; 1
    1966:	68 27       	eor	r22, r24
    1968:	85 e0       	ldi	r24, 0x05	; 5
    196a:	8b df       	rcall	.-234    	; 0x1882 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_B, ampState.swAB);
    196c:	6d 81       	ldd	r22, Y+5	; 0x05
    196e:	86 e0       	ldi	r24, 0x06	; 6
    1970:	88 df       	rcall	.-240    	; 0x1882 <SH100HW_SetNewLedState>
	
	MIDICTRL_SendSwABComm();
    1972:	c7 df       	rcall	.-114    	; 0x1902 <MIDICTRL_SendSwABComm>
}
    1974:	df 91       	pop	r29
    1976:	cf 91       	pop	r28
    1978:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetAmpState:

00001794 <SH100CTRL_SetAmpState>:
	
	SH100CTRL_SetAmpState(&ampState);
}

void SH100CTRL_SetAmpState(const SH100_State_t* state)
{
    1794:	cf 93       	push	r28
    1796:	df 93       	push	r29
    1798:	98 2f       	mov	r25, r24
	ampState = *state;
    179a:	86 e0       	ldi	r24, 0x06	; 6
    179c:	e6 2f       	mov	r30, r22
    179e:	f7 2f       	mov	r31, r23
    17a0:	ad e3       	ldi	r26, 0x3D	; 61
    17a2:	b1 e0       	ldi	r27, 0x01	; 1
    17a4:	79 2f       	mov	r23, r25
    17a6:	47 d1       	rcall	.+654    	; 0x1a36 <__movmemx_qi>
	
	SH100CTRL_SetChannel(ampState.channelNum);
    17a8:	cd e3       	ldi	r28, 0x3D	; 61
    17aa:	d1 e0       	ldi	r29, 0x01	; 1
    17ac:	88 81       	ld	r24, Y
    17ae:	52 d0       	rcall	.+164    	; 0x1854 <SH100CTRL_SetChannel>
	SH100CTRL_SetLoop(ampState.loopOn[ampState.channelNum]);
    17b0:	e8 81       	ld	r30, Y
    17b2:	f0 e0       	ldi	r31, 0x00	; 0
    17b4:	e3 5c       	subi	r30, 0xC3	; 195
    17b6:	fe 4f       	sbci	r31, 0xFE	; 254
    17b8:	81 81       	ldd	r24, Z+1	; 0x01
    17ba:	b8 d0       	rcall	.+368    	; 0x192c <SH100CTRL_SetLoop>
	SH100CTRL_SetAB(ampState.swAB);
    17bc:	8d 81       	ldd	r24, Y+5	; 0x05
    17be:	cb d0       	rcall	.+406    	; 0x1956 <SH100CTRL_SetAB>
}
    17c0:	df 91       	pop	r29
    17c2:	cf 91       	pop	r28
    17c4:	08 95       	ret

Disassembly of section .text.SH100CTRL_Init:

0000101a <SH100CTRL_Init>:
SH100_State_t ampState;

void setChannelLeds();

void SH100CTRL_Init()
{
    101a:	cf 93       	push	r28
    101c:	df 93       	push	r29
    101e:	00 d0       	rcall	.+0      	; 0x1020 <SH100CTRL_Init+0x6>
    1020:	00 d0       	rcall	.+0      	; 0x1022 <SH100CTRL_Init+0x8>
    1022:	00 d0       	rcall	.+0      	; 0x1024 <SH100CTRL_Init+0xa>
    1024:	cd b7       	in	r28, 0x3d	; 61
    1026:	de b7       	in	r29, 0x3e	; 62
	uint16_t readedMagicWord = eeprom_read_word(0x00);
    1028:	60 e0       	ldi	r22, 0x00	; 0
    102a:	70 e0       	ldi	r23, 0x00	; 0
    102c:	80 e0       	ldi	r24, 0x00	; 0
    102e:	af d5       	rcall	.+2910   	; 0x1b8e <eeprom_read_word>
	
	if(readedMagicWord == MEMORY_MAGIC_WORD)
    1030:	8b 3a       	cpi	r24, 0xAB	; 171
    1032:	9c 4a       	sbci	r25, 0xAC	; 172
    1034:	91 f4       	brne	.+36     	; 0x105a <SH100CTRL_Init+0x40>
	{
		uint8_t readedData[sizeof(SH100_State_t)];
		eeprom_read_block(&readedData, (uint16_t*)MEMORY_AMP_STATE_OFFSET, sizeof(SH100_State_t));
    1036:	48 e0       	ldi	r20, 0x08	; 8
    1038:	50 e0       	ldi	r21, 0x00	; 0
    103a:	60 e8       	ldi	r22, 0x80	; 128
    103c:	26 e0       	ldi	r18, 0x06	; 6
    103e:	30 e0       	ldi	r19, 0x00	; 0
    1040:	ce 01       	movw	r24, r28
    1042:	01 96       	adiw	r24, 0x01	; 1
    1044:	9a d4       	rcall	.+2356   	; 0x197a <eeprom_read_block>
		SH100_State_t* ampState_ptr = (SH100_State_t*)readedData;
		ampState = *ampState_ptr;
    1046:	86 e0       	ldi	r24, 0x06	; 6
    1048:	fe 01       	movw	r30, r28
    104a:	31 96       	adiw	r30, 0x01	; 1
    104c:	ad e3       	ldi	r26, 0x3D	; 61
    104e:	b1 e0       	ldi	r27, 0x01	; 1
    1050:	01 90       	ld	r0, Z+
    1052:	0d 92       	st	X+, r0
    1054:	8a 95       	dec	r24
    1056:	e1 f7       	brne	.-8      	; 0x1050 <SH100CTRL_Init+0x36>
    1058:	0f c0       	rjmp	.+30     	; 0x1078 <SH100CTRL_Init+0x5e>
	}
	else
	{
		ampState.channelNum = 0;
    105a:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <ampState>
		for(int i=0; i<4; i++)
    105e:	80 e0       	ldi	r24, 0x00	; 0
    1060:	90 e0       	ldi	r25, 0x00	; 0
    1062:	05 c0       	rjmp	.+10     	; 0x106e <SH100CTRL_Init+0x54>
		{
			ampState.loopOn[i] = false;
    1064:	fc 01       	movw	r30, r24
    1066:	e3 5c       	subi	r30, 0xC3	; 195
    1068:	fe 4f       	sbci	r31, 0xFE	; 254
    106a:	11 82       	std	Z+1, r1	; 0x01
		ampState = *ampState_ptr;
	}
	else
	{
		ampState.channelNum = 0;
		for(int i=0; i<4; i++)
    106c:	01 96       	adiw	r24, 0x01	; 1
    106e:	84 30       	cpi	r24, 0x04	; 4
    1070:	91 05       	cpc	r25, r1
    1072:	c4 f3       	brlt	.-16     	; 0x1064 <SH100CTRL_Init+0x4a>
		{
			ampState.loopOn[i] = false;
		}		
		ampState.swAB = false;		
    1074:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <ampState+0x5>
	}
	
	SH100CTRL_SetAmpState(&ampState);
    1078:	6d e3       	ldi	r22, 0x3D	; 61
    107a:	71 e0       	ldi	r23, 0x01	; 1
    107c:	80 e8       	ldi	r24, 0x80	; 128
    107e:	8a d3       	rcall	.+1812   	; 0x1794 <SH100CTRL_SetAmpState>
}
    1080:	26 96       	adiw	r28, 0x06	; 6
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	cd bf       	out	0x3d, r28	; 61
    108c:	df 91       	pop	r29
    108e:	cf 91       	pop	r28
    1090:	08 95       	ret

Disassembly of section .text.SH100CTRL_SwAB:

00001b76 <SH100CTRL_SwAB>:
	MIDICTRL_SendLoopEnComm();
}

void SH100CTRL_SwAB()
{
	SH100CTRL_SetAB(!ampState.swAB);
    1b76:	90 91 42 01 	lds	r25, 0x0142	; 0x800142 <ampState+0x5>
    1b7a:	81 e0       	ldi	r24, 0x01	; 1
    1b7c:	89 27       	eor	r24, r25
    1b7e:	eb de       	rcall	.-554    	; 0x1956 <SH100CTRL_SetAB>
    1b80:	08 95       	ret

Disassembly of section .text.SH100CTRL_MuteAmp:

00001bdc <SH100CTRL_MuteAmp>:
	MIDICTRL_SendSwABComm();
}

void SH100CTRL_MuteAmp()
{
	SH100HW_SetPAState(OUTPUT_MUTE);
    1bdc:	80 e0       	ldi	r24, 0x00	; 0
    1bde:	6a dd       	rcall	.-1324   	; 0x16b4 <SH100HW_SetPAState>
    1be0:	08 95       	ret

Disassembly of section .text.SH100CTRL_UnmuteAmp:

00001b82 <SH100CTRL_UnmuteAmp>:
}

void SH100CTRL_UnmuteAmp()
{
	if(SH100HW_GetOutputJacks() != OUT_NONE)
    1b82:	7e df       	rcall	.-260    	; 0x1a80 <SH100HW_GetOutputJacks>
    1b84:	88 23       	and	r24, r24
    1b86:	11 f0       	breq	.+4      	; 0x1b8c <SH100CTRL_UnmuteAmp+0xa>
	{
		SH100HW_SetPAState(OUTPUT_ENABLED);	
    1b88:	81 e0       	ldi	r24, 0x01	; 1
    1b8a:	94 dd       	rcall	.-1240   	; 0x16b4 <SH100HW_SetPAState>
    1b8c:	08 95       	ret

Disassembly of section .text.SH100CTRL_CheckOutputJacks:

00001092 <SH100CTRL_CheckOutputJacks>:
	}		
}

void SH100CTRL_CheckOutputJacks()
{
	if(SH100HW_GetPAFailure()) return;
    1092:	83 d5       	rcall	.+2822   	; 0x1b9a <SH100HW_GetPAFailure>
    1094:	81 11       	cpse	r24, r1
    1096:	38 c0       	rjmp	.+112    	; 0x1108 <SH100CTRL_CheckOutputJacks+0x76>
	
	SH100HW_OutputJacks_t outJacksState = SH100HW_GetOutputJacks();
    1098:	f3 d4       	rcall	.+2534   	; 0x1a80 <SH100HW_GetOutputJacks>
	
	switch(outJacksState)
    109a:	81 30       	cpi	r24, 0x01	; 1
    109c:	89 f0       	breq	.+34     	; 0x10c0 <SH100CTRL_CheckOutputJacks+0x2e>
    109e:	28 f0       	brcs	.+10     	; 0x10aa <SH100CTRL_CheckOutputJacks+0x18>
    10a0:	82 30       	cpi	r24, 0x02	; 2
    10a2:	d9 f0       	breq	.+54     	; 0x10da <SH100CTRL_CheckOutputJacks+0x48>
    10a4:	83 30       	cpi	r24, 0x03	; 3
    10a6:	31 f1       	breq	.+76     	; 0x10f4 <SH100CTRL_CheckOutputJacks+0x62>
    10a8:	08 95       	ret
	{
		case OUT_NONE:
		{
			if(MIDICTRL_MidiMode() == RUNNING)
    10aa:	89 d5       	rcall	.+2834   	; 0x1bbe <MIDICTRL_MidiMode>
    10ac:	81 11       	cpse	r24, r1
    10ae:	06 c0       	rjmp	.+12     	; 0x10bc <SH100CTRL_CheckOutputJacks+0x2a>
			{
				SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
    10b0:	60 e0       	ldi	r22, 0x00	; 0
    10b2:	87 e0       	ldi	r24, 0x07	; 7
    10b4:	e6 d3       	rcall	.+1996   	; 0x1882 <SH100HW_SetNewLedState>
				SH100HW_SetNewLedState(LED_PWR_RED, LED_ON);
    10b6:	61 e0       	ldi	r22, 0x01	; 1
    10b8:	88 e0       	ldi	r24, 0x08	; 8
    10ba:	e3 d3       	rcall	.+1990   	; 0x1882 <SH100HW_SetNewLedState>
			}
			SH100CTRL_MuteAmp();
    10bc:	8f d5       	rcall	.+2846   	; 0x1bdc <SH100CTRL_MuteAmp>
			break;
    10be:	08 95       	ret
		}
		case OUT_16OHM:
		{
			if(MIDICTRL_MidiMode() == RUNNING)
    10c0:	7e d5       	rcall	.+2812   	; 0x1bbe <MIDICTRL_MidiMode>
    10c2:	81 11       	cpse	r24, r1
    10c4:	21 c0       	rjmp	.+66     	; 0x1108 <SH100CTRL_CheckOutputJacks+0x76>
			{
				SH100CTRL_UnmuteAmp();
    10c6:	5d d5       	rcall	.+2746   	; 0x1b82 <SH100CTRL_UnmuteAmp>
				SH100HW_SetOutputMode(OUTPUT_16OHM);
    10c8:	81 e0       	ldi	r24, 0x01	; 1
    10ca:	8e d5       	rcall	.+2844   	; 0x1be8 <SH100HW_SetOutputMode>
				SH100HW_SetNewLedState(LED_PWR_GRN, LED_ON);
    10cc:	61 e0       	ldi	r22, 0x01	; 1
    10ce:	87 e0       	ldi	r24, 0x07	; 7
    10d0:	d8 d3       	rcall	.+1968   	; 0x1882 <SH100HW_SetNewLedState>
				SH100HW_SetNewLedState(LED_PWR_RED, LED_OFF);
    10d2:	60 e0       	ldi	r22, 0x00	; 0
    10d4:	88 e0       	ldi	r24, 0x08	; 8
    10d6:	d5 d3       	rcall	.+1962   	; 0x1882 <SH100HW_SetNewLedState>
    10d8:	08 95       	ret
			}			
			break;
		}
		case OUT_8OHM:
		{
			if(MIDICTRL_MidiMode() == RUNNING)
    10da:	71 d5       	rcall	.+2786   	; 0x1bbe <MIDICTRL_MidiMode>
    10dc:	81 11       	cpse	r24, r1
    10de:	14 c0       	rjmp	.+40     	; 0x1108 <SH100CTRL_CheckOutputJacks+0x76>
			{
				SH100CTRL_UnmuteAmp();
    10e0:	50 d5       	rcall	.+2720   	; 0x1b82 <SH100CTRL_UnmuteAmp>
				SH100HW_SetOutputMode(OUTPUT_8OHM);
    10e2:	80 e0       	ldi	r24, 0x00	; 0
    10e4:	81 d5       	rcall	.+2818   	; 0x1be8 <SH100HW_SetOutputMode>
				SH100HW_SetNewLedState(LED_PWR_GRN, LED_ON);
    10e6:	61 e0       	ldi	r22, 0x01	; 1
    10e8:	87 e0       	ldi	r24, 0x07	; 7
    10ea:	cb d3       	rcall	.+1942   	; 0x1882 <SH100HW_SetNewLedState>
				SH100HW_SetNewLedState(LED_PWR_RED, LED_OFF);
    10ec:	60 e0       	ldi	r22, 0x00	; 0
    10ee:	88 e0       	ldi	r24, 0x08	; 8
    10f0:	c8 d3       	rcall	.+1936   	; 0x1882 <SH100HW_SetNewLedState>
    10f2:	08 95       	ret

			break;
		}
		case OUT_BOTH:
		{
			if(MIDICTRL_MidiMode() == RUNNING)
    10f4:	64 d5       	rcall	.+2760   	; 0x1bbe <MIDICTRL_MidiMode>
    10f6:	81 11       	cpse	r24, r1
    10f8:	06 c0       	rjmp	.+12     	; 0x1106 <SH100CTRL_CheckOutputJacks+0x74>
			{
				SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
    10fa:	60 e0       	ldi	r22, 0x00	; 0
    10fc:	87 e0       	ldi	r24, 0x07	; 7
    10fe:	c1 d3       	rcall	.+1922   	; 0x1882 <SH100HW_SetNewLedState>
				SH100HW_SetNewLedState(LED_PWR_RED, LED_ON);
    1100:	61 e0       	ldi	r22, 0x01	; 1
    1102:	88 e0       	ldi	r24, 0x08	; 8
    1104:	be d3       	rcall	.+1916   	; 0x1882 <SH100HW_SetNewLedState>
			}
			SH100CTRL_MuteAmp();
    1106:	6a d5       	rcall	.+2772   	; 0x1bdc <SH100CTRL_MuteAmp>
    1108:	08 95       	ret

Disassembly of section .text.SH100HW_Init:

00001248 <SH100HW_Init>:

bool isPAOk;

void SH100HW_Init()
{
	isPAOk = false;
    1248:	10 92 65 01 	sts	0x0165, r1	; 0x800165 <isPAOk>
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
    124c:	55 b1       	in	r21, 0x05	; 5
		}

		*((uint8_t *)port + 1) |= pin_mask;
    124e:	94 b1       	in	r25, 0x04	; 4
    1250:	98 62       	ori	r25, 0x28	; 40
		port_pin_flags_t flags)
{
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
    1252:	88 b1       	in	r24, 0x08	; 8
    1254:	80 61       	ori	r24, 0x10	; 16
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
		}

		*((uint8_t *)port + 1) |= pin_mask;
    1256:	27 b1       	in	r18, 0x07	; 7
    1258:	20 61       	ori	r18, 0x10	; 16
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
    125a:	3b b1       	in	r19, 0x0b	; 11
		}

		*((uint8_t *)port + 1) |= pin_mask;
    125c:	4a b1       	in	r20, 0x0a	; 10
    125e:	40 6e       	ori	r20, 0xE0	; 224
	} else {
		*((uint8_t *)port + 1) &= ~pin_mask;
		if (flags & IOPORT_PULL_UP) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
    1260:	3b 71       	andi	r19, 0x1B	; 27
			*((uint8_t *)port + 2) &= ~pin_mask;
		}

		*((uint8_t *)port + 1) |= pin_mask;
	} else {
		*((uint8_t *)port + 1) &= ~pin_mask;
    1262:	4b 7e       	andi	r20, 0xEB	; 235
    1264:	4a b9       	out	0x0a, r20	; 10
		if (flags & IOPORT_PULL_UP) {
			*((uint8_t *)port + 2) |= pin_mask;
    1266:	30 61       	ori	r19, 0x10	; 16
    1268:	3b b9       	out	0x0b, r19	; 11
			*((uint8_t *)port + 2) &= ~pin_mask;
		}

		*((uint8_t *)port + 1) |= pin_mask;
	} else {
		*((uint8_t *)port + 1) &= ~pin_mask;
    126a:	2b 7d       	andi	r18, 0xDB	; 219
		if (flags & IOPORT_PULL_UP) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
    126c:	8b 7d       	andi	r24, 0xDB	; 219
			*((uint8_t *)port + 2) &= ~pin_mask;
		}

		*((uint8_t *)port + 1) |= pin_mask;
	} else {
		*((uint8_t *)port + 1) &= ~pin_mask;
    126e:	9c 7f       	andi	r25, 0xFC	; 252
		port_pin_flags_t flags)
{
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
    1270:	82 60       	ori	r24, 0x02	; 2
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
    1272:	87 7f       	andi	r24, 0xF7	; 247
    1274:	88 b9       	out	0x08, r24	; 8
		}

		*((uint8_t *)port + 1) |= pin_mask;
    1276:	82 2f       	mov	r24, r18
    1278:	8a 60       	ori	r24, 0x0A	; 10
    127a:	87 b9       	out	0x07, r24	; 7
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
    127c:	85 2f       	mov	r24, r21
    127e:	80 7d       	andi	r24, 0xD0	; 208
    1280:	85 b9       	out	0x05, r24	; 5
		}

		*((uint8_t *)port + 1) |= pin_mask;
    1282:	89 2f       	mov	r24, r25
    1284:	84 60       	ori	r24, 0x04	; 4
    1286:	84 b9       	out	0x04, r24	; 4
	//gpio_configure_pin(PIN_SW, IOPORT_INIT_LOW | IOPORT_DIR_OUTPUT);
	gpio_configure_pin(PIN_MUTE, IOPORT_INIT_HIGH | IOPORT_DIR_OUTPUT); // MUTE on start
	gpio_configure_pin(PIN_RELE_W, IOPORT_INIT_LOW | IOPORT_DIR_OUTPUT);
	gpio_configure_pin(PIN_RELAY_LOOP, IOPORT_INIT_LOW | IOPORT_DIR_OUTPUT);
	
	for(int i=0; i< LED_COUNT; i++)
    1288:	80 e0       	ldi	r24, 0x00	; 0
    128a:	90 e0       	ldi	r25, 0x00	; 0
    128c:	0a c0       	rjmp	.+20     	; 0x12a2 <SH100HW_Init+0x5a>
	{
		led[i].blinkCount = 255; // set default blink count to infinite
    128e:	fc 01       	movw	r30, r24
    1290:	ee 0f       	add	r30, r30
    1292:	ff 1f       	adc	r31, r31
    1294:	e8 0f       	add	r30, r24
    1296:	f9 1f       	adc	r31, r25
    1298:	e9 5b       	subi	r30, 0xB9	; 185
    129a:	fe 4f       	sbci	r31, 0xFE	; 254
    129c:	2f ef       	ldi	r18, 0xFF	; 255
    129e:	22 83       	std	Z+2, r18	; 0x02
	//gpio_configure_pin(PIN_SW, IOPORT_INIT_LOW | IOPORT_DIR_OUTPUT);
	gpio_configure_pin(PIN_MUTE, IOPORT_INIT_HIGH | IOPORT_DIR_OUTPUT); // MUTE on start
	gpio_configure_pin(PIN_RELE_W, IOPORT_INIT_LOW | IOPORT_DIR_OUTPUT);
	gpio_configure_pin(PIN_RELAY_LOOP, IOPORT_INIT_LOW | IOPORT_DIR_OUTPUT);
	
	for(int i=0; i< LED_COUNT; i++)
    12a0:	01 96       	adiw	r24, 0x01	; 1
    12a2:	89 30       	cpi	r24, 0x09	; 9
    12a4:	91 05       	cpc	r25, r1
    12a6:	9c f3       	brlt	.-26     	; 0x128e <SH100HW_Init+0x46>
	{
		led[i].blinkCount = 255; // set default blink count to infinite
	}
}
    12a8:	08 95       	ret

Disassembly of section .text.SH100HW_SetPAFailure:

00001b40 <SH100HW_SetPAFailure>:

void SH100HW_SetPAFailure(bool isFail)
{
	isPAOk = !isFail;
    1b40:	91 e0       	ldi	r25, 0x01	; 1
    1b42:	98 27       	eor	r25, r24
    1b44:	90 93 65 01 	sts	0x0165, r25	; 0x800165 <isPAOk>
	if(isFail)
    1b48:	81 11       	cpse	r24, r1
	{
		SH100CTRL_MuteAmp();
    1b4a:	48 d0       	rcall	.+144    	; 0x1bdc <SH100CTRL_MuteAmp>
    1b4c:	08 95       	ret

Disassembly of section .text.SH100HW_GetPAFailure:

00001b9a <SH100HW_GetPAFailure>:
	}
}

bool SH100HW_GetPAFailure()
{
	return !isPAOk;
    1b9a:	90 91 65 01 	lds	r25, 0x0165	; 0x800165 <isPAOk>
}
    1b9e:	81 e0       	ldi	r24, 0x01	; 1
    1ba0:	89 27       	eor	r24, r25
    1ba2:	08 95       	ret

Disassembly of section .text.SH100HW_SetCh:

000013b2 <SH100HW_SetCh>:

void SH100HW_SetCh(uint8_t chNum)
{
	switch(chNum)
    13b2:	81 30       	cpi	r24, 0x01	; 1
    13b4:	69 f0       	breq	.+26     	; 0x13d0 <SH100HW_SetCh+0x1e>
    13b6:	28 f0       	brcs	.+10     	; 0x13c2 <SH100HW_SetCh+0x10>
    13b8:	82 30       	cpi	r24, 0x02	; 2
    13ba:	91 f0       	breq	.+36     	; 0x13e0 <SH100HW_SetCh+0x2e>
    13bc:	83 30       	cpi	r24, 0x03	; 3
    13be:	c1 f0       	breq	.+48     	; 0x13f0 <SH100HW_SetCh+0x3e>
    13c0:	08 95       	ret
	{
		case 0:
		{
			RELAY_13_24 = REL_OFF;
    13c2:	10 92 64 01 	sts	0x0164, r1	; 0x800164 <RELAY_13_24>
			RELAY_1_3 = REL_OFF;
    13c6:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <RELAY_1_3>
			RELAY_2_4 = REL_OFF;
    13ca:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <RELAY_2_4>
			break;
    13ce:	08 95       	ret
		}
		case 1:
		{
			RELAY_13_24 = REL_ON;
    13d0:	81 e0       	ldi	r24, 0x01	; 1
    13d2:	80 93 64 01 	sts	0x0164, r24	; 0x800164 <RELAY_13_24>
			RELAY_1_3 = REL_OFF;
    13d6:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <RELAY_1_3>
			RELAY_2_4 = REL_OFF;
    13da:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <RELAY_2_4>
			break;
    13de:	08 95       	ret
		}
		case 2:
		{
			RELAY_13_24 = REL_OFF;
    13e0:	10 92 64 01 	sts	0x0164, r1	; 0x800164 <RELAY_13_24>
			RELAY_1_3 = REL_ON;
    13e4:	81 e0       	ldi	r24, 0x01	; 1
    13e6:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <RELAY_1_3>
			RELAY_2_4 = REL_OFF;
    13ea:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <RELAY_2_4>
			break;
    13ee:	08 95       	ret
		}
		case 3:
		{
			RELAY_13_24 = REL_ON;
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	80 93 64 01 	sts	0x0164, r24	; 0x800164 <RELAY_13_24>
			RELAY_1_3 = REL_OFF;
    13f6:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <RELAY_1_3>
			RELAY_2_4 = REL_ON;
    13fa:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <RELAY_2_4>
    13fe:	08 95       	ret

Disassembly of section .text.SH100HW_LoopEn:

00001a50 <SH100HW_LoopEn>:
	}
}

void SH100HW_LoopEn(bool isEnabled)
{
	RELAY_LOOP = isEnabled;
    1a50:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <RELAY_LOOP>
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
    1a54:	88 23       	and	r24, r24
    1a56:	21 f0       	breq	.+8      	; 0x1a60 <SH100HW_LoopEn+0x10>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    1a58:	85 b1       	in	r24, 0x05	; 5
    1a5a:	84 60       	ori	r24, 0x04	; 4
    1a5c:	85 b9       	out	0x05, r24	; 5
    1a5e:	08 95       	ret
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    1a60:	85 b1       	in	r24, 0x05	; 5
    1a62:	8b 7f       	andi	r24, 0xFB	; 251
    1a64:	85 b9       	out	0x05, r24	; 5
    1a66:	08 95       	ret

Disassembly of section .text.SH100HW_SetAB:

00001be2 <SH100HW_SetAB>:
	ioport_set_pin_level(PIN_RELAY_LOOP, RELAY_LOOP);
}

void SH100HW_SetAB(bool isBEn)
{
	RELAY_AB = isBEn;
    1be2:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <RELAY_AB>
    1be6:	08 95       	ret

Disassembly of section .text.SH100HW_SetNewLedState:

00001882 <SH100HW_SetNewLedState>:
}

void SH100HW_SetNewLedState(uint8_t ledId, SH100HW_LedState_t newState)
{
	if(led[ledId].curState != newState)
    1882:	90 e0       	ldi	r25, 0x00	; 0
    1884:	fc 01       	movw	r30, r24
    1886:	ee 0f       	add	r30, r30
    1888:	ff 1f       	adc	r31, r31
    188a:	e8 0f       	add	r30, r24
    188c:	f9 1f       	adc	r31, r25
    188e:	e9 5b       	subi	r30, 0xB9	; 185
    1890:	fe 4f       	sbci	r31, 0xFE	; 254
    1892:	20 81       	ld	r18, Z
    1894:	26 17       	cp	r18, r22
    1896:	51 f0       	breq	.+20     	; 0x18ac <SH100HW_SetNewLedState+0x2a>
	{
		led[ledId].prevState = led[ledId].curState;
    1898:	fc 01       	movw	r30, r24
    189a:	ee 0f       	add	r30, r30
    189c:	ff 1f       	adc	r31, r31
    189e:	8e 0f       	add	r24, r30
    18a0:	9f 1f       	adc	r25, r31
    18a2:	fc 01       	movw	r30, r24
    18a4:	e9 5b       	subi	r30, 0xB9	; 185
    18a6:	fe 4f       	sbci	r31, 0xFE	; 254
    18a8:	21 83       	std	Z+1, r18	; 0x01
		led[ledId].curState = newState;
    18aa:	60 83       	st	Z, r22
    18ac:	08 95       	ret

Disassembly of section .text.SH100HW_SetPreviousLedState:

00001a68 <SH100HW_SetPreviousLedState>:
	}
}

void SH100HW_SetPreviousLedState(uint8_t ledId)
{
	led[ledId].curState = led[ledId].prevState;
    1a68:	90 e0       	ldi	r25, 0x00	; 0
    1a6a:	fc 01       	movw	r30, r24
    1a6c:	ee 0f       	add	r30, r30
    1a6e:	ff 1f       	adc	r31, r31
    1a70:	8e 0f       	add	r24, r30
    1a72:	9f 1f       	adc	r25, r31
    1a74:	fc 01       	movw	r30, r24
    1a76:	e9 5b       	subi	r30, 0xB9	; 185
    1a78:	fe 4f       	sbci	r31, 0xFE	; 254
    1a7a:	81 81       	ldd	r24, Z+1	; 0x01
    1a7c:	80 83       	st	Z, r24
    1a7e:	08 95       	ret

Disassembly of section .text.SH100HW_SetLedBlinkCount:

00001636 <SH100HW_SetLedBlinkCount>:
}

void SH100HW_SetLedBlinkCount(uint8_t ledId, uint8_t blinkCount)
{
	if(led[ledId].curState != LED_FAST_BLINKING)
    1636:	90 e0       	ldi	r25, 0x00	; 0
    1638:	fc 01       	movw	r30, r24
    163a:	ee 0f       	add	r30, r30
    163c:	ff 1f       	adc	r31, r31
    163e:	e8 0f       	add	r30, r24
    1640:	f9 1f       	adc	r31, r25
    1642:	e9 5b       	subi	r30, 0xB9	; 185
    1644:	fe 4f       	sbci	r31, 0xFE	; 254
    1646:	20 81       	ld	r18, Z
    1648:	22 30       	cpi	r18, 0x02	; 2
    164a:	41 f0       	breq	.+16     	; 0x165c <SH100HW_SetLedBlinkCount+0x26>
	{
		led[ledId].prevState = led[ledId].curState;
    164c:	fc 01       	movw	r30, r24
    164e:	ee 0f       	add	r30, r30
    1650:	ff 1f       	adc	r31, r31
    1652:	e8 0f       	add	r30, r24
    1654:	f9 1f       	adc	r31, r25
    1656:	e9 5b       	subi	r30, 0xB9	; 185
    1658:	fe 4f       	sbci	r31, 0xFE	; 254
    165a:	21 83       	std	Z+1, r18	; 0x01
	}
	led[ledId].curState = LED_FAST_BLINKING;
    165c:	fc 01       	movw	r30, r24
    165e:	ee 0f       	add	r30, r30
    1660:	ff 1f       	adc	r31, r31
    1662:	8e 0f       	add	r24, r30
    1664:	9f 1f       	adc	r25, r31
    1666:	fc 01       	movw	r30, r24
    1668:	e9 5b       	subi	r30, 0xB9	; 185
    166a:	fe 4f       	sbci	r31, 0xFE	; 254
    166c:	82 e0       	ldi	r24, 0x02	; 2
    166e:	80 83       	st	Z, r24
	led[ledId].blinkCount = blinkCount*2;
    1670:	66 0f       	add	r22, r22
    1672:	62 83       	std	Z+2, r22	; 0x02
    1674:	08 95       	ret

Disassembly of section .text.SH100HW_GetOutputJacks:

00001a80 <SH100HW_GetOutputJacks>:
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
    1a80:	21 e0       	ldi	r18, 0x01	; 1
    1a82:	18 9b       	sbis	0x03, 0	; 3
    1a84:	20 e0       	ldi	r18, 0x00	; 0
    1a86:	91 e0       	ldi	r25, 0x01	; 1
    1a88:	19 9b       	sbis	0x03, 1	; 3
    1a8a:	90 e0       	ldi	r25, 0x00	; 0

SH100HW_OutputJacks_t SH100HW_GetOutputJacks()
{
	bool is16Ohm = ioport_get_pin_level(PIN_M16_DETECT);
	bool is8Ohm = ioport_get_pin_level(PIN_M8_DETECT);
	return ((is16Ohm) | (is8Ohm<<1));
    1a8c:	89 2f       	mov	r24, r25
    1a8e:	90 e0       	ldi	r25, 0x00	; 0
    1a90:	88 0f       	add	r24, r24
    1a92:	99 1f       	adc	r25, r25
}
    1a94:	82 2b       	or	r24, r18
    1a96:	08 95       	ret

Disassembly of section .text.SH100HW_SetPAState:

000016b4 <SH100HW_SetPAState>:

void SH100HW_SetPAState(SH100HW_OutputState_t state)
{
	if(isPAOk)
    16b4:	90 91 65 01 	lds	r25, 0x0165	; 0x800165 <isPAOk>
    16b8:	99 23       	and	r25, r25
    16ba:	99 f0       	breq	.+38     	; 0x16e2 <SH100HW_SetPAState+0x2e>
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
    16bc:	81 11       	cpse	r24, r1
    16be:	04 c0       	rjmp	.+8      	; 0x16c8 <SH100HW_SetPAState+0x14>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    16c0:	98 b1       	in	r25, 0x08	; 8
    16c2:	92 60       	ori	r25, 0x02	; 2
    16c4:	98 b9       	out	0x08, r25	; 8
    16c6:	03 c0       	rjmp	.+6      	; 0x16ce <SH100HW_SetPAState+0x1a>
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    16c8:	98 b1       	in	r25, 0x08	; 8
    16ca:	9d 7f       	andi	r25, 0xFD	; 253
    16cc:	98 b9       	out	0x08, r25	; 8
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
    16ce:	88 23       	and	r24, r24
    16d0:	21 f0       	breq	.+8      	; 0x16da <SH100HW_SetPAState+0x26>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    16d2:	88 b1       	in	r24, 0x08	; 8
    16d4:	88 60       	ori	r24, 0x08	; 8
    16d6:	88 b9       	out	0x08, r24	; 8
    16d8:	08 95       	ret
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    16da:	88 b1       	in	r24, 0x08	; 8
    16dc:	87 7f       	andi	r24, 0xF7	; 247
    16de:	88 b9       	out	0x08, r24	; 8
    16e0:	08 95       	ret
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    16e2:	88 b1       	in	r24, 0x08	; 8
    16e4:	82 60       	ori	r24, 0x02	; 2
    16e6:	88 b9       	out	0x08, r24	; 8
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    16e8:	88 b1       	in	r24, 0x08	; 8
    16ea:	87 7f       	andi	r24, 0xF7	; 247
    16ec:	88 b9       	out	0x08, r24	; 8
    16ee:	08 95       	ret

Disassembly of section .text.SH100HW_SetOutputMode:

00001be8 <SH100HW_SetOutputMode>:
	}
}

void SH100HW_SetOutputMode(SH100HW_PAMode_t mode)
{
	RELAY_8_16 = mode;
    1be8:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <RELAY_8_16>
    1bec:	08 95       	ret

Disassembly of section .text.SH100HW_StartADConvertion:

00001aee <SH100HW_StartADConvertion>:
}

void SH100HW_StartADConvertion(ADC_Channels_t channel)
{
	ADMUX = (1<<REFS0) | channel; // AREF ext pin, Left-adjustment result
    1aee:	80 64       	ori	r24, 0x40	; 64
    1af0:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7fe07c>
	DIDR0 = 0x01; // Disable digital io on PC0
    1af4:	81 e0       	ldi	r24, 0x01	; 1
    1af6:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7fe07e>
	ADCSRA = (1<<ADEN) | (1<<ADSC) | (1<<ADIE) | (1<<ADPS2) | (1<<ADPS1); // ADC enable, INT enable, prescaler = 64
    1afa:	8e ec       	ldi	r24, 0xCE	; 206
    1afc:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7fe07a>
    1b00:	08 95       	ret

Disassembly of section .text.SH100HW_GetControlsState:

00000960 <SH100HW_GetControlsState>:
}

SH100HW_Controls_t SH100HW_GetControlsState()
{
 960:	cf 93       	push	r28
 962:	df 93       	push	r29
 964:	dc 01       	movw	r26, r24
	SH100HW_Controls_t buttonsState;
	uint8_t midiChBit[4];
	for(uint8_t cnt = 0; cnt<8; cnt++)
 966:	90 e0       	ldi	r25, 0x00	; 0
 968:	be c0       	rjmp	.+380    	; 0xae6 <SH100HW_GetControlsState+0x186>
	{
		
		switch(cnt)
 96a:	49 2f       	mov	r20, r25
 96c:	50 e0       	ldi	r21, 0x00	; 0
 96e:	48 30       	cpi	r20, 0x08	; 8
 970:	51 05       	cpc	r21, r1
 972:	08 f0       	brcs	.+2      	; 0x976 <SH100HW_GetControlsState+0x16>
 974:	b7 c0       	rjmp	.+366    	; 0xae4 <SH100HW_GetControlsState+0x184>
 976:	fa 01       	movw	r30, r20
 978:	ef 5d       	subi	r30, 0xDF	; 223
 97a:	ff 4f       	sbci	r31, 0xFF	; 255
 97c:	09 94       	ijmp
 97e:	8b b1       	in	r24, 0x0b	; 11
 980:	8f 7d       	andi	r24, 0xDF	; 223
 982:	8b b9       	out	0x0b, r24	; 11
 984:	8b b1       	in	r24, 0x0b	; 11
 986:	8f 7b       	andi	r24, 0xBF	; 191
 988:	8b b9       	out	0x0b, r24	; 11
 98a:	8b b1       	in	r24, 0x0b	; 11
 98c:	8f 77       	andi	r24, 0x7F	; 127
 98e:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 990:	81 e0       	ldi	r24, 0x01	; 1
 992:	4c 9b       	sbis	0x09, 4	; 9
 994:	80 e0       	ldi	r24, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 0);
				ioport_set_pin_level(PIN_B, 0);
				ioport_set_pin_level(PIN_C, 0);
				
				buttonsState.midiOmni = ioport_get_pin_level(PIN_MIDI_SWITCH);
 996:	11 96       	adiw	r26, 0x01	; 1
 998:	8c 93       	st	X, r24
 99a:	11 97       	sbiw	r26, 0x01	; 1
 99c:	81 e0       	ldi	r24, 0x01	; 1
 99e:	35 9b       	sbis	0x06, 5	; 6
 9a0:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.FS2_sleeve = ioport_get_pin_level(PIN_FOOTSWITCH);
 9a2:	1c 96       	adiw	r26, 0x0c	; 12
 9a4:	8c 93       	st	X, r24
 9a6:	1c 97       	sbiw	r26, 0x0c	; 12
				break;
 9a8:	9d c0       	rjmp	.+314    	; 0xae4 <SH100HW_GetControlsState+0x184>
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 9aa:	8b b1       	in	r24, 0x0b	; 11
 9ac:	80 62       	ori	r24, 0x20	; 32
 9ae:	8b b9       	out	0x0b, r24	; 11
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 9b0:	8b b1       	in	r24, 0x0b	; 11
 9b2:	8f 7b       	andi	r24, 0xBF	; 191
 9b4:	8b b9       	out	0x0b, r24	; 11
 9b6:	8b b1       	in	r24, 0x0b	; 11
 9b8:	8f 77       	andi	r24, 0x7F	; 127
 9ba:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 9bc:	81 e0       	ldi	r24, 0x01	; 1
 9be:	4c 9b       	sbis	0x09, 4	; 9
 9c0:	80 e0       	ldi	r24, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 1);
				ioport_set_pin_level(PIN_B, 0);
				ioport_set_pin_level(PIN_C, 0);
				
				midiChBit[3] = ioport_get_pin_level(PIN_MIDI_SWITCH);
 9c2:	28 2f       	mov	r18, r24
 9c4:	81 e0       	ldi	r24, 0x01	; 1
 9c6:	4a 9b       	sbis	0x09, 2	; 9
 9c8:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.btnAB = ioport_get_pin_level(PIN_BUTTONS);
 9ca:	17 96       	adiw	r26, 0x07	; 7
 9cc:	8c 93       	st	X, r24
 9ce:	17 97       	sbiw	r26, 0x07	; 7
 9d0:	81 e0       	ldi	r24, 0x01	; 1
 9d2:	35 9b       	sbis	0x06, 5	; 6
 9d4:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.FS2_presence = ioport_get_pin_level(PIN_FOOTSWITCH);
 9d6:	1e 96       	adiw	r26, 0x0e	; 14
 9d8:	8c 93       	st	X, r24
 9da:	1e 97       	sbiw	r26, 0x0e	; 14
				break;
 9dc:	83 c0       	rjmp	.+262    	; 0xae4 <SH100HW_GetControlsState+0x184>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 9de:	8b b1       	in	r24, 0x0b	; 11
 9e0:	8f 7d       	andi	r24, 0xDF	; 223
 9e2:	8b b9       	out	0x0b, r24	; 11
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 9e4:	8b b1       	in	r24, 0x0b	; 11
 9e6:	80 64       	ori	r24, 0x40	; 64
 9e8:	8b b9       	out	0x0b, r24	; 11
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 9ea:	8b b1       	in	r24, 0x0b	; 11
 9ec:	8f 77       	andi	r24, 0x7F	; 127
 9ee:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 9f0:	41 e0       	ldi	r20, 0x01	; 1
 9f2:	4c 9b       	sbis	0x09, 4	; 9
 9f4:	40 e0       	ldi	r20, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 0);
				ioport_set_pin_level(PIN_B, 1);
				ioport_set_pin_level(PIN_C, 0);
				
				midiChBit[2] = ioport_get_pin_level(PIN_MIDI_SWITCH);
 9f6:	34 2f       	mov	r19, r20
 9f8:	81 e0       	ldi	r24, 0x01	; 1
 9fa:	4a 9b       	sbis	0x09, 2	; 9
 9fc:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.btnLoop = ioport_get_pin_level(PIN_BUTTONS);
 9fe:	18 96       	adiw	r26, 0x08	; 8
 a00:	8c 93       	st	X, r24
 a02:	18 97       	sbiw	r26, 0x08	; 8
 a04:	81 e0       	ldi	r24, 0x01	; 1
 a06:	35 9b       	sbis	0x06, 5	; 6
 a08:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.FS1_presence = ioport_get_pin_level(PIN_FOOTSWITCH);
 a0a:	1b 96       	adiw	r26, 0x0b	; 11
 a0c:	8c 93       	st	X, r24
 a0e:	1b 97       	sbiw	r26, 0x0b	; 11
				break;
 a10:	69 c0       	rjmp	.+210    	; 0xae4 <SH100HW_GetControlsState+0x184>
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 a12:	8b b1       	in	r24, 0x0b	; 11
 a14:	80 62       	ori	r24, 0x20	; 32
 a16:	8b b9       	out	0x0b, r24	; 11
 a18:	8b b1       	in	r24, 0x0b	; 11
 a1a:	80 64       	ori	r24, 0x40	; 64
 a1c:	8b b9       	out	0x0b, r24	; 11
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 a1e:	8b b1       	in	r24, 0x0b	; 11
 a20:	8f 77       	andi	r24, 0x7F	; 127
 a22:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 a24:	81 e0       	ldi	r24, 0x01	; 1
 a26:	4c 9b       	sbis	0x09, 4	; 9
 a28:	80 e0       	ldi	r24, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 1);
				ioport_set_pin_level(PIN_B, 1);
				ioport_set_pin_level(PIN_C, 0);
				
				buttonsState.midiMuteComm = ioport_get_pin_level(PIN_MIDI_SWITCH);
 a2a:	12 96       	adiw	r26, 0x02	; 2
 a2c:	8c 93       	st	X, r24
 a2e:	12 97       	sbiw	r26, 0x02	; 2
 a30:	81 e0       	ldi	r24, 0x01	; 1
 a32:	35 9b       	sbis	0x06, 5	; 6
 a34:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.FS1_sleeve = ioport_get_pin_level(PIN_FOOTSWITCH);
 a36:	19 96       	adiw	r26, 0x09	; 9
 a38:	8c 93       	st	X, r24
 a3a:	19 97       	sbiw	r26, 0x09	; 9
				break;
 a3c:	53 c0       	rjmp	.+166    	; 0xae4 <SH100HW_GetControlsState+0x184>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 a3e:	8b b1       	in	r24, 0x0b	; 11
 a40:	8f 7d       	andi	r24, 0xDF	; 223
 a42:	8b b9       	out	0x0b, r24	; 11
 a44:	8b b1       	in	r24, 0x0b	; 11
 a46:	8f 7b       	andi	r24, 0xBF	; 191
 a48:	8b b9       	out	0x0b, r24	; 11
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 a4a:	8b b1       	in	r24, 0x0b	; 11
 a4c:	80 68       	ori	r24, 0x80	; 128
 a4e:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 a50:	61 e0       	ldi	r22, 0x01	; 1
 a52:	4c 9b       	sbis	0x09, 4	; 9
 a54:	60 e0       	ldi	r22, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 0);
				ioport_set_pin_level(PIN_B, 0);
				ioport_set_pin_level(PIN_C, 1);
				
				midiChBit[0] = ioport_get_pin_level(PIN_MIDI_SWITCH);
 a56:	d6 2f       	mov	r29, r22
 a58:	81 e0       	ldi	r24, 0x01	; 1
 a5a:	4a 9b       	sbis	0x09, 2	; 9
 a5c:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.btnCh2 = ioport_get_pin_level(PIN_BUTTONS);
 a5e:	14 96       	adiw	r26, 0x04	; 4
 a60:	8c 93       	st	X, r24
 a62:	14 97       	sbiw	r26, 0x04	; 4
 a64:	81 e0       	ldi	r24, 0x01	; 1
 a66:	35 9b       	sbis	0x06, 5	; 6
 a68:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.FS1_tip = ioport_get_pin_level(PIN_FOOTSWITCH);
 a6a:	1a 96       	adiw	r26, 0x0a	; 10
 a6c:	8c 93       	st	X, r24
 a6e:	1a 97       	sbiw	r26, 0x0a	; 10
				break;
 a70:	39 c0       	rjmp	.+114    	; 0xae4 <SH100HW_GetControlsState+0x184>
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 a72:	8b b1       	in	r24, 0x0b	; 11
 a74:	80 62       	ori	r24, 0x20	; 32
 a76:	8b b9       	out	0x0b, r24	; 11
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 a78:	8b b1       	in	r24, 0x0b	; 11
 a7a:	8f 7b       	andi	r24, 0xBF	; 191
 a7c:	8b b9       	out	0x0b, r24	; 11
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 a7e:	8b b1       	in	r24, 0x0b	; 11
 a80:	80 68       	ori	r24, 0x80	; 128
 a82:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 a84:	81 e0       	ldi	r24, 0x01	; 1
 a86:	4a 9b       	sbis	0x09, 2	; 9
 a88:	80 e0       	ldi	r24, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 1);
				ioport_set_pin_level(PIN_B, 0);
				ioport_set_pin_level(PIN_C, 1);
				
				buttonsState.btnCh3 = ioport_get_pin_level(PIN_BUTTONS);
 a8a:	15 96       	adiw	r26, 0x05	; 5
 a8c:	8c 93       	st	X, r24
 a8e:	15 97       	sbiw	r26, 0x05	; 5
				break;
 a90:	29 c0       	rjmp	.+82     	; 0xae4 <SH100HW_GetControlsState+0x184>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 a92:	8b b1       	in	r24, 0x0b	; 11
 a94:	8f 7d       	andi	r24, 0xDF	; 223
 a96:	8b b9       	out	0x0b, r24	; 11
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 a98:	8b b1       	in	r24, 0x0b	; 11
 a9a:	80 64       	ori	r24, 0x40	; 64
 a9c:	8b b9       	out	0x0b, r24	; 11
 a9e:	8b b1       	in	r24, 0x0b	; 11
 aa0:	80 68       	ori	r24, 0x80	; 128
 aa2:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 aa4:	61 e0       	ldi	r22, 0x01	; 1
 aa6:	4c 9b       	sbis	0x09, 4	; 9
 aa8:	60 e0       	ldi	r22, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 0);
				ioport_set_pin_level(PIN_B, 1);
				ioport_set_pin_level(PIN_C, 1);
				
				midiChBit[1] = ioport_get_pin_level(PIN_MIDI_SWITCH);
 aaa:	c6 2f       	mov	r28, r22
 aac:	81 e0       	ldi	r24, 0x01	; 1
 aae:	4a 9b       	sbis	0x09, 2	; 9
 ab0:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.btnCh4 = ioport_get_pin_level(PIN_BUTTONS);
 ab2:	16 96       	adiw	r26, 0x06	; 6
 ab4:	8c 93       	st	X, r24
 ab6:	16 97       	sbiw	r26, 0x06	; 6
 ab8:	81 e0       	ldi	r24, 0x01	; 1
 aba:	35 9b       	sbis	0x06, 5	; 6
 abc:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.FS2_tip = ioport_get_pin_level(PIN_FOOTSWITCH);
 abe:	1d 96       	adiw	r26, 0x0d	; 13
 ac0:	8c 93       	st	X, r24
 ac2:	1d 97       	sbiw	r26, 0x0d	; 13
				break;
 ac4:	0f c0       	rjmp	.+30     	; 0xae4 <SH100HW_GetControlsState+0x184>
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 ac6:	8b b1       	in	r24, 0x0b	; 11
 ac8:	80 62       	ori	r24, 0x20	; 32
 aca:	8b b9       	out	0x0b, r24	; 11
 acc:	8b b1       	in	r24, 0x0b	; 11
 ace:	80 64       	ori	r24, 0x40	; 64
 ad0:	8b b9       	out	0x0b, r24	; 11
 ad2:	8b b1       	in	r24, 0x0b	; 11
 ad4:	80 68       	ori	r24, 0x80	; 128
 ad6:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 ad8:	81 e0       	ldi	r24, 0x01	; 1
 ada:	4a 9b       	sbis	0x09, 2	; 9
 adc:	80 e0       	ldi	r24, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 1);
				ioport_set_pin_level(PIN_B, 1);
				ioport_set_pin_level(PIN_C, 1);
				
				buttonsState.btnCh1 = ioport_get_pin_level(PIN_BUTTONS);
 ade:	13 96       	adiw	r26, 0x03	; 3
 ae0:	8c 93       	st	X, r24
 ae2:	13 97       	sbiw	r26, 0x03	; 3

SH100HW_Controls_t SH100HW_GetControlsState()
{
	SH100HW_Controls_t buttonsState;
	uint8_t midiChBit[4];
	for(uint8_t cnt = 0; cnt<8; cnt++)
 ae4:	9f 5f       	subi	r25, 0xFF	; 255
 ae6:	98 30       	cpi	r25, 0x08	; 8
 ae8:	08 f4       	brcc	.+2      	; 0xaec <SH100HW_GetControlsState+0x18c>
 aea:	3f cf       	rjmp	.-386    	; 0x96a <SH100HW_GetControlsState+0xa>
			}
			default: break;
		}
	}
	
	buttonsState.midiChNum = midiChBit[0] | (midiChBit[1]<<1) | (midiChBit[2]<<2) | (midiChBit[3]<<3);
 aec:	6c 2f       	mov	r22, r28
 aee:	70 e0       	ldi	r23, 0x00	; 0
 af0:	66 0f       	add	r22, r22
 af2:	77 1f       	adc	r23, r23
 af4:	43 2f       	mov	r20, r19
 af6:	50 e0       	ldi	r21, 0x00	; 0
 af8:	44 0f       	add	r20, r20
 afa:	55 1f       	adc	r21, r21
 afc:	44 0f       	add	r20, r20
 afe:	55 1f       	adc	r21, r21
 b00:	82 2f       	mov	r24, r18
 b02:	90 e0       	ldi	r25, 0x00	; 0
 b04:	88 0f       	add	r24, r24
 b06:	99 1f       	adc	r25, r25
 b08:	88 0f       	add	r24, r24
 b0a:	99 1f       	adc	r25, r25
 b0c:	88 0f       	add	r24, r24
 b0e:	99 1f       	adc	r25, r25
 b10:	6d 2b       	or	r22, r29
 b12:	46 2b       	or	r20, r22
 b14:	84 2b       	or	r24, r20
 b16:	8c 93       	st	X, r24
	
	return buttonsState;
}
 b18:	cd 01       	movw	r24, r26
 b1a:	df 91       	pop	r29
 b1c:	cf 91       	pop	r28
 b1e:	08 95       	ret

Disassembly of section .text.writeShiftRegs:

000015f4 <writeShiftRegs>:

void writeShiftRegs(uint16_t data)
{
    15f4:	ac 01       	movw	r20, r24
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    15f6:	88 b1       	in	r24, 0x08	; 8
    15f8:	8f 7e       	andi	r24, 0xEF	; 239
    15fa:	88 b9       	out	0x08, r24	; 8
	ioport_set_pin_level(PIN_ST, 0);
	for(uint8_t i=0; i<16; i++)
    15fc:	20 e0       	ldi	r18, 0x00	; 0
    15fe:	12 c0       	rjmp	.+36     	; 0x1624 <writeShiftRegs+0x30>
    1600:	95 b1       	in	r25, 0x05	; 5
    1602:	9f 7d       	andi	r25, 0xDF	; 223
    1604:	95 b9       	out	0x05, r25	; 5
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
    1606:	55 23       	and	r21, r21
    1608:	24 f4       	brge	.+8      	; 0x1612 <writeShiftRegs+0x1e>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    160a:	85 b1       	in	r24, 0x05	; 5
    160c:	88 60       	ori	r24, 0x08	; 8
    160e:	85 b9       	out	0x05, r24	; 5
    1610:	03 c0       	rjmp	.+6      	; 0x1618 <writeShiftRegs+0x24>
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    1612:	85 b1       	in	r24, 0x05	; 5
    1614:	87 7f       	andi	r24, 0xF7	; 247
    1616:	85 b9       	out	0x05, r24	; 5
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    1618:	95 b1       	in	r25, 0x05	; 5
    161a:	90 62       	ori	r25, 0x20	; 32
    161c:	95 b9       	out	0x05, r25	; 5
	{
		ioport_set_pin_level(PIN_SCK, 0);
		ioport_set_pin_level(PIN_MOSI, (data & 0x8000));
		ioport_set_pin_level(PIN_SCK, 1);
		data = data << 1;
    161e:	44 0f       	add	r20, r20
    1620:	55 1f       	adc	r21, r21
}

void writeShiftRegs(uint16_t data)
{
	ioport_set_pin_level(PIN_ST, 0);
	for(uint8_t i=0; i<16; i++)
    1622:	2f 5f       	subi	r18, 0xFF	; 255
    1624:	20 31       	cpi	r18, 0x10	; 16
    1626:	60 f3       	brcs	.-40     	; 0x1600 <writeShiftRegs+0xc>
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    1628:	85 b1       	in	r24, 0x05	; 5
    162a:	8f 7d       	andi	r24, 0xDF	; 223
    162c:	85 b9       	out	0x05, r24	; 5
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    162e:	88 b1       	in	r24, 0x08	; 8
    1630:	80 61       	ori	r24, 0x10	; 16
    1632:	88 b9       	out	0x08, r24	; 8
    1634:	08 95       	ret

Disassembly of section .text.SH100HW_MainTask:

0000031e <SH100HW_MainTask>:
uint8_t blinkDecrement;
bool slowBlink = false;
bool fastBlink = false;
uint8_t indErrorCnt = 0;
void SH100HW_MainTask()
{
 31e:	cf 93       	push	r28
 320:	df 93       	push	r29
 322:	cd b7       	in	r28, 0x3d	; 61
 324:	de b7       	in	r29, 0x3e	; 62
 326:	29 97       	sbiw	r28, 0x09	; 9
 328:	0f b6       	in	r0, 0x3f	; 63
 32a:	f8 94       	cli
 32c:	de bf       	out	0x3e, r29	; 62
 32e:	0f be       	out	0x3f, r0	; 63
 330:	cd bf       	out	0x3d, r28	; 61
	if(!isPAOk) SH100CTRL_MuteAmp();
 332:	80 91 65 01 	lds	r24, 0x0165	; 0x800165 <isPAOk>
 336:	81 11       	cpse	r24, r1
 338:	01 c0       	rjmp	.+2      	; 0x33c <SH100HW_MainTask+0x1e>
 33a:	50 dc       	rcall	.-1888   	; 0xfffffbdc <__eeprom_end+0xff7efbdc>
	
	//SH100HW_ReadControlsState();
	
	// blink work----------------------------------------------
	bool isLedOn[LED_COUNT];	
	if((blinkCounter % 25) == 0 && blinkCounter != 0)
 33c:	90 91 b0 01 	lds	r25, 0x01B0	; 0x8001b0 <blinkCounter>
 340:	89 e2       	ldi	r24, 0x29	; 41
 342:	98 9f       	mul	r25, r24
 344:	81 2d       	mov	r24, r1
 346:	11 24       	eor	r1, r1
 348:	86 95       	lsr	r24
 34a:	86 95       	lsr	r24
 34c:	39 2f       	mov	r19, r25
 34e:	29 e1       	ldi	r18, 0x19	; 25
 350:	82 9f       	mul	r24, r18
 352:	30 19       	sub	r19, r0
 354:	11 24       	eor	r1, r1
 356:	31 11       	cpse	r19, r1
 358:	0b c0       	rjmp	.+22     	; 0x370 <SH100HW_MainTask+0x52>
 35a:	99 23       	and	r25, r25
 35c:	49 f0       	breq	.+18     	; 0x370 <SH100HW_MainTask+0x52>
	{
		fastBlink = !fastBlink;
 35e:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <fastBlink>
 362:	91 e0       	ldi	r25, 0x01	; 1
 364:	89 27       	eor	r24, r25
 366:	80 93 ae 01 	sts	0x01AE, r24	; 0x8001ae <fastBlink>
		blinkDecrement = 1;
 36a:	90 93 44 01 	sts	0x0144, r25	; 0x800144 <blinkDecrement>
 36e:	02 c0       	rjmp	.+4      	; 0x374 <SH100HW_MainTask+0x56>
	}
	else
	{
		blinkDecrement = 0;
 370:	10 92 44 01 	sts	0x0144, r1	; 0x800144 <blinkDecrement>
	}
	
	if(blinkCounter == 50)
 374:	80 91 b0 01 	lds	r24, 0x01B0	; 0x8001b0 <blinkCounter>
 378:	82 33       	cpi	r24, 0x32	; 50
 37a:	51 f4       	brne	.+20     	; 0x390 <SH100HW_MainTask+0x72>
	{
		blinkCounter = 0;
 37c:	10 92 b0 01 	sts	0x01B0, r1	; 0x8001b0 <blinkCounter>
		slowBlink = !slowBlink;
 380:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <slowBlink>
 384:	81 e0       	ldi	r24, 0x01	; 1
 386:	89 27       	eor	r24, r25
 388:	80 93 af 01 	sts	0x01AF, r24	; 0x8001af <slowBlink>
uint8_t blinkDecrement;
bool slowBlink = false;
bool fastBlink = false;
uint8_t indErrorCnt = 0;
void SH100HW_MainTask()
{
 38c:	20 e0       	ldi	r18, 0x00	; 0
 38e:	6f c0       	rjmp	.+222    	; 0x46e <__DATA_REGION_LENGTH__+0x6e>
		blinkCounter = 0;
		slowBlink = !slowBlink;
	}
	else
	{
		blinkCounter++;
 390:	8f 5f       	subi	r24, 0xFF	; 255
 392:	80 93 b0 01 	sts	0x01B0, r24	; 0x8001b0 <blinkCounter>
 396:	fa cf       	rjmp	.-12     	; 0x38c <SH100HW_MainTask+0x6e>
	}
	
	for(uint8_t i=0; i<LED_COUNT; i++)
	{
		switch(led[i].curState)
 398:	82 2f       	mov	r24, r18
 39a:	90 e0       	ldi	r25, 0x00	; 0
 39c:	fc 01       	movw	r30, r24
 39e:	ee 0f       	add	r30, r30
 3a0:	ff 1f       	adc	r31, r31
 3a2:	e8 0f       	add	r30, r24
 3a4:	f9 1f       	adc	r31, r25
 3a6:	e9 5b       	subi	r30, 0xB9	; 185
 3a8:	fe 4f       	sbci	r31, 0xFE	; 254
 3aa:	30 81       	ld	r19, Z
 3ac:	31 30       	cpi	r19, 0x01	; 1
 3ae:	79 f0       	breq	.+30     	; 0x3ce <SH100HW_MainTask+0xb0>
 3b0:	30 f0       	brcs	.+12     	; 0x3be <SH100HW_MainTask+0xa0>
 3b2:	32 30       	cpi	r19, 0x02	; 2
 3b4:	a9 f0       	breq	.+42     	; 0x3e0 <SH100HW_MainTask+0xc2>
 3b6:	33 30       	cpi	r19, 0x03	; 3
 3b8:	09 f4       	brne	.+2      	; 0x3bc <SH100HW_MainTask+0x9e>
 3ba:	44 c0       	rjmp	.+136    	; 0x444 <__DATA_REGION_LENGTH__+0x44>
 3bc:	50 c0       	rjmp	.+160    	; 0x45e <__DATA_REGION_LENGTH__+0x5e>
		{
			case LED_OFF: isLedOn[i] = false; break;
 3be:	e1 e0       	ldi	r30, 0x01	; 1
 3c0:	f0 e0       	ldi	r31, 0x00	; 0
 3c2:	ec 0f       	add	r30, r28
 3c4:	fd 1f       	adc	r31, r29
 3c6:	e8 0f       	add	r30, r24
 3c8:	f9 1f       	adc	r31, r25
 3ca:	10 82       	st	Z, r1
 3cc:	4f c0       	rjmp	.+158    	; 0x46c <__DATA_REGION_LENGTH__+0x6c>
			case LED_ON: isLedOn[i] = true; break;
 3ce:	e1 e0       	ldi	r30, 0x01	; 1
 3d0:	f0 e0       	ldi	r31, 0x00	; 0
 3d2:	ec 0f       	add	r30, r28
 3d4:	fd 1f       	adc	r31, r29
 3d6:	e8 0f       	add	r30, r24
 3d8:	f9 1f       	adc	r31, r25
 3da:	31 e0       	ldi	r19, 0x01	; 1
 3dc:	30 83       	st	Z, r19
 3de:	46 c0       	rjmp	.+140    	; 0x46c <__DATA_REGION_LENGTH__+0x6c>
			case LED_FAST_BLINKING: 
			{
				isLedOn[i] = fastBlink; 
 3e0:	40 91 ae 01 	lds	r20, 0x01AE	; 0x8001ae <fastBlink>
 3e4:	e1 e0       	ldi	r30, 0x01	; 1
 3e6:	f0 e0       	ldi	r31, 0x00	; 0
 3e8:	ec 0f       	add	r30, r28
 3ea:	fd 1f       	adc	r31, r29
 3ec:	e8 0f       	add	r30, r24
 3ee:	f9 1f       	adc	r31, r25
 3f0:	40 83       	st	Z, r20
				isLedOn[LED_PWR_GRN] = !fastBlink; // Green led blink 180deg phase of red led
 3f2:	31 e0       	ldi	r19, 0x01	; 1
 3f4:	34 27       	eor	r19, r20
 3f6:	38 87       	std	Y+8, r19	; 0x08
				
				if(led[i].blinkCount != 255)
 3f8:	fc 01       	movw	r30, r24
 3fa:	ee 0f       	add	r30, r30
 3fc:	ff 1f       	adc	r31, r31
 3fe:	e8 0f       	add	r30, r24
 400:	f9 1f       	adc	r31, r25
 402:	e9 5b       	subi	r30, 0xB9	; 185
 404:	fe 4f       	sbci	r31, 0xFE	; 254
 406:	32 81       	ldd	r19, Z+2	; 0x02
 408:	3f 3f       	cpi	r19, 0xFF	; 255
 40a:	81 f1       	breq	.+96     	; 0x46c <__DATA_REGION_LENGTH__+0x6c>
				{
					if(led[i].blinkCount == 0)
 40c:	31 11       	cpse	r19, r1
 40e:	0d c0       	rjmp	.+26     	; 0x42a <__DATA_REGION_LENGTH__+0x2a>
					{
						led[i].curState = led[i].prevState;
 410:	fc 01       	movw	r30, r24
 412:	ee 0f       	add	r30, r30
 414:	ff 1f       	adc	r31, r31
 416:	8e 0f       	add	r24, r30
 418:	9f 1f       	adc	r25, r31
 41a:	fc 01       	movw	r30, r24
 41c:	e9 5b       	subi	r30, 0xB9	; 185
 41e:	fe 4f       	sbci	r31, 0xFE	; 254
 420:	81 81       	ldd	r24, Z+1	; 0x01
 422:	80 83       	st	Z, r24
						led[i].blinkCount = 255;
 424:	8f ef       	ldi	r24, 0xFF	; 255
 426:	82 83       	std	Z+2, r24	; 0x02
 428:	21 c0       	rjmp	.+66     	; 0x46c <__DATA_REGION_LENGTH__+0x6c>
					}
					else
					{
						led[i].blinkCount -= blinkDecrement;
 42a:	fc 01       	movw	r30, r24
 42c:	ee 0f       	add	r30, r30
 42e:	ff 1f       	adc	r31, r31
 430:	8e 0f       	add	r24, r30
 432:	9f 1f       	adc	r25, r31
 434:	fc 01       	movw	r30, r24
 436:	e9 5b       	subi	r30, 0xB9	; 185
 438:	fe 4f       	sbci	r31, 0xFE	; 254
 43a:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <blinkDecrement>
 43e:	38 1b       	sub	r19, r24
 440:	32 83       	std	Z+2, r19	; 0x02
 442:	14 c0       	rjmp	.+40     	; 0x46c <__DATA_REGION_LENGTH__+0x6c>
				}
				break;
			}
			case LED_SLOW_BLINKING: 
			{
				isLedOn[i] = slowBlink;
 444:	30 91 af 01 	lds	r19, 0x01AF	; 0x8001af <slowBlink>
 448:	e1 e0       	ldi	r30, 0x01	; 1
 44a:	f0 e0       	ldi	r31, 0x00	; 0
 44c:	ec 0f       	add	r30, r28
 44e:	fd 1f       	adc	r31, r29
 450:	e8 0f       	add	r30, r24
 452:	f9 1f       	adc	r31, r25
 454:	30 83       	st	Z, r19
				isLedOn[LED_PWR_GRN] = !slowBlink; // Green led slow blink 180deg phase of red led
 456:	81 e0       	ldi	r24, 0x01	; 1
 458:	83 27       	eor	r24, r19
 45a:	88 87       	std	Y+8, r24	; 0x08
				break;
 45c:	07 c0       	rjmp	.+14     	; 0x46c <__DATA_REGION_LENGTH__+0x6c>
			}	
			default: isLedOn[i] = LED_OFF;
 45e:	e1 e0       	ldi	r30, 0x01	; 1
 460:	f0 e0       	ldi	r31, 0x00	; 0
 462:	ec 0f       	add	r30, r28
 464:	fd 1f       	adc	r31, r29
 466:	e8 0f       	add	r30, r24
 468:	f9 1f       	adc	r31, r25
 46a:	10 82       	st	Z, r1
	else
	{
		blinkCounter++;
	}
	
	for(uint8_t i=0; i<LED_COUNT; i++)
 46c:	2f 5f       	subi	r18, 0xFF	; 255
 46e:	29 30       	cpi	r18, 0x09	; 9
 470:	08 f4       	brcc	.+2      	; 0x474 <__DATA_REGION_LENGTH__+0x74>
 472:	92 cf       	rjmp	.-220    	; 0x398 <SH100HW_MainTask+0x7a>
			default: isLedOn[i] = LED_OFF;
		}
	}
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
 474:	20 91 64 01 	lds	r18, 0x0164	; 0x800164 <RELAY_13_24>
								((uint16_t)RELAY_1_3 << 1)			|
 478:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <RELAY_1_3>
 47c:	90 e0       	ldi	r25, 0x00	; 0
 47e:	88 0f       	add	r24, r24
 480:	99 1f       	adc	r25, r25
			default: isLedOn[i] = LED_OFF;
		}
	}
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
 482:	ac 01       	movw	r20, r24
 484:	42 2b       	or	r20, r18
 486:	9a 01       	movw	r18, r20
								((uint16_t)RELAY_1_3 << 1)			|
								((uint16_t)isLedOn[LED_CH3] << 2)	|
 488:	9b 81       	ldd	r25, Y+3	; 0x03
 48a:	89 2f       	mov	r24, r25
 48c:	90 e0       	ldi	r25, 0x00	; 0
 48e:	88 0f       	add	r24, r24
 490:	99 1f       	adc	r25, r25
 492:	88 0f       	add	r24, r24
 494:	99 1f       	adc	r25, r25
		}
	}
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
								((uint16_t)RELAY_1_3 << 1)			|
 496:	82 2b       	or	r24, r18
 498:	93 2b       	or	r25, r19
								((uint16_t)isLedOn[LED_CH3] << 2)	|
								((uint16_t)isLedOn[LED_CH1] << 3)	|
 49a:	29 81       	ldd	r18, Y+1	; 0x01
 49c:	30 e0       	ldi	r19, 0x00	; 0
 49e:	22 0f       	add	r18, r18
 4a0:	33 1f       	adc	r19, r19
 4a2:	22 0f       	add	r18, r18
 4a4:	33 1f       	adc	r19, r19
 4a6:	22 0f       	add	r18, r18
 4a8:	33 1f       	adc	r19, r19
	}
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
								((uint16_t)RELAY_1_3 << 1)			|
								((uint16_t)isLedOn[LED_CH3] << 2)	|
 4aa:	82 2b       	or	r24, r18
 4ac:	93 2b       	or	r25, r19
								((uint16_t)isLedOn[LED_CH1] << 3)	|
								((uint16_t)isLedOn[LED_CH2] << 4)	|
 4ae:	2a 81       	ldd	r18, Y+2	; 0x02
 4b0:	50 e1       	ldi	r21, 0x10	; 16
 4b2:	25 9f       	mul	r18, r21
 4b4:	90 01       	movw	r18, r0
 4b6:	11 24       	eor	r1, r1
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
								((uint16_t)RELAY_1_3 << 1)			|
								((uint16_t)isLedOn[LED_CH3] << 2)	|
								((uint16_t)isLedOn[LED_CH1] << 3)	|
 4b8:	28 2b       	or	r18, r24
 4ba:	39 2b       	or	r19, r25
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
 4bc:	4c 81       	ldd	r20, Y+4	; 0x04
 4be:	80 e2       	ldi	r24, 0x20	; 32
 4c0:	48 9f       	mul	r20, r24
 4c2:	a0 01       	movw	r20, r0
 4c4:	11 24       	eor	r1, r1
 4c6:	24 2b       	or	r18, r20
 4c8:	35 2b       	or	r19, r21
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
 4ca:	40 91 62 01 	lds	r20, 0x0162	; 0x800162 <RELAY_8_16>
 4ce:	80 e8       	ldi	r24, 0x80	; 128
 4d0:	48 9f       	mul	r20, r24
 4d2:	a0 01       	movw	r20, r0
 4d4:	11 24       	eor	r1, r1
								((uint16_t)RELAY_1_3 << 1)			|
								((uint16_t)isLedOn[LED_CH3] << 2)	|
								((uint16_t)isLedOn[LED_CH1] << 3)	|
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
 4d6:	24 2b       	or	r18, r20
 4d8:	35 2b       	or	r19, r21
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << (8+0))			|
 4da:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <RELAY_2_4>
 4de:	90 e0       	ldi	r25, 0x00	; 0
 4e0:	98 2f       	mov	r25, r24
 4e2:	88 27       	eor	r24, r24
								((uint16_t)isLedOn[LED_CH3] << 2)	|
								((uint16_t)isLedOn[LED_CH1] << 3)	|
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
 4e4:	28 2b       	or	r18, r24
 4e6:	39 2b       	or	r19, r25
								((uint16_t)RELAY_2_4 << (8+0))			|
								((uint16_t)isLedOn[LED_A] << (8+1))	|
 4e8:	8e 81       	ldd	r24, Y+6	; 0x06
 4ea:	90 e0       	ldi	r25, 0x00	; 0
 4ec:	98 2f       	mov	r25, r24
 4ee:	88 27       	eor	r24, r24
 4f0:	99 0f       	add	r25, r25
								((uint16_t)isLedOn[LED_CH1] << 3)	|
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << (8+0))			|
 4f2:	28 2b       	or	r18, r24
 4f4:	39 2b       	or	r19, r25
								((uint16_t)isLedOn[LED_A] << (8+1))	|
								((uint16_t)isLedOn[LED_B] << (8+2))	|
 4f6:	8f 81       	ldd	r24, Y+7	; 0x07
 4f8:	90 e0       	ldi	r25, 0x00	; 0
 4fa:	98 2f       	mov	r25, r24
 4fc:	88 27       	eor	r24, r24
 4fe:	99 0f       	add	r25, r25
 500:	99 0f       	add	r25, r25
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << (8+0))			|
								((uint16_t)isLedOn[LED_A] << (8+1))	|
 502:	28 2b       	or	r18, r24
 504:	39 2b       	or	r19, r25
								((uint16_t)isLedOn[LED_B] << (8+2))	|
								((uint16_t)isLedOn[LED_PWR_GRN] << (8+3))	|
 506:	88 85       	ldd	r24, Y+8	; 0x08
 508:	90 e0       	ldi	r25, 0x00	; 0
 50a:	98 2f       	mov	r25, r24
 50c:	88 27       	eor	r24, r24
 50e:	99 0f       	add	r25, r25
 510:	99 0f       	add	r25, r25
 512:	99 0f       	add	r25, r25
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << (8+0))			|
								((uint16_t)isLedOn[LED_A] << (8+1))	|
								((uint16_t)isLedOn[LED_B] << (8+2))	|
 514:	28 2b       	or	r18, r24
 516:	39 2b       	or	r19, r25
								((uint16_t)isLedOn[LED_PWR_GRN] << (8+3))	|
								((uint16_t)isLedOn[LED_PWR_RED] << (8+4))	|
 518:	99 85       	ldd	r25, Y+9	; 0x09
 51a:	89 2f       	mov	r24, r25
 51c:	90 e0       	ldi	r25, 0x00	; 0
 51e:	98 2f       	mov	r25, r24
 520:	88 27       	eor	r24, r24
 522:	92 95       	swap	r25
 524:	90 7f       	andi	r25, 0xF0	; 240
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << (8+0))			|
								((uint16_t)isLedOn[LED_A] << (8+1))	|
								((uint16_t)isLedOn[LED_B] << (8+2))	|
								((uint16_t)isLedOn[LED_PWR_GRN] << (8+3))	|
 526:	28 2b       	or	r18, r24
 528:	39 2b       	or	r19, r25
								((uint16_t)isLedOn[LED_PWR_RED] << (8+4))	|
								((uint16_t)isLedOn[LED_LOOP] << (8+5))		|
 52a:	4d 81       	ldd	r20, Y+5	; 0x05
 52c:	50 e0       	ldi	r21, 0x00	; 0
 52e:	54 2f       	mov	r21, r20
 530:	44 27       	eor	r20, r20
 532:	52 95       	swap	r21
 534:	55 0f       	add	r21, r21
 536:	50 7e       	andi	r21, 0xE0	; 224
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << (8+0))			|
								((uint16_t)isLedOn[LED_A] << (8+1))	|
								((uint16_t)isLedOn[LED_B] << (8+2))	|
								((uint16_t)isLedOn[LED_PWR_GRN] << (8+3))	|
								((uint16_t)isLedOn[LED_PWR_RED] << (8+4))	|
 538:	24 2b       	or	r18, r20
 53a:	35 2b       	or	r19, r21
								((uint16_t)isLedOn[LED_LOOP] << (8+5))		|
								((uint16_t)RELAY_AB << (8+6)) |
 53c:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <RELAY_AB>
 540:	90 e0       	ldi	r25, 0x00	; 0
 542:	90 e4       	ldi	r25, 0x40	; 64
 544:	89 9f       	mul	r24, r25
 546:	90 2d       	mov	r25, r0
 548:	88 27       	eor	r24, r24
 54a:	11 24       	eor	r1, r1
								(0 << (8+7));

	writeShiftRegs(resultSendWord);
 54c:	82 2b       	or	r24, r18
 54e:	93 2b       	or	r25, r19
 550:	51 d8       	rcall	.-3934   	; 0xfffff5f4 <__eeprom_end+0xff7ef5f4>
 552:	29 96       	adiw	r28, 0x09	; 9
 554:	0f b6       	in	r0, 0x3f	; 63
 556:	f8 94       	cli
 558:	de bf       	out	0x3e, r29	; 62
 55a:	0f be       	out	0x3f, r0	; 63
 55c:	cd bf       	out	0x3d, r28	; 61
 55e:	df 91       	pop	r29
 560:	cf 91       	pop	r28
 562:	08 95       	ret

Disassembly of section .text.UART_init:

00001a98 <UART_init>:
	// Rx INT: On
	// Tx INT: On
	// Receiver: On
	// Transmitter: On
	
	UCSR0B = (1<<RXCIE0) | (1<<TXCIE0) | (1<<RXEN0) | (1<<TXEN0); //UCSR1B=0x98;
    1a98:	88 ed       	ldi	r24, 0xD8	; 216
    1a9a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fe0c1>
	
	// 8 Data, 1 Stop, No Parity
	UCSR0C= (1<<UCSZ01) | (1<<UCSZ00); 
    1a9e:	86 e0       	ldi	r24, 0x06	; 6
    1aa0:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fe0c2>
	
	// USART0 Mode: Asynchronous
	// USART Baud Rate: Fosc/320 = Fosc/16(UBRR+1)
	UBRR0H=0;
    1aa4:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fe0c5>
	UBRR0L=19;
    1aa8:	83 e1       	ldi	r24, 0x13	; 19
    1aaa:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fe0c4>
    1aae:	08 95       	ret

Disassembly of section .text.__vector_18:

000012aa <__vector_18>:
uint8_t rx_wr_index, rx_rd_index, rx_counter;

bool rx_buffer_overflow;

ISR(USART_RX_vect)
{
    12aa:	1f 92       	push	r1
    12ac:	1f b6       	in	r1, 0x3f	; 63
    12ae:	1f 92       	push	r1
    12b0:	11 24       	eor	r1, r1
    12b2:	8f 93       	push	r24
    12b4:	9f 93       	push	r25
    12b6:	ef 93       	push	r30
    12b8:	ff 93       	push	r31
	uint8_t status, data;
	status = UCSR0A;
    12ba:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fe0c0>
	data = UDR0;
    12be:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fe0c6>
	
	if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
    12c2:	8c 71       	andi	r24, 0x1C	; 28
    12c4:	d1 f4       	brne	.+52     	; 0x12fa <__vector_18+0x50>
	{
		rx_buffer0[rx_wr_index++] = data;
    12c6:	e0 91 66 01 	lds	r30, 0x0166	; 0x800166 <rx_wr_index>
    12ca:	81 e0       	ldi	r24, 0x01	; 1
    12cc:	8e 0f       	add	r24, r30
    12ce:	80 93 66 01 	sts	0x0166, r24	; 0x800166 <rx_wr_index>
    12d2:	f0 e0       	ldi	r31, 0x00	; 0
    12d4:	ee 58       	subi	r30, 0x8E	; 142
    12d6:	fe 4f       	sbci	r31, 0xFE	; 254
    12d8:	90 83       	st	Z, r25
		
		if (rx_wr_index == RX_BUFFER_SIZE) rx_wr_index=0;
    12da:	80 31       	cpi	r24, 0x10	; 16
    12dc:	11 f4       	brne	.+4      	; 0x12e2 <__vector_18+0x38>
    12de:	10 92 66 01 	sts	0x0166, r1	; 0x800166 <rx_wr_index>
		
		if (++rx_counter == RX_BUFFER_SIZE)
    12e2:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <rx_counter>
    12e6:	8f 5f       	subi	r24, 0xFF	; 255
    12e8:	80 93 71 01 	sts	0x0171, r24	; 0x800171 <rx_counter>
    12ec:	80 31       	cpi	r24, 0x10	; 16
    12ee:	29 f4       	brne	.+10     	; 0x12fa <__vector_18+0x50>
		{
			rx_counter=0;
    12f0:	10 92 71 01 	sts	0x0171, r1	; 0x800171 <rx_counter>
			rx_buffer_overflow=1;
    12f4:	81 e0       	ldi	r24, 0x01	; 1
    12f6:	80 93 67 01 	sts	0x0167, r24	; 0x800167 <rx_buffer_overflow>
		}
	}
}
    12fa:	ff 91       	pop	r31
    12fc:	ef 91       	pop	r30
    12fe:	9f 91       	pop	r25
    1300:	8f 91       	pop	r24
    1302:	1f 90       	pop	r1
    1304:	1f be       	out	0x3f, r1	; 63
    1306:	1f 90       	pop	r1
    1308:	18 95       	reti

Disassembly of section .text.UART_PopWord:

00001760 <UART_PopWord>:

uint8_t UART_PopWord()
{
	uint8_t data;
	
	while (rx_counter == 0); // blocking
    1760:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <rx_counter>
    1764:	88 23       	and	r24, r24
    1766:	e1 f3       	breq	.-8      	; 0x1760 <UART_PopWord>
	
	data = rx_buffer0[rx_rd_index++];
    1768:	e0 91 82 01 	lds	r30, 0x0182	; 0x800182 <rx_rd_index>
    176c:	91 e0       	ldi	r25, 0x01	; 1
    176e:	9e 0f       	add	r25, r30
    1770:	90 93 82 01 	sts	0x0182, r25	; 0x800182 <rx_rd_index>
    1774:	f0 e0       	ldi	r31, 0x00	; 0
    1776:	ee 58       	subi	r30, 0x8E	; 142
    1778:	fe 4f       	sbci	r31, 0xFE	; 254
    177a:	80 81       	ld	r24, Z
	
	#if RX_BUFFER_SIZE != 256
		if (rx_rd_index == RX_BUFFER_SIZE) rx_rd_index = 0;
    177c:	90 31       	cpi	r25, 0x10	; 16
    177e:	11 f4       	brne	.+4      	; 0x1784 <UART_PopWord+0x24>
    1780:	10 92 82 01 	sts	0x0182, r1	; 0x800182 <rx_rd_index>
	#endif
	
	cpu_irq_disable();
    1784:	f8 94       	cli
	--rx_counter;
    1786:	90 91 71 01 	lds	r25, 0x0171	; 0x800171 <rx_counter>
    178a:	91 50       	subi	r25, 0x01	; 1
    178c:	90 93 71 01 	sts	0x0171, r25	; 0x800171 <rx_counter>
	cpu_irq_enable();
    1790:	78 94       	sei
	return data;
}
    1792:	08 95       	ret

Disassembly of section .text.UART_RxBufferNotEmpty:

00001b4e <UART_RxBufferNotEmpty>:

bool UART_RxBufferNotEmpty()
{
	return (bool)rx_counter;
    1b4e:	81 e0       	ldi	r24, 0x01	; 1
    1b50:	90 91 71 01 	lds	r25, 0x0171	; 0x800171 <rx_counter>
    1b54:	91 11       	cpse	r25, r1
    1b56:	01 c0       	rjmp	.+2      	; 0x1b5a <UART_RxBufferNotEmpty+0xc>
    1b58:	80 e0       	ldi	r24, 0x00	; 0
}
    1b5a:	08 95       	ret

Disassembly of section .text.__vector_20:

00001400 <__vector_20>:
uint8_t tx_buffer[TX_BUFFER_SIZE];
uint8_t tx_wr_index, tx_rd_index, tx_counter;

// USART Transmitter interrupt service routine
ISR(USART_TX_vect)
{
    1400:	1f 92       	push	r1
    1402:	1f b6       	in	r1, 0x3f	; 63
    1404:	1f 92       	push	r1
    1406:	11 24       	eor	r1, r1
    1408:	8f 93       	push	r24
    140a:	ef 93       	push	r30
    140c:	ff 93       	push	r31
	if (tx_counter)
    140e:	80 91 68 01 	lds	r24, 0x0168	; 0x800168 <tx_counter>
    1412:	88 23       	and	r24, r24
    1414:	a9 f0       	breq	.+42     	; 0x1440 <__vector_20+0x40>
	{
		--tx_counter;
    1416:	81 50       	subi	r24, 0x01	; 1
    1418:	80 93 68 01 	sts	0x0168, r24	; 0x800168 <tx_counter>
		UDR0=tx_buffer[tx_rd_index++];
    141c:	e0 91 83 01 	lds	r30, 0x0183	; 0x800183 <tx_rd_index>
    1420:	81 e0       	ldi	r24, 0x01	; 1
    1422:	8e 0f       	add	r24, r30
    1424:	80 93 83 01 	sts	0x0183, r24	; 0x800183 <tx_rd_index>
    1428:	f0 e0       	ldi	r31, 0x00	; 0
    142a:	e7 59       	subi	r30, 0x97	; 151
    142c:	fe 4f       	sbci	r31, 0xFE	; 254
    142e:	80 81       	ld	r24, Z
    1430:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fe0c6>
		
		#if TX_BUFFER_SIZE != 256
			if (tx_rd_index == TX_BUFFER_SIZE) tx_rd_index = 0;
    1434:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <tx_rd_index>
    1438:	88 30       	cpi	r24, 0x08	; 8
    143a:	11 f4       	brne	.+4      	; 0x1440 <__vector_20+0x40>
    143c:	10 92 83 01 	sts	0x0183, r1	; 0x800183 <tx_rd_index>
		#endif
	}
}
    1440:	ff 91       	pop	r31
    1442:	ef 91       	pop	r30
    1444:	8f 91       	pop	r24
    1446:	1f 90       	pop	r1
    1448:	1f be       	out	0x3f, r1	; 63
    144a:	1f 90       	pop	r1
    144c:	18 95       	reti

Disassembly of section .text.UART_PushWord:

0000152a <UART_PushWord>:

// Write a character to the USART Transmitter buffer
void UART_PushWord(uint8_t c)
{	
	while (tx_counter == TX_BUFFER_SIZE);
    152a:	90 91 68 01 	lds	r25, 0x0168	; 0x800168 <tx_counter>
    152e:	98 30       	cpi	r25, 0x08	; 8
    1530:	e1 f3       	breq	.-8      	; 0x152a <UART_PushWord>
	
	cpu_irq_disable();
    1532:	f8 94       	cli
	
	if (tx_counter || ((UCSR0A & DATA_REGISTER_EMPTY)==0))
    1534:	90 91 68 01 	lds	r25, 0x0168	; 0x800168 <tx_counter>
    1538:	91 11       	cpse	r25, r1
    153a:	04 c0       	rjmp	.+8      	; 0x1544 <UART_PushWord+0x1a>
    153c:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fe0c0>
    1540:	25 fd       	sbrc	r18, 5
    1542:	12 c0       	rjmp	.+36     	; 0x1568 <UART_PushWord+0x3e>
	{
		tx_buffer[tx_wr_index++] = c;
    1544:	e0 91 84 01 	lds	r30, 0x0184	; 0x800184 <tx_wr_index>
    1548:	21 e0       	ldi	r18, 0x01	; 1
    154a:	2e 0f       	add	r18, r30
    154c:	20 93 84 01 	sts	0x0184, r18	; 0x800184 <tx_wr_index>
    1550:	f0 e0       	ldi	r31, 0x00	; 0
    1552:	e7 59       	subi	r30, 0x97	; 151
    1554:	fe 4f       	sbci	r31, 0xFE	; 254
    1556:	80 83       	st	Z, r24
		
		#if TX_BUFFER_SIZE0 != 256
			if (tx_wr_index == TX_BUFFER_SIZE) tx_wr_index=0;
    1558:	28 30       	cpi	r18, 0x08	; 8
    155a:	11 f4       	brne	.+4      	; 0x1560 <UART_PushWord+0x36>
    155c:	10 92 84 01 	sts	0x0184, r1	; 0x800184 <tx_wr_index>
		#endif
		
		++tx_counter;
    1560:	9f 5f       	subi	r25, 0xFF	; 255
    1562:	90 93 68 01 	sts	0x0168, r25	; 0x800168 <tx_counter>
    1566:	02 c0       	rjmp	.+4      	; 0x156c <UART_PushWord+0x42>
	}
	else UDR0=c;
    1568:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fe0c6>
	
	cpu_irq_enable();
    156c:	78 94       	sei
    156e:	08 95       	ret

Disassembly of section .text:

00000f28 <__floatunsisf>:
 f28:	e8 94       	clt
 f2a:	09 c0       	rjmp	.+18     	; 0xf3e <__floatsisf+0x12>

00000f2c <__floatsisf>:
 f2c:	97 fb       	bst	r25, 7
 f2e:	3e f4       	brtc	.+14     	; 0xf3e <__floatsisf+0x12>
 f30:	90 95       	com	r25
 f32:	80 95       	com	r24
 f34:	70 95       	com	r23
 f36:	61 95       	neg	r22
 f38:	7f 4f       	sbci	r23, 0xFF	; 255
 f3a:	8f 4f       	sbci	r24, 0xFF	; 255
 f3c:	9f 4f       	sbci	r25, 0xFF	; 255
 f3e:	99 23       	and	r25, r25
 f40:	a9 f0       	breq	.+42     	; 0xf6c <__floatsisf+0x40>
 f42:	f9 2f       	mov	r31, r25
 f44:	96 e9       	ldi	r25, 0x96	; 150
 f46:	bb 27       	eor	r27, r27
 f48:	93 95       	inc	r25
 f4a:	f6 95       	lsr	r31
 f4c:	87 95       	ror	r24
 f4e:	77 95       	ror	r23
 f50:	67 95       	ror	r22
 f52:	b7 95       	ror	r27
 f54:	f1 11       	cpse	r31, r1
 f56:	f8 cf       	rjmp	.-16     	; 0xf48 <__floatsisf+0x1c>
 f58:	fa f4       	brpl	.+62     	; 0xf98 <__floatsisf+0x6c>
 f5a:	bb 0f       	add	r27, r27
 f5c:	11 f4       	brne	.+4      	; 0xf62 <__floatsisf+0x36>
 f5e:	60 ff       	sbrs	r22, 0
 f60:	1b c0       	rjmp	.+54     	; 0xf98 <__floatsisf+0x6c>
 f62:	6f 5f       	subi	r22, 0xFF	; 255
 f64:	7f 4f       	sbci	r23, 0xFF	; 255
 f66:	8f 4f       	sbci	r24, 0xFF	; 255
 f68:	9f 4f       	sbci	r25, 0xFF	; 255
 f6a:	16 c0       	rjmp	.+44     	; 0xf98 <__floatsisf+0x6c>
 f6c:	88 23       	and	r24, r24
 f6e:	11 f0       	breq	.+4      	; 0xf74 <__floatsisf+0x48>
 f70:	96 e9       	ldi	r25, 0x96	; 150
 f72:	11 c0       	rjmp	.+34     	; 0xf96 <__floatsisf+0x6a>
 f74:	77 23       	and	r23, r23
 f76:	21 f0       	breq	.+8      	; 0xf80 <__floatsisf+0x54>
 f78:	9e e8       	ldi	r25, 0x8E	; 142
 f7a:	87 2f       	mov	r24, r23
 f7c:	76 2f       	mov	r23, r22
 f7e:	05 c0       	rjmp	.+10     	; 0xf8a <__floatsisf+0x5e>
 f80:	66 23       	and	r22, r22
 f82:	71 f0       	breq	.+28     	; 0xfa0 <__floatsisf+0x74>
 f84:	96 e8       	ldi	r25, 0x86	; 134
 f86:	86 2f       	mov	r24, r22
 f88:	70 e0       	ldi	r23, 0x00	; 0
 f8a:	60 e0       	ldi	r22, 0x00	; 0
 f8c:	2a f0       	brmi	.+10     	; 0xf98 <__floatsisf+0x6c>
 f8e:	9a 95       	dec	r25
 f90:	66 0f       	add	r22, r22
 f92:	77 1f       	adc	r23, r23
 f94:	88 1f       	adc	r24, r24
 f96:	da f7       	brpl	.-10     	; 0xf8e <__floatsisf+0x62>
 f98:	88 0f       	add	r24, r24
 f9a:	96 95       	lsr	r25
 f9c:	87 95       	ror	r24
 f9e:	97 f9       	bld	r25, 7
 fa0:	08 95       	ret

Disassembly of section .text:

00001bb6 <__gesf2>:
    1bb6:	95 dc       	rcall	.-1750   	; 0x14e2 <__fp_cmp>
    1bb8:	08 f4       	brcc	.+2      	; 0x1bbc <__gesf2+0x6>
    1bba:	8f ef       	ldi	r24, 0xFF	; 255
    1bbc:	08 95       	ret

Disassembly of section .text:

000014e2 <__fp_cmp>:
    14e2:	99 0f       	add	r25, r25
    14e4:	00 08       	sbc	r0, r0
    14e6:	55 0f       	add	r21, r21
    14e8:	aa 0b       	sbc	r26, r26
    14ea:	e0 e8       	ldi	r30, 0x80	; 128
    14ec:	fe ef       	ldi	r31, 0xFE	; 254
    14ee:	16 16       	cp	r1, r22
    14f0:	17 06       	cpc	r1, r23
    14f2:	e8 07       	cpc	r30, r24
    14f4:	f9 07       	cpc	r31, r25
    14f6:	c0 f0       	brcs	.+48     	; 0x1528 <__fp_cmp+0x46>
    14f8:	12 16       	cp	r1, r18
    14fa:	13 06       	cpc	r1, r19
    14fc:	e4 07       	cpc	r30, r20
    14fe:	f5 07       	cpc	r31, r21
    1500:	98 f0       	brcs	.+38     	; 0x1528 <__fp_cmp+0x46>
    1502:	62 1b       	sub	r22, r18
    1504:	73 0b       	sbc	r23, r19
    1506:	84 0b       	sbc	r24, r20
    1508:	95 0b       	sbc	r25, r21
    150a:	39 f4       	brne	.+14     	; 0x151a <__fp_cmp+0x38>
    150c:	0a 26       	eor	r0, r26
    150e:	61 f0       	breq	.+24     	; 0x1528 <__fp_cmp+0x46>
    1510:	23 2b       	or	r18, r19
    1512:	24 2b       	or	r18, r20
    1514:	25 2b       	or	r18, r21
    1516:	21 f4       	brne	.+8      	; 0x1520 <__fp_cmp+0x3e>
    1518:	08 95       	ret
    151a:	0a 26       	eor	r0, r26
    151c:	09 f4       	brne	.+2      	; 0x1520 <__fp_cmp+0x3e>
    151e:	a1 40       	sbci	r26, 0x01	; 1
    1520:	a6 95       	lsr	r26
    1522:	8f ef       	ldi	r24, 0xFF	; 255
    1524:	81 1d       	adc	r24, r1
    1526:	81 1d       	adc	r24, r1
    1528:	08 95       	ret

Disassembly of section .text.libgcc:

00001a36 <__movmemx_qi>:
    1a36:	99 27       	eor	r25, r25

00001a38 <__movmemx_hi>:
    1a38:	77 fd       	sbrc	r23, 7
    1a3a:	05 c0       	rjmp	.+10     	; 0x1a46 <__movmemx_hi+0xe>
    1a3c:	05 90       	lpm	r0, Z+
    1a3e:	0d 92       	st	X+, r0
    1a40:	01 97       	sbiw	r24, 0x01	; 1
    1a42:	e1 f7       	brne	.-8      	; 0x1a3c <__movmemx_hi+0x4>
    1a44:	08 95       	ret
    1a46:	01 90       	ld	r0, Z+
    1a48:	0d 92       	st	X+, r0
    1a4a:	01 97       	sbiw	r24, 0x01	; 1
    1a4c:	e1 f7       	brne	.-8      	; 0x1a46 <__movmemx_hi+0xe>
    1a4e:	08 95       	ret

Disassembly of section .text.__dummy_fini:

00001bfa <_fini>:
    1bfa:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

00001bfc <__funcs_on_exit>:
    1bfc:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

00001bfe <__simulator_exit>:
    1bfe:	08 95       	ret

Disassembly of section .text.exit:

00001b5c <exit>:
    1b5c:	ec 01       	movw	r28, r24
    1b5e:	4e d0       	rcall	.+156    	; 0x1bfc <__funcs_on_exit>
    1b60:	4c d0       	rcall	.+152    	; 0x1bfa <_fini>
    1b62:	ce 01       	movw	r24, r28
    1b64:	4c d0       	rcall	.+152    	; 0x1bfe <__simulator_exit>
    1b66:	ce 01       	movw	r24, r28
    1b68:	4b d0       	rcall	.+150    	; 0x1c00 <_Exit>

Disassembly of section .text._Exit:

00001c00 <_Exit>:
    1c00:	63 d2       	rcall	.+1222   	; 0x20c8 <__TEXT_REGION_LENGTH__+0xc8>

Disassembly of section .text.avrlibc:

0000197a <eeprom_read_block>:
    197a:	ba 01       	movw	r22, r20
    197c:	a9 01       	movw	r20, r18
    197e:	dc 01       	movw	r26, r24
    1980:	cb 01       	movw	r24, r22

00001982 <eeprom_read_blraw>:
    1982:	fc 01       	movw	r30, r24
    1984:	f9 99       	sbic	0x1f, 1	; 31
    1986:	fe cf       	rjmp	.-4      	; 0x1984 <eeprom_read_blraw+0x2>
    1988:	06 c0       	rjmp	.+12     	; 0x1996 <eeprom_read_blraw+0x14>
    198a:	f2 bd       	out	0x22, r31	; 34
    198c:	e1 bd       	out	0x21, r30	; 33
    198e:	f8 9a       	sbi	0x1f, 0	; 31
    1990:	31 96       	adiw	r30, 0x01	; 1
    1992:	00 b4       	in	r0, 0x20	; 32
    1994:	0d 92       	st	X+, r0
    1996:	41 50       	subi	r20, 0x01	; 1
    1998:	50 40       	sbci	r21, 0x00	; 0
    199a:	b8 f7       	brcc	.-18     	; 0x198a <eeprom_read_blraw+0x8>
    199c:	08 95       	ret

Disassembly of section .text.avrlibc:

00001b02 <eeprom_read_byte>:
    1b02:	cb 01       	movw	r24, r22
    1b04:	f9 99       	sbic	0x1f, 1	; 31
    1b06:	fe cf       	rjmp	.-4      	; 0x1b04 <eeprom_read_byte+0x2>
    1b08:	92 bd       	out	0x22, r25	; 34
    1b0a:	81 bd       	out	0x21, r24	; 33
    1b0c:	f8 9a       	sbi	0x1f, 0	; 31
    1b0e:	99 27       	eor	r25, r25
    1b10:	80 b5       	in	r24, 0x20	; 32
    1b12:	08 95       	ret

Disassembly of section .text.avrlibc:

00001b8e <eeprom_read_word>:
    1b8e:	cb 01       	movw	r24, r22
    1b90:	a8 e1       	ldi	r26, 0x18	; 24
    1b92:	b0 e0       	ldi	r27, 0x00	; 0
    1b94:	42 e0       	ldi	r20, 0x02	; 2
    1b96:	50 e0       	ldi	r21, 0x00	; 0
    1b98:	f4 ce       	rjmp	.-536    	; 0x1982 <eeprom_read_blraw>

Disassembly of section .text.avrlibc:

000017c6 <eeprom_write_block>:
    17c6:	cf 92       	push	r12
    17c8:	df 92       	push	r13
    17ca:	ef 92       	push	r14
    17cc:	6b 01       	movw	r12, r22
    17ce:	e8 2e       	mov	r14, r24
    17d0:	ca 01       	movw	r24, r20
    17d2:	42 2f       	mov	r20, r18
    17d4:	73 2f       	mov	r23, r19
    17d6:	09 c0       	rjmp	.+18     	; 0x17ea <eeprom_write_block+0x24>
    17d8:	f6 01       	movw	r30, r12
    17da:	5e 2d       	mov	r21, r14
    17dc:	e3 d1       	rcall	.+966    	; 0x1ba4 <__xload_1>
    17de:	26 2f       	mov	r18, r22
    17e0:	1d d1       	rcall	.+570    	; 0x1a1c <eeprom_write_r18>
    17e2:	3f ef       	ldi	r19, 0xFF	; 255
    17e4:	c3 1a       	sub	r12, r19
    17e6:	d3 0a       	sbc	r13, r19
    17e8:	e3 0a       	sbc	r14, r19
    17ea:	41 50       	subi	r20, 0x01	; 1
    17ec:	70 40       	sbci	r23, 0x00	; 0
    17ee:	a0 f7       	brcc	.-24     	; 0x17d8 <eeprom_write_block+0x12>
    17f0:	ef 90       	pop	r14
    17f2:	df 90       	pop	r13
    17f4:	cf 90       	pop	r12
    17f6:	08 95       	ret

Disassembly of section .text.avrlibc:

00001a1a <eeprom_write_byte>:
    1a1a:	26 2f       	mov	r18, r22

00001a1c <eeprom_write_r18>:
    1a1c:	f9 99       	sbic	0x1f, 1	; 31
    1a1e:	fe cf       	rjmp	.-4      	; 0x1a1c <eeprom_write_r18>
    1a20:	1f ba       	out	0x1f, r1	; 31
    1a22:	92 bd       	out	0x22, r25	; 34
    1a24:	81 bd       	out	0x21, r24	; 33
    1a26:	20 bd       	out	0x20, r18	; 32
    1a28:	0f b6       	in	r0, 0x3f	; 63
    1a2a:	f8 94       	cli
    1a2c:	fa 9a       	sbi	0x1f, 2	; 31
    1a2e:	f9 9a       	sbi	0x1f, 1	; 31
    1a30:	0f be       	out	0x3f, r0	; 63
    1a32:	01 96       	adiw	r24, 0x01	; 1
    1a34:	08 95       	ret

Disassembly of section .text.avrlibc:

00001bee <eeprom_write_word>:
    1bee:	15 df       	rcall	.-470    	; 0x1a1a <eeprom_write_byte>
    1bf0:	27 2f       	mov	r18, r23
    1bf2:	14 cf       	rjmp	.-472    	; 0x1a1c <eeprom_write_r18>

Disassembly of section .text.libgcc:

00001ba4 <__xload_1>:
    1ba4:	57 fd       	sbrc	r21, 7
    1ba6:	60 81       	ld	r22, Z
    1ba8:	57 ff       	sbrs	r21, 7
    1baa:	64 91       	lpm	r22, Z
    1bac:	08 95       	ret
