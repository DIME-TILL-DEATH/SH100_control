
SH100_control.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  000014f9  2**0
                  ALLOC, LOAD, DATA
  1 .text         000001cc  00000000  00000000  00000154  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000086  00800100  00800100  000014f9  2**0
                  ALLOC
  3 .comment      0000002f  00000000  00000000  000014f9  2**0
                  CONTENTS, READONLY
  4 .stack.descriptors.hdr 0000007e  00000000  00000000  00001528  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00000328  00000000  00000000  000015a8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000057b8  00000000  00000000  000018d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000104c  00000000  00000000  00007088  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001a6d  00000000  00000000  000080d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000588  00000000  00000000  00009b44  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005ec  00000000  00000000  0000a0cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000014e5  00000000  00000000  0000a6b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000210  00000000  00000000  0000bb9d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .text         00000002  0000137e  0000137e  000014d2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000bdb0  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .text.main    00000022  00001190  00001190  000012e4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.__vector_16 0000017e  0000050e  0000050e  00000662  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .bss.leaveDefSettings_cnt 00000001  008001a8  008001a8  000014f9  2**0
                  ALLOC
 18 .bss.swProgrammingMode_cnt 00000001  008001a9  008001a9  000014f9  2**0
                  ALLOC
 19 .text.MIDI_IsStatusWord 00000008  00001342  00001342  00001496  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.MIDI_IsSysRealTime 0000000c  000012f2  000012f2  00001446  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .text.MIDI_GetStatusType 00000040  00000ebc  00000ebc  00001010  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.isEqualCommands 00000014  0000128a  0000128a  000013de  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.loadCommSetFromMemory 0000007a  00000a02  00000a02  00000b56  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.setMidiLeds 00000052  00000c66  00000c66  00000dba  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text.MIDICTRL_Init 0000002a  000010aa  000010aa  000011fe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .text.MIDICTRL_MidiMode 00000006  0000134a  0000134a  0000149e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.MIDICTRL_SetProgrammingButton 0000002e  0000107c  0000107c  000011d0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .text.MIDICTRL_SwitchMode 00000042  00000e7a  00000e7a  00000fce  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .text.MIDICTRL_SetMidiChannel 00000006  00001350  00001350  000014a4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .text.MIDICTRL_OmniModeEn 00000006  00001356  00001356  000014aa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.MIDICTRL_MuteCommEn 00000006  0000135c  0000135c  000014b0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.programmBtn 0000004c  00000d54  00000d54  00000ea8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.MIDICTRL_StoreUserCommands 00000036  00000faa  00000faa  000010fe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.MIDICTRL_DiscardCommands 00000014  0000129e  0000129e  000013f2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .text.indicateMidiError 00000024  00001148  00001148  0000129c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .text.MIDICTRL_HandleCommand 0000014e  000007e2  000007e2  00000936  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .text.__vector_13 00000054  00000c12  00000c12  00000d66  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 38 .data.defaultCommands 00000018  00800186  00001388  000014dc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 39 .progmemx.data.muteCommand 00000004  000001cc  000001cc  00000320  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 40 .bss.channelNum 00000001  008001aa  008001aa  000014f9  2**0
                  ALLOC
 41 .bss.muteCommandEnabled 00000001  008001ab  008001ab  000014f9  2**0
                  ALLOC
 42 .bss.omniModeEnabled 00000001  008001ac  008001ac  000014f9  2**0
                  ALLOC
 43 .text.handleRealTimeStatus 00000004  0000137a  0000137a  000014ce  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .text.MIDI_ParserTask 00000156  0000068c  0000068c  000007e0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .text.MIDI_SetRetranslateState 00000006  00001362  00001362  000014b6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .bss.state    00000001  008001ad  008001ad  000014f9  2**0
                  ALLOC
 47 .data.retranslate 00000001  008001ae  000013a4  000014f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 48 .text.setChannelLeds 00000022  000011b2  000011b2  00001306  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .text.SH100CTRL_SetAmpLeds 00000026  000010fc  000010fc  00001250  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .text.SH100CTRL_SwChannel 0000000a  0000132e  0000132e  00001482  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .text.SH100CTRL_SetLoop 00000018  00001212  00001212  00001366  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .text.SH100CTRL_SetAB 00000022  000011d4  000011d4  00001328  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .text.SH100CTRL_SwLoop 0000000c  000012fe  000012fe  00001452  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .text.SH100CTRL_SwAB 0000000c  0000130a  0000130a  0000145e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 55 .text.SH100CTRL_MuteAmp 00000006  00001368  00001368  000014bc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 56 .text.SH100CTRL_UnmuteAmp 0000000c  00001316  00001316  0000146a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 57 .text.SH100CTRL_SetAmpState 0000003e  00000efc  00000efc  00001050  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .text.SH100CTRL_Init 00000062  00000b50  00000b50  00000ca4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .text.SH100CTRL_CheckOutputJacks 0000004a  00000da0  00000da0  00000ef4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .text.SH100HW_Init 00000066  00000aea  00000aea  00000c3e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .text.SH100HW_GetButtonsState 00000012  000012b2  000012b2  00001406  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 62 .text.SH100HW_SwitchCh 0000004e  00000cb8  00000cb8  00000e0c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .text.SH100HW_LoopEn 00000018  0000122a  0000122a  0000137e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 64 .text.SH100HW_SwitchAB 00000006  0000136e  0000136e  000014c2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 65 .text.SH100HW_SetNewLedState 00000038  00000f3a  00000f3a  0000108e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 66 .text.SH100HW_SetPreviousLedState 00000028  000010d4  000010d4  00001228  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .text.SH100HW_GetOutputJacks 00000018  00001242  00001242  00001396  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .text.SH100HW_SetPAState 00000026  00001122  00001122  00001276  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .text.readButtonsState 00000186  00000388  00000388  000004dc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .text.writeShiftRegs 0000004a  00000dea  00000dea  00000f3e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 71 .text.SH100HW_MainTask 000001b8  000001d0  000001d0  00000324  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 72 .bss.fastBlink 00000001  008001af  008001af  000014f9  2**0
                  ALLOC
 73 .bss.slowBlink 00000001  008001b0  008001b0  000014f9  2**0
                  ALLOC
 74 .bss.blinkCounter 00000001  008001b1  008001b1  000014f9  2**0
                  ALLOC
 75 .text.UART_init 00000018  0000125a  0000125a  000013ae  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 76 .text.__vector_18 00000060  00000bb2  00000bb2  00000d06  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 77 .text.UART_PopWord 00000034  00001016  00001016  0000116a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 78 .text.UART_RxBufferNotEmpty 0000000e  000012d6  000012d6  0000142a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 79 .text.__vector_20 0000004e  00000d06  00000d06  00000e5a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 80 .text.UART_PushWord 00000046  00000e34  00000e34  00000f88  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 81 .text.libgcc  00000018  00001272  00001272  000013c6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 82 .text.__dummy_fini 00000002  00001380  00001380  000014d4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 83 .text.__dummy_funcs_on_exit 00000002  00001382  00001382  000014d6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 84 .text.__dummy_simulator_exit 00000002  00001384  00001384  000014d8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 85 .text.exit    0000000e  000012e4  000012e4  00001438  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 86 .text.__simple_malloc 000000d2  00000930  00000930  00000a84  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 87 .bss.end.1483 00000002  0080019e  0080019e  000014f9  2**0
                  ALLOC
 88 .bss.cur.1482 00000002  008001a0  008001a0  000014f9  2**0
                  ALLOC
 89 .text._Exit   00000002  00001386  00001386  000014da  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 90 .text.__expand_heap 0000006e  00000a7c  00000a7c  00000bd0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 91 .bss.__brkval 00000002  008001a2  008001a2  000014f9  2**0
                  ALLOC
 92 .data.__malloc_heap_end 00000002  008001a4  000013a0  000014f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 93 .data.__malloc_heap_start 00000002  008001a6  000013a2  000014f6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 94 .text.avrlibc 00000024  0000116c  0000116c  000012c0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 95 .text.avrlibc 00000012  000012c4  000012c4  00001418  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 96 .text.avrlibc 0000000c  00001322  00001322  00001476  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 97 .text.avrlibc 00000032  0000104a  0000104a  0000119e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 98 .text.avrlibc 0000001c  000011f6  000011f6  0000134a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 99 .text.avrlibc 00000006  00001374  00001374  000014c8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
100 .text.libgcc.prologue 00000038  00000f72  00000f72  000010c6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
101 .text.libgcc.prologue 00000036  00000fe0  00000fe0  00001134  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
102 .text.libgcc  0000000a  00001338  00001338  0000148c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	bd c0       	rjmp	.+378    	; 0x17c <__ctors_end>
   2:	bd c9       	rjmp	.-3206   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
   4:	bc c9       	rjmp	.-3208   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
   6:	bb c9       	rjmp	.-3210   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
   8:	ba c9       	rjmp	.-3212   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
   a:	b9 c9       	rjmp	.-3214   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
   c:	b8 c9       	rjmp	.-3216   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
   e:	b7 c9       	rjmp	.-3218   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  10:	b6 c9       	rjmp	.-3220   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  12:	b5 c9       	rjmp	.-3222   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  14:	b4 c9       	rjmp	.-3224   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  16:	b3 c9       	rjmp	.-3226   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  18:	b2 c9       	rjmp	.-3228   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  1a:	fb c5       	rjmp	.+3062   	; 0xc12 <__vector_13>
  1c:	b0 c9       	rjmp	.-3232   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  1e:	af c9       	rjmp	.-3234   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  20:	76 c2       	rjmp	.+1260   	; 0x50e <__vector_16>
  22:	ad c9       	rjmp	.-3238   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  24:	c6 c5       	rjmp	.+2956   	; 0xbb2 <__vector_18>
  26:	ab c9       	rjmp	.-3242   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  28:	6e c6       	rjmp	.+3292   	; 0xd06 <__vector_20>
  2a:	a9 c9       	rjmp	.-3246   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  2c:	a8 c9       	rjmp	.-3248   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  2e:	a7 c9       	rjmp	.-3250   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  30:	a6 c9       	rjmp	.-3252   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  32:	a5 c9       	rjmp	.-3254   	; 0xfffff37e <__eeprom_end+0xff7ef37e>
  34:	4d c7       	rjmp	.+3738   	; 0xed0 <MIDI_GetStatusType+0x14>
  36:	5e c7       	rjmp	.+3772   	; 0xef4 <MIDI_GetStatusType+0x38>
  38:	5d c7       	rjmp	.+3770   	; 0xef4 <MIDI_GetStatusType+0x38>
  3a:	5c c7       	rjmp	.+3768   	; 0xef4 <MIDI_GetStatusType+0x38>
  3c:	5b c7       	rjmp	.+3766   	; 0xef4 <MIDI_GetStatusType+0x38>
  3e:	5a c7       	rjmp	.+3764   	; 0xef4 <MIDI_GetStatusType+0x38>
  40:	59 c7       	rjmp	.+3762   	; 0xef4 <MIDI_GetStatusType+0x38>
  42:	58 c7       	rjmp	.+3760   	; 0xef4 <MIDI_GetStatusType+0x38>
  44:	57 c7       	rjmp	.+3758   	; 0xef4 <MIDI_GetStatusType+0x38>
  46:	56 c7       	rjmp	.+3756   	; 0xef4 <MIDI_GetStatusType+0x38>
  48:	55 c7       	rjmp	.+3754   	; 0xef4 <MIDI_GetStatusType+0x38>
  4a:	54 c7       	rjmp	.+3752   	; 0xef4 <MIDI_GetStatusType+0x38>
  4c:	53 c7       	rjmp	.+3750   	; 0xef4 <MIDI_GetStatusType+0x38>
  4e:	52 c7       	rjmp	.+3748   	; 0xef4 <MIDI_GetStatusType+0x38>
  50:	51 c7       	rjmp	.+3746   	; 0xef4 <MIDI_GetStatusType+0x38>
  52:	50 c7       	rjmp	.+3744   	; 0xef4 <MIDI_GetStatusType+0x38>
  54:	3d c7       	rjmp	.+3706   	; 0xed0 <MIDI_GetStatusType+0x14>
  56:	4e c7       	rjmp	.+3740   	; 0xef4 <MIDI_GetStatusType+0x38>
  58:	4d c7       	rjmp	.+3738   	; 0xef4 <MIDI_GetStatusType+0x38>
  5a:	4c c7       	rjmp	.+3736   	; 0xef4 <MIDI_GetStatusType+0x38>
  5c:	4b c7       	rjmp	.+3734   	; 0xef4 <MIDI_GetStatusType+0x38>
  5e:	4a c7       	rjmp	.+3732   	; 0xef4 <MIDI_GetStatusType+0x38>
  60:	49 c7       	rjmp	.+3730   	; 0xef4 <MIDI_GetStatusType+0x38>
  62:	48 c7       	rjmp	.+3728   	; 0xef4 <MIDI_GetStatusType+0x38>
  64:	47 c7       	rjmp	.+3726   	; 0xef4 <MIDI_GetStatusType+0x38>
  66:	46 c7       	rjmp	.+3724   	; 0xef4 <MIDI_GetStatusType+0x38>
  68:	45 c7       	rjmp	.+3722   	; 0xef4 <MIDI_GetStatusType+0x38>
  6a:	44 c7       	rjmp	.+3720   	; 0xef4 <MIDI_GetStatusType+0x38>
  6c:	43 c7       	rjmp	.+3718   	; 0xef4 <MIDI_GetStatusType+0x38>
  6e:	42 c7       	rjmp	.+3716   	; 0xef4 <MIDI_GetStatusType+0x38>
  70:	41 c7       	rjmp	.+3714   	; 0xef4 <MIDI_GetStatusType+0x38>
  72:	40 c7       	rjmp	.+3712   	; 0xef4 <MIDI_GetStatusType+0x38>
  74:	2d c7       	rjmp	.+3674   	; 0xed0 <MIDI_GetStatusType+0x14>
  76:	3e c7       	rjmp	.+3708   	; 0xef4 <MIDI_GetStatusType+0x38>
  78:	3d c7       	rjmp	.+3706   	; 0xef4 <MIDI_GetStatusType+0x38>
  7a:	3c c7       	rjmp	.+3704   	; 0xef4 <MIDI_GetStatusType+0x38>
  7c:	3b c7       	rjmp	.+3702   	; 0xef4 <MIDI_GetStatusType+0x38>
  7e:	3a c7       	rjmp	.+3700   	; 0xef4 <MIDI_GetStatusType+0x38>
  80:	39 c7       	rjmp	.+3698   	; 0xef4 <MIDI_GetStatusType+0x38>
  82:	38 c7       	rjmp	.+3696   	; 0xef4 <MIDI_GetStatusType+0x38>
  84:	37 c7       	rjmp	.+3694   	; 0xef4 <MIDI_GetStatusType+0x38>
  86:	36 c7       	rjmp	.+3692   	; 0xef4 <MIDI_GetStatusType+0x38>
  88:	35 c7       	rjmp	.+3690   	; 0xef4 <MIDI_GetStatusType+0x38>
  8a:	34 c7       	rjmp	.+3688   	; 0xef4 <MIDI_GetStatusType+0x38>
  8c:	33 c7       	rjmp	.+3686   	; 0xef4 <MIDI_GetStatusType+0x38>
  8e:	32 c7       	rjmp	.+3684   	; 0xef4 <MIDI_GetStatusType+0x38>
  90:	31 c7       	rjmp	.+3682   	; 0xef4 <MIDI_GetStatusType+0x38>
  92:	30 c7       	rjmp	.+3680   	; 0xef4 <MIDI_GetStatusType+0x38>
  94:	1d c7       	rjmp	.+3642   	; 0xed0 <MIDI_GetStatusType+0x14>
  96:	2e c7       	rjmp	.+3676   	; 0xef4 <MIDI_GetStatusType+0x38>
  98:	2d c7       	rjmp	.+3674   	; 0xef4 <MIDI_GetStatusType+0x38>
  9a:	2c c7       	rjmp	.+3672   	; 0xef4 <MIDI_GetStatusType+0x38>
  9c:	2b c7       	rjmp	.+3670   	; 0xef4 <MIDI_GetStatusType+0x38>
  9e:	2a c7       	rjmp	.+3668   	; 0xef4 <MIDI_GetStatusType+0x38>
  a0:	29 c7       	rjmp	.+3666   	; 0xef4 <MIDI_GetStatusType+0x38>
  a2:	28 c7       	rjmp	.+3664   	; 0xef4 <MIDI_GetStatusType+0x38>
  a4:	27 c7       	rjmp	.+3662   	; 0xef4 <MIDI_GetStatusType+0x38>
  a6:	26 c7       	rjmp	.+3660   	; 0xef4 <MIDI_GetStatusType+0x38>
  a8:	25 c7       	rjmp	.+3658   	; 0xef4 <MIDI_GetStatusType+0x38>
  aa:	24 c7       	rjmp	.+3656   	; 0xef4 <MIDI_GetStatusType+0x38>
  ac:	23 c7       	rjmp	.+3654   	; 0xef4 <MIDI_GetStatusType+0x38>
  ae:	22 c7       	rjmp	.+3652   	; 0xef4 <MIDI_GetStatusType+0x38>
  b0:	21 c7       	rjmp	.+3650   	; 0xef4 <MIDI_GetStatusType+0x38>
  b2:	20 c7       	rjmp	.+3648   	; 0xef4 <MIDI_GetStatusType+0x38>
  b4:	21 c7       	rjmp	.+3650   	; 0xef8 <MIDI_GetStatusType+0x3c>
  b6:	1e c7       	rjmp	.+3644   	; 0xef4 <MIDI_GetStatusType+0x38>
  b8:	1d c7       	rjmp	.+3642   	; 0xef4 <MIDI_GetStatusType+0x38>
  ba:	1c c7       	rjmp	.+3640   	; 0xef4 <MIDI_GetStatusType+0x38>
  bc:	1b c7       	rjmp	.+3638   	; 0xef4 <MIDI_GetStatusType+0x38>
  be:	1a c7       	rjmp	.+3636   	; 0xef4 <MIDI_GetStatusType+0x38>
  c0:	19 c7       	rjmp	.+3634   	; 0xef4 <MIDI_GetStatusType+0x38>
  c2:	18 c7       	rjmp	.+3632   	; 0xef4 <MIDI_GetStatusType+0x38>
  c4:	17 c7       	rjmp	.+3630   	; 0xef4 <MIDI_GetStatusType+0x38>
  c6:	16 c7       	rjmp	.+3628   	; 0xef4 <MIDI_GetStatusType+0x38>
  c8:	15 c7       	rjmp	.+3626   	; 0xef4 <MIDI_GetStatusType+0x38>
  ca:	14 c7       	rjmp	.+3624   	; 0xef4 <MIDI_GetStatusType+0x38>
  cc:	13 c7       	rjmp	.+3622   	; 0xef4 <MIDI_GetStatusType+0x38>
  ce:	12 c7       	rjmp	.+3620   	; 0xef4 <MIDI_GetStatusType+0x38>
  d0:	11 c7       	rjmp	.+3618   	; 0xef4 <MIDI_GetStatusType+0x38>
  d2:	10 c7       	rjmp	.+3616   	; 0xef4 <MIDI_GetStatusType+0x38>
  d4:	11 c7       	rjmp	.+3618   	; 0xef8 <MIDI_GetStatusType+0x3c>
  d6:	0e c7       	rjmp	.+3612   	; 0xef4 <MIDI_GetStatusType+0x38>
  d8:	0d c7       	rjmp	.+3610   	; 0xef4 <MIDI_GetStatusType+0x38>
  da:	0c c7       	rjmp	.+3608   	; 0xef4 <MIDI_GetStatusType+0x38>
  dc:	0b c7       	rjmp	.+3606   	; 0xef4 <MIDI_GetStatusType+0x38>
  de:	0a c7       	rjmp	.+3604   	; 0xef4 <MIDI_GetStatusType+0x38>
  e0:	09 c7       	rjmp	.+3602   	; 0xef4 <MIDI_GetStatusType+0x38>
  e2:	08 c7       	rjmp	.+3600   	; 0xef4 <MIDI_GetStatusType+0x38>
  e4:	07 c7       	rjmp	.+3598   	; 0xef4 <MIDI_GetStatusType+0x38>
  e6:	06 c7       	rjmp	.+3596   	; 0xef4 <MIDI_GetStatusType+0x38>
  e8:	05 c7       	rjmp	.+3594   	; 0xef4 <MIDI_GetStatusType+0x38>
  ea:	04 c7       	rjmp	.+3592   	; 0xef4 <MIDI_GetStatusType+0x38>
  ec:	03 c7       	rjmp	.+3590   	; 0xef4 <MIDI_GetStatusType+0x38>
  ee:	02 c7       	rjmp	.+3588   	; 0xef4 <MIDI_GetStatusType+0x38>
  f0:	01 c7       	rjmp	.+3586   	; 0xef4 <MIDI_GetStatusType+0x38>
  f2:	00 c7       	rjmp	.+3584   	; 0xef4 <MIDI_GetStatusType+0x38>
  f4:	ed c6       	rjmp	.+3546   	; 0xed0 <MIDI_GetStatusType+0x14>
  f6:	fe c6       	rjmp	.+3580   	; 0xef4 <MIDI_GetStatusType+0x38>
  f8:	fd c6       	rjmp	.+3578   	; 0xef4 <MIDI_GetStatusType+0x38>
  fa:	fc c6       	rjmp	.+3576   	; 0xef4 <MIDI_GetStatusType+0x38>
  fc:	fb c6       	rjmp	.+3574   	; 0xef4 <MIDI_GetStatusType+0x38>
  fe:	fa c6       	rjmp	.+3572   	; 0xef4 <MIDI_GetStatusType+0x38>
 100:	f9 c6       	rjmp	.+3570   	; 0xef4 <MIDI_GetStatusType+0x38>
 102:	f8 c6       	rjmp	.+3568   	; 0xef4 <MIDI_GetStatusType+0x38>
 104:	f7 c6       	rjmp	.+3566   	; 0xef4 <MIDI_GetStatusType+0x38>
 106:	f6 c6       	rjmp	.+3564   	; 0xef4 <MIDI_GetStatusType+0x38>
 108:	f5 c6       	rjmp	.+3562   	; 0xef4 <MIDI_GetStatusType+0x38>
 10a:	f4 c6       	rjmp	.+3560   	; 0xef4 <MIDI_GetStatusType+0x38>
 10c:	f3 c6       	rjmp	.+3558   	; 0xef4 <MIDI_GetStatusType+0x38>
 10e:	f2 c6       	rjmp	.+3556   	; 0xef4 <MIDI_GetStatusType+0x38>
 110:	f1 c6       	rjmp	.+3554   	; 0xef4 <MIDI_GetStatusType+0x38>
 112:	f0 c6       	rjmp	.+3552   	; 0xef4 <MIDI_GetStatusType+0x38>
 114:	eb c6       	rjmp	.+3542   	; 0xeec <MIDI_GetStatusType+0x30>
 116:	f0 c6       	rjmp	.+3552   	; 0xef8 <MIDI_GetStatusType+0x3c>
 118:	db c6       	rjmp	.+3510   	; 0xed0 <MIDI_GetStatusType+0x14>
 11a:	ee c6       	rjmp	.+3548   	; 0xef8 <MIDI_GetStatusType+0x3c>
 11c:	eb c6       	rjmp	.+3542   	; 0xef4 <MIDI_GetStatusType+0x38>
 11e:	ea c6       	rjmp	.+3540   	; 0xef4 <MIDI_GetStatusType+0x38>
 120:	e9 c6       	rjmp	.+3538   	; 0xef4 <MIDI_GetStatusType+0x38>
 122:	e6 c6       	rjmp	.+3532   	; 0xef0 <MIDI_GetStatusType+0x34>
 124:	d7 c6       	rjmp	.+3502   	; 0xed4 <MIDI_GetStatusType+0x18>
 126:	e6 c6       	rjmp	.+3532   	; 0xef4 <MIDI_GetStatusType+0x38>
 128:	d7 c6       	rjmp	.+3502   	; 0xed8 <MIDI_GetStatusType+0x1c>
 12a:	d8 c6       	rjmp	.+3504   	; 0xedc <MIDI_GetStatusType+0x20>
 12c:	d9 c6       	rjmp	.+3506   	; 0xee0 <MIDI_GetStatusType+0x24>
 12e:	e2 c6       	rjmp	.+3524   	; 0xef4 <MIDI_GetStatusType+0x38>
 130:	d9 c6       	rjmp	.+3506   	; 0xee4 <MIDI_GetStatusType+0x28>
 132:	da c6       	rjmp	.+3508   	; 0xee8 <MIDI_GetStatusType+0x2c>
 134:	b7 c2       	rjmp	.+1390   	; 0x6a4 <MIDI_ParserTask+0x18>
 136:	c3 c2       	rjmp	.+1414   	; 0x6be <MIDI_ParserTask+0x32>
 138:	02 c3       	rjmp	.+1540   	; 0x73e <MIDI_ParserTask+0xb2>
 13a:	35 c3       	rjmp	.+1642   	; 0x7a6 <MIDI_ParserTask+0x11a>
 13c:	15 c3       	rjmp	.+1578   	; 0x768 <MIDI_ParserTask+0xdc>
 13e:	44 c3       	rjmp	.+1672   	; 0x7c8 <MIDI_ParserTask+0x13c>
 140:	47 c3       	rjmp	.+1678   	; 0x7d0 <MIDI_ParserTask+0x144>
 142:	2e c1       	rjmp	.+604    	; 0x3a0 <readButtonsState+0x18>
 144:	41 c1       	rjmp	.+642    	; 0x3c8 <readButtonsState+0x40>
 146:	57 c1       	rjmp	.+686    	; 0x3f6 <readButtonsState+0x6e>
 148:	6d c1       	rjmp	.+730    	; 0x424 <__DATA_REGION_LENGTH__+0x24>
 14a:	80 c1       	rjmp	.+768    	; 0x44c <__DATA_REGION_LENGTH__+0x4c>
 14c:	96 c1       	rjmp	.+812    	; 0x47a <__DATA_REGION_LENGTH__+0x7a>
 14e:	a4 c1       	rjmp	.+840    	; 0x498 <__DATA_REGION_LENGTH__+0x98>
 150:	ba c1       	rjmp	.+884    	; 0x4c6 <__DATA_REGION_LENGTH__+0xc6>

00000152 <.dinit>:
 152:	01 00       	.word	0x0001	; ????
 154:	01 86       	std	Z+9, r0	; 0x09
 156:	80 01       	movw	r16, r0
 158:	86 01       	movw	r16, r12
 15a:	9e 00       	.word	0x009e	; ????
 15c:	13 88       	ldd	r1, Z+19	; 0x13
 15e:	01 9e       	mul	r0, r17
 160:	01 a4       	ldd	r0, Z+41	; 0x29
 162:	80 01       	movw	r16, r0
 164:	a4 01       	movw	r20, r8
 166:	a8 00       	.word	0x00a8	; ????
 168:	13 a0       	ldd	r1, Z+35	; 0x23
 16a:	01 a8       	ldd	r0, Z+49	; 0x31
 16c:	01 ae       	std	Z+57, r0	; 0x39
 16e:	80 01       	movw	r16, r0
 170:	ae 01       	movw	r20, r28
 172:	af 00       	.word	0x00af	; ????
 174:	13 a4       	ldd	r1, Z+43	; 0x2b
 176:	01 af       	std	Z+57, r16	; 0x39
 178:	01 b2       	in	r0, 0x11	; 17
 17a:	80 00       	.word	0x0080	; ????

0000017c <__ctors_end>:
 17c:	11 24       	eor	r1, r1
 17e:	1f be       	out	0x3f, r1	; 63
 180:	cf ef       	ldi	r28, 0xFF	; 255
 182:	d4 e0       	ldi	r29, 0x04	; 4
 184:	de bf       	out	0x3e, r29	; 62
 186:	cd bf       	out	0x3d, r28	; 61

00000188 <__do_copy_data>:
 188:	e2 e5       	ldi	r30, 0x52	; 82
 18a:	f1 e0       	ldi	r31, 0x01	; 1
 18c:	41 e0       	ldi	r20, 0x01	; 1
 18e:	17 c0       	rjmp	.+46     	; 0x1be <__do_clear_bss+0x8>
 190:	b5 91       	lpm	r27, Z+
 192:	a5 91       	lpm	r26, Z+
 194:	35 91       	lpm	r19, Z+
 196:	25 91       	lpm	r18, Z+
 198:	05 91       	lpm	r16, Z+
 19a:	07 fd       	sbrc	r16, 7
 19c:	0c c0       	rjmp	.+24     	; 0x1b6 <__do_clear_bss>
 19e:	95 91       	lpm	r25, Z+
 1a0:	85 91       	lpm	r24, Z+
 1a2:	ef 01       	movw	r28, r30
 1a4:	f9 2f       	mov	r31, r25
 1a6:	e8 2f       	mov	r30, r24
 1a8:	05 90       	lpm	r0, Z+
 1aa:	0d 92       	st	X+, r0
 1ac:	a2 17       	cp	r26, r18
 1ae:	b3 07       	cpc	r27, r19
 1b0:	d9 f7       	brne	.-10     	; 0x1a8 <__do_copy_data+0x20>
 1b2:	fe 01       	movw	r30, r28
 1b4:	04 c0       	rjmp	.+8      	; 0x1be <__do_clear_bss+0x8>

000001b6 <__do_clear_bss>:
 1b6:	1d 92       	st	X+, r1
 1b8:	a2 17       	cp	r26, r18
 1ba:	b3 07       	cpc	r27, r19
 1bc:	e1 f7       	brne	.-8      	; 0x1b6 <__do_clear_bss>
 1be:	eb 37       	cpi	r30, 0x7B	; 123
 1c0:	f4 07       	cpc	r31, r20
 1c2:	31 f7       	brne	.-52     	; 0x190 <__do_copy_data+0x8>
 1c4:	e5 d7       	rcall	.+4042   	; 0x1190 <main>
 1c6:	8e c8       	rjmp	.-3812   	; 0xfffff2e4 <__eeprom_end+0xff7ef2e4>

000001c8 <_exit>:
 1c8:	f8 94       	cli

000001ca <__stop_program>:
 1ca:	ff cf       	rjmp	.-2      	; 0x1ca <__stop_program>

Disassembly of section .text:

0000137e <__bad_interrupt>:
    137e:	40 c6       	rjmp	.+3200   	; 0x2000 <__TEXT_REGION_LENGTH__>

Disassembly of section .text.main:

00001190 <main>:
#include "sh100_hardware.h"
#include "sh100_controller.h"

int main(void)
{
	UART_init();
    1190:	64 d0       	rcall	.+200    	; 0x125a <UART_init>
	SH100HW_Init();
    1192:	ab dc       	rcall	.-1706   	; 0xaea <SH100HW_Init>
	SH100CTRL_Init();
    1194:	dd dc       	rcall	.-1606   	; 0xb50 <SH100CTRL_Init>
	MIDICTRL_Init();
    1196:	89 df       	rcall	.-238    	; 0x10aa <MIDICTRL_Init>
	
	// Timer0 init. For main task
	TCCR0B |= 0x05; // psc = 1024
    1198:	85 b5       	in	r24, 0x25	; 37
    119a:	85 60       	ori	r24, 0x05	; 5
    119c:	85 bd       	out	0x25, r24	; 37
	TIMSK0 |= 0x01; // OVF INT enable, count pulse = 100us
    119e:	ee e6       	ldi	r30, 0x6E	; 110
    11a0:	f0 e0       	ldi	r31, 0x00	; 0
    11a2:	80 81       	ld	r24, Z
    11a4:	81 60       	ori	r24, 0x01	; 1
    11a6:	80 83       	st	Z, r24
	TCNT0 = 100;
    11a8:	84 e6       	ldi	r24, 0x64	; 100
    11aa:	86 bd       	out	0x26, r24	; 38
	
	cpu_irq_enable();
    11ac:	78 94       	sei
	
    while(1)
    {
		MIDI_ParserTask();
    11ae:	6e da       	rcall	.-2852   	; 0x68c <MIDI_ParserTask>
    11b0:	fe cf       	rjmp	.-4      	; 0x11ae <main+0x1e>

Disassembly of section .text.__vector_16:

0000050e <__vector_16>:

uint8_t swProgrammingMode_cnt = 0;
uint8_t leaveDefSettings_cnt = 0;

ISR(TIMER0_OVF_vect)
{
 50e:	1f 92       	push	r1
 510:	0f 92       	push	r0
 512:	0f b6       	in	r0, 0x3f	; 63
 514:	0f 92       	push	r0
 516:	11 24       	eor	r1, r1
 518:	1f 93       	push	r17
 51a:	2f 93       	push	r18
 51c:	3f 93       	push	r19
 51e:	4f 93       	push	r20
 520:	5f 93       	push	r21
 522:	6f 93       	push	r22
 524:	7f 93       	push	r23
 526:	8f 93       	push	r24
 528:	9f 93       	push	r25
 52a:	af 93       	push	r26
 52c:	bf 93       	push	r27
 52e:	ef 93       	push	r30
 530:	ff 93       	push	r31
 532:	cf 93       	push	r28
 534:	df 93       	push	r29
 536:	cd b7       	in	r28, 0x3d	; 61
 538:	de b7       	in	r29, 0x3e	; 62
 53a:	2f 97       	sbiw	r28, 0x0f	; 15
 53c:	de bf       	out	0x3e, r29	; 62
 53e:	cd bf       	out	0x3d, r28	; 61
	SH100HW_MainTask();
 540:	47 de       	rcall	.-882    	; 0x1d0 <SH100HW_MainTask>
	SH100CTRL_CheckOutputJacks();
 542:	2e d4       	rcall	.+2140   	; 0xda0 <SH100CTRL_CheckOutputJacks>
	
	SH100HW_Buttons_t pressedButtons = SH100HW_GetButtonsState();
 544:	ce 01       	movw	r24, r28
 546:	01 96       	adiw	r24, 0x01	; 1
 548:	b4 d6       	rcall	.+3432   	; 0x12b2 <SH100HW_GetButtonsState>
	
	MIDICTRL_SetMidiChannel(pressedButtons.midiChNum);
 54a:	89 81       	ldd	r24, Y+1	; 0x01
 54c:	01 d7       	rcall	.+3586   	; 0x1350 <MIDICTRL_SetMidiChannel>
	MIDICTRL_OmniModeEn(pressedButtons.midiOmni);
 54e:	9a 81       	ldd	r25, Y+2	; 0x02
 550:	81 e0       	ldi	r24, 0x01	; 1
 552:	91 11       	cpse	r25, r1
 554:	01 c0       	rjmp	.+2      	; 0x558 <__vector_16+0x4a>
 556:	80 e0       	ldi	r24, 0x00	; 0
 558:	fe d6       	rcall	.+3580   	; 0x1356 <MIDICTRL_OmniModeEn>
	MIDICTRL_MuteCommEn(pressedButtons.midiMuteComm);
 55a:	9b 81       	ldd	r25, Y+3	; 0x03
 55c:	81 e0       	ldi	r24, 0x01	; 1
 55e:	91 11       	cpse	r25, r1
 560:	01 c0       	rjmp	.+2      	; 0x564 <__vector_16+0x56>
 562:	80 e0       	ldi	r24, 0x00	; 0
 564:	fb d6       	rcall	.+3574   	; 0x135c <MIDICTRL_MuteCommEn>
	
	//=============BTN AB===========================
	if(pressedButtons.btnAB == BT_ON)
 566:	88 85       	ldd	r24, Y+8	; 0x08
 568:	81 30       	cpi	r24, 0x01	; 1
 56a:	d9 f4       	brne	.+54     	; 0x5a2 <__vector_16+0x94>
	{
		if(leaveDefSettings_cnt == 200)
 56c:	80 91 a8 01 	lds	r24, 0x01A8	; 0x8001a8 <leaveDefSettings_cnt>
 570:	88 3c       	cpi	r24, 0xC8	; 200
 572:	49 f4       	brne	.+18     	; 0x586 <__vector_16+0x78>
		{
			if(MIDICTRL_MidiMode() == PROGRAMMING)
 574:	ea d6       	rcall	.+3540   	; 0x134a <MIDICTRL_MidiMode>
 576:	81 30       	cpi	r24, 0x01	; 1
 578:	b1 f4       	brne	.+44     	; 0x5a6 <__vector_16+0x98>
			{
				leaveDefSettings_cnt = 0;
 57a:	10 92 a8 01 	sts	0x01A8, r1	; 0x8001a8 <leaveDefSettings_cnt>
				MIDICTRL_DiscardCommands();
 57e:	8f d6       	rcall	.+3358   	; 0x129e <MIDICTRL_DiscardCommands>
				SH100CTRL_SetAmpLeds();
 580:	bd d5       	rcall	.+2938   	; 0x10fc <SH100CTRL_SetAmpLeds>
				SH100CTRL_UnmuteAmp();
 582:	c9 d6       	rcall	.+3474   	; 0x1316 <SH100CTRL_UnmuteAmp>
 584:	10 c0       	rjmp	.+32     	; 0x5a6 <__vector_16+0x98>
			}
		}
		else
		{
			leaveDefSettings_cnt++;
 586:	8f 5f       	subi	r24, 0xFF	; 255
 588:	80 93 a8 01 	sts	0x01A8, r24	; 0x8001a8 <leaveDefSettings_cnt>
			switch(MIDICTRL_MidiMode())
 58c:	de d6       	rcall	.+3516   	; 0x134a <MIDICTRL_MidiMode>
 58e:	88 23       	and	r24, r24
 590:	19 f0       	breq	.+6      	; 0x598 <__vector_16+0x8a>
 592:	81 30       	cpi	r24, 0x01	; 1
 594:	19 f0       	breq	.+6      	; 0x59c <__vector_16+0x8e>
 596:	07 c0       	rjmp	.+14     	; 0x5a6 <__vector_16+0x98>
			{
				case RUNNING: SH100CTRL_SwAB(); break;
 598:	b8 d6       	rcall	.+3440   	; 0x130a <SH100CTRL_SwAB>
 59a:	05 c0       	rjmp	.+10     	; 0x5a6 <__vector_16+0x98>
				case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_AB); break;
 59c:	85 e0       	ldi	r24, 0x05	; 5
 59e:	6e d5       	rcall	.+2780   	; 0x107c <MIDICTRL_SetProgrammingButton>
 5a0:	02 c0       	rjmp	.+4      	; 0x5a6 <__vector_16+0x98>
			}
		}
	}
	else leaveDefSettings_cnt=0;
 5a2:	10 92 a8 01 	sts	0x01A8, r1	; 0x8001a8 <leaveDefSettings_cnt>

	//=============BTN LOOP=========================
	if(pressedButtons.btnCh2 == BT_ON)
 5a6:	1d 81       	ldd	r17, Y+5	; 0x05
 5a8:	11 30       	cpi	r17, 0x01	; 1
 5aa:	51 f4       	brne	.+20     	; 0x5c0 <__vector_16+0xb2>
	{
		switch(MIDICTRL_MidiMode())
 5ac:	ce d6       	rcall	.+3484   	; 0x134a <MIDICTRL_MidiMode>
 5ae:	88 23       	and	r24, r24
 5b0:	19 f0       	breq	.+6      	; 0x5b8 <__vector_16+0xaa>
 5b2:	81 30       	cpi	r24, 0x01	; 1
 5b4:	19 f0       	breq	.+6      	; 0x5bc <__vector_16+0xae>
 5b6:	04 c0       	rjmp	.+8      	; 0x5c0 <__vector_16+0xb2>
		{
			case RUNNING: SH100CTRL_SwLoop(); break;
 5b8:	a2 d6       	rcall	.+3396   	; 0x12fe <SH100CTRL_SwLoop>
 5ba:	02 c0       	rjmp	.+4      	; 0x5c0 <__vector_16+0xb2>
			case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_LOOP); break;
 5bc:	84 e0       	ldi	r24, 0x04	; 4
 5be:	5e d5       	rcall	.+2748   	; 0x107c <MIDICTRL_SetProgrammingButton>
		}
	}
		
	//=============BTN CH4==========================
	if(pressedButtons.btnCh2 == BT_ON)
 5c0:	11 30       	cpi	r17, 0x01	; 1
 5c2:	59 f4       	brne	.+22     	; 0x5da <__vector_16+0xcc>
	{
		switch(MIDICTRL_MidiMode())
 5c4:	c2 d6       	rcall	.+3460   	; 0x134a <MIDICTRL_MidiMode>
 5c6:	88 23       	and	r24, r24
 5c8:	19 f0       	breq	.+6      	; 0x5d0 <__vector_16+0xc2>
 5ca:	81 30       	cpi	r24, 0x01	; 1
 5cc:	21 f0       	breq	.+8      	; 0x5d6 <__vector_16+0xc8>
 5ce:	05 c0       	rjmp	.+10     	; 0x5da <__vector_16+0xcc>
		{
			case RUNNING: SH100CTRL_SwChannel(SH100_CHANNEL4); break;
 5d0:	83 e0       	ldi	r24, 0x03	; 3
 5d2:	ad d6       	rcall	.+3418   	; 0x132e <SH100CTRL_SwChannel>
 5d4:	02 c0       	rjmp	.+4      	; 0x5da <__vector_16+0xcc>
			case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH4); break;
 5d6:	83 e0       	ldi	r24, 0x03	; 3
 5d8:	51 d5       	rcall	.+2722   	; 0x107c <MIDICTRL_SetProgrammingButton>
		}
	}
		
	//=============BTN CH3==========================
	if(pressedButtons.btnCh2 == BT_ON)
 5da:	11 30       	cpi	r17, 0x01	; 1
 5dc:	59 f4       	brne	.+22     	; 0x5f4 <__vector_16+0xe6>
	{
		switch(MIDICTRL_MidiMode())
 5de:	b5 d6       	rcall	.+3434   	; 0x134a <MIDICTRL_MidiMode>
 5e0:	88 23       	and	r24, r24
 5e2:	19 f0       	breq	.+6      	; 0x5ea <__vector_16+0xdc>
 5e4:	81 30       	cpi	r24, 0x01	; 1
 5e6:	21 f0       	breq	.+8      	; 0x5f0 <__vector_16+0xe2>
 5e8:	05 c0       	rjmp	.+10     	; 0x5f4 <__vector_16+0xe6>
		{
			case RUNNING: SH100CTRL_SwChannel(SH100_CHANNEL3); break;
 5ea:	82 e0       	ldi	r24, 0x02	; 2
 5ec:	a0 d6       	rcall	.+3392   	; 0x132e <SH100CTRL_SwChannel>
 5ee:	02 c0       	rjmp	.+4      	; 0x5f4 <__vector_16+0xe6>
			case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH3); break;
 5f0:	82 e0       	ldi	r24, 0x02	; 2
 5f2:	44 d5       	rcall	.+2696   	; 0x107c <MIDICTRL_SetProgrammingButton>
		}
	}
		
	//=============BTN CH2==========================
	if(pressedButtons.btnCh2 == BT_ON)
 5f4:	11 30       	cpi	r17, 0x01	; 1
 5f6:	59 f4       	brne	.+22     	; 0x60e <__vector_16+0x100>
	{
		switch(MIDICTRL_MidiMode())
 5f8:	a8 d6       	rcall	.+3408   	; 0x134a <MIDICTRL_MidiMode>
 5fa:	88 23       	and	r24, r24
 5fc:	19 f0       	breq	.+6      	; 0x604 <__vector_16+0xf6>
 5fe:	81 30       	cpi	r24, 0x01	; 1
 600:	21 f0       	breq	.+8      	; 0x60a <__vector_16+0xfc>
 602:	05 c0       	rjmp	.+10     	; 0x60e <__vector_16+0x100>
		{
			case RUNNING: SH100CTRL_SwChannel(SH100_CHANNEL2); break;
 604:	81 e0       	ldi	r24, 0x01	; 1
 606:	93 d6       	rcall	.+3366   	; 0x132e <SH100CTRL_SwChannel>
 608:	02 c0       	rjmp	.+4      	; 0x60e <__vector_16+0x100>
			case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH2); break;
 60a:	81 e0       	ldi	r24, 0x01	; 1
 60c:	37 d5       	rcall	.+2670   	; 0x107c <MIDICTRL_SetProgrammingButton>
		}
	}
	
	//=============BTN CH1==========================
	if(pressedButtons.btnCh1 == BT_ON)
 60e:	8c 81       	ldd	r24, Y+4	; 0x04
 610:	81 30       	cpi	r24, 0x01	; 1
 612:	01 f5       	brne	.+64     	; 0x654 <__vector_16+0x146>
	{
		if(swProgrammingMode_cnt == 200)
 614:	80 91 a9 01 	lds	r24, 0x01A9	; 0x8001a9 <swProgrammingMode_cnt>
 618:	88 3c       	cpi	r24, 0xC8	; 200
 61a:	69 f4       	brne	.+26     	; 0x636 <__vector_16+0x128>
		{
			swProgrammingMode_cnt = 0;
 61c:	10 92 a9 01 	sts	0x01A9, r1	; 0x8001a9 <swProgrammingMode_cnt>
			//enter prog mode, or save settings
			if(MIDICTRL_MidiMode() == RUNNING)
 620:	94 d6       	rcall	.+3368   	; 0x134a <MIDICTRL_MidiMode>
 622:	81 11       	cpse	r24, r1
 624:	04 c0       	rjmp	.+8      	; 0x62e <__vector_16+0x120>
			{
				MIDICTRL_SwitchMode(PROGRAMMING);
 626:	81 e0       	ldi	r24, 0x01	; 1
 628:	28 d4       	rcall	.+2128   	; 0xe7a <MIDICTRL_SwitchMode>
				SH100CTRL_MuteAmp();
 62a:	9e d6       	rcall	.+3388   	; 0x1368 <SH100CTRL_MuteAmp>
 62c:	15 c0       	rjmp	.+42     	; 0x658 <__vector_16+0x14a>
			}
			else
			{
				MIDICTRL_StoreUserCommands();
 62e:	bd d4       	rcall	.+2426   	; 0xfaa <MIDICTRL_StoreUserCommands>
				SH100CTRL_SetAmpLeds();
 630:	65 d5       	rcall	.+2762   	; 0x10fc <SH100CTRL_SetAmpLeds>
				SH100CTRL_UnmuteAmp();
 632:	71 d6       	rcall	.+3298   	; 0x1316 <SH100CTRL_UnmuteAmp>
 634:	11 c0       	rjmp	.+34     	; 0x658 <__vector_16+0x14a>
			}
		}
		else
		{
			swProgrammingMode_cnt++;
 636:	8f 5f       	subi	r24, 0xFF	; 255
 638:	80 93 a9 01 	sts	0x01A9, r24	; 0x8001a9 <swProgrammingMode_cnt>
			switch(MIDICTRL_MidiMode()) 
 63c:	86 d6       	rcall	.+3340   	; 0x134a <MIDICTRL_MidiMode>
 63e:	88 23       	and	r24, r24
 640:	19 f0       	breq	.+6      	; 0x648 <__vector_16+0x13a>
 642:	81 30       	cpi	r24, 0x01	; 1
 644:	21 f0       	breq	.+8      	; 0x64e <__vector_16+0x140>
 646:	08 c0       	rjmp	.+16     	; 0x658 <__vector_16+0x14a>
			{
				case RUNNING: SH100CTRL_SwChannel(SH100_CHANNEL1); break;
 648:	80 e0       	ldi	r24, 0x00	; 0
 64a:	71 d6       	rcall	.+3298   	; 0x132e <SH100CTRL_SwChannel>
 64c:	05 c0       	rjmp	.+10     	; 0x658 <__vector_16+0x14a>
				case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH1); break;
 64e:	80 e0       	ldi	r24, 0x00	; 0
 650:	15 d5       	rcall	.+2602   	; 0x107c <MIDICTRL_SetProgrammingButton>
 652:	02 c0       	rjmp	.+4      	; 0x658 <__vector_16+0x14a>
			}			
		}		
	}
	else swProgrammingMode_cnt=0;
 654:	10 92 a9 01 	sts	0x01A9, r1	; 0x8001a9 <swProgrammingMode_cnt>
 658:	2f 96       	adiw	r28, 0x0f	; 15
 65a:	0f b6       	in	r0, 0x3f	; 63
 65c:	f8 94       	cli
 65e:	de bf       	out	0x3e, r29	; 62
 660:	0f be       	out	0x3f, r0	; 63
 662:	cd bf       	out	0x3d, r28	; 61
 664:	df 91       	pop	r29
 666:	cf 91       	pop	r28
 668:	ff 91       	pop	r31
 66a:	ef 91       	pop	r30
 66c:	bf 91       	pop	r27
 66e:	af 91       	pop	r26
 670:	9f 91       	pop	r25
 672:	8f 91       	pop	r24
 674:	7f 91       	pop	r23
 676:	6f 91       	pop	r22
 678:	5f 91       	pop	r21
 67a:	4f 91       	pop	r20
 67c:	3f 91       	pop	r19
 67e:	2f 91       	pop	r18
 680:	1f 91       	pop	r17
 682:	0f 90       	pop	r0
 684:	0f be       	out	0x3f, r0	; 63
 686:	0f 90       	pop	r0
 688:	1f 90       	pop	r1
 68a:	18 95       	reti

Disassembly of section .text.MIDI_IsStatusWord:

00001342 <MIDI_IsStatusWord>:
#include "midi.h"

bool MIDI_IsStatusWord(uint8_t word)
{
	return (word & 0x80);
}
    1342:	88 1f       	adc	r24, r24
    1344:	88 27       	eor	r24, r24
    1346:	88 1f       	adc	r24, r24
    1348:	08 95       	ret

Disassembly of section .text.MIDI_IsSysRealTime:

000012f2 <MIDI_IsSysRealTime>:

bool MIDI_IsSysRealTime(uint8_t word)
{
	return word > 0xF7;
    12f2:	91 e0       	ldi	r25, 0x01	; 1
    12f4:	88 3f       	cpi	r24, 0xF8	; 248
    12f6:	08 f4       	brcc	.+2      	; 0x12fa <MIDI_IsSysRealTime+0x8>
    12f8:	90 e0       	ldi	r25, 0x00	; 0
}
    12fa:	89 2f       	mov	r24, r25
    12fc:	08 95       	ret

Disassembly of section .text.MIDI_GetStatusType:

00000ebc <MIDI_GetStatusType>:

MIDI_StatusType_t MIDI_GetStatusType(MIDI_Status_t status)
{
	switch(status)
 ebc:	90 e0       	ldi	r25, 0x00	; 0
 ebe:	fc 01       	movw	r30, r24
 ec0:	e0 58       	subi	r30, 0x80	; 128
 ec2:	f1 09       	sbc	r31, r1
 ec4:	e0 38       	cpi	r30, 0x80	; 128
 ec6:	f1 05       	cpc	r31, r1
 ec8:	a8 f4       	brcc	.+42     	; 0xef4 <MIDI_GetStatusType+0x38>
 eca:	e6 5e       	subi	r30, 0xE6	; 230
 ecc:	ff 4f       	sbci	r31, 0xFF	; 255
 ece:	09 94       	ijmp
	{
		// Status messages with 2 bytes
		case MIDI_COMM_NOTE_OFF: return MIDI_TYPE_TWO_BYTE;
 ed0:	82 e0       	ldi	r24, 0x02	; 2
 ed2:	08 95       	ret
		case MIDI_COMM_CHANNEL_PRESSURE: return MIDI_TYPE_ONE_BYTE;
		case MIDI_COMM_TIME_CODE: return MIDI_TYPE_ONE_BYTE;
		case MIDI_COMM_SONG_SELECT: return MIDI_TYPE_ONE_BYTE;

		// System real-time messages(no data bytes)
		case MIDI_COMM_TIMING_CLOCK: return MIDI_TYPE_REAL_TIME;
 ed4:	83 e0       	ldi	r24, 0x03	; 3
 ed6:	08 95       	ret
		case MIDI_COMM_START: return MIDI_TYPE_REAL_TIME;
 ed8:	83 e0       	ldi	r24, 0x03	; 3
 eda:	08 95       	ret
		case MIDI_COMM_CONTINUE: return MIDI_TYPE_REAL_TIME;
 edc:	83 e0       	ldi	r24, 0x03	; 3
 ede:	08 95       	ret
		case MIDI_COMM_STO: return MIDI_TYPE_REAL_TIME;
 ee0:	83 e0       	ldi	r24, 0x03	; 3
 ee2:	08 95       	ret
		case MIDI_COMM_ACTIVE_SENSING: return MIDI_TYPE_REAL_TIME;
 ee4:	83 e0       	ldi	r24, 0x03	; 3
 ee6:	08 95       	ret
		case MIDI_COMM_SYSTEM_RESET: return MIDI_TYPE_REAL_TIME;
 ee8:	83 e0       	ldi	r24, 0x03	; 3
 eea:	08 95       	ret

		// System exclusive
		case MIDI_COMM_START_SYS_EX: return MIDI_TYPE_START_SYS_EX;
 eec:	84 e0       	ldi	r24, 0x04	; 4
 eee:	08 95       	ret
		case MIDI_COMM_STOP_SYS_EX: return MIDI_TYPE_STOP_SYS_EX;
 ef0:	85 e0       	ldi	r24, 0x05	; 5
 ef2:	08 95       	ret
		
		default: return MIDI_TYPE_UNDEFINED;
 ef4:	80 e0       	ldi	r24, 0x00	; 0
 ef6:	08 95       	ret
		case MIDI_COMM_CONTROL_CHANGE: return MIDI_TYPE_TWO_BYTE;
		case MIDI_COMM_PITCH_BEND: return MIDI_TYPE_TWO_BYTE;
		case MIDI_COMM_SONG_POSITION: return MIDI_TYPE_TWO_BYTE;

		// Status messages with 1 byte
		case MIDI_COMM_PROGRAM_CHANGE: return MIDI_TYPE_ONE_BYTE;
 ef8:	81 e0       	ldi	r24, 0x01	; 1
		case MIDI_COMM_START_SYS_EX: return MIDI_TYPE_START_SYS_EX;
		case MIDI_COMM_STOP_SYS_EX: return MIDI_TYPE_STOP_SYS_EX;
		
		default: return MIDI_TYPE_UNDEFINED;
	}
 efa:	08 95       	ret

Disassembly of section .text.isEqualCommands:

0000128a <isEqualCommands>:

void indicateMidiError();

bool isEqualCommands(MIDI_Command_t commandRecieved, MIDI_Command_t commandSaved)
{
	if(commandRecieved.status != commandSaved.status) return false;
    128a:	62 13       	cpse	r22, r18
    128c:	04 c0       	rjmp	.+8      	; 0x1296 <isEqualCommands+0xc>
	if(commandRecieved.data1 != commandSaved.data2) return false;	
    128e:	85 17       	cp	r24, r21
    1290:	21 f0       	breq	.+8      	; 0x129a <isEqualCommands+0x10>
    1292:	80 e0       	ldi	r24, 0x00	; 0
    1294:	08 95       	ret

void indicateMidiError();

bool isEqualCommands(MIDI_Command_t commandRecieved, MIDI_Command_t commandSaved)
{
	if(commandRecieved.status != commandSaved.status) return false;
    1296:	80 e0       	ldi	r24, 0x00	; 0
    1298:	08 95       	ret
	if(commandRecieved.data1 != commandSaved.data2) return false;	
	return true;
    129a:	81 e0       	ldi	r24, 0x01	; 1
}
    129c:	08 95       	ret

Disassembly of section .text.loadCommSetFromMemory:

00000a02 <loadCommSetFromMemory>:

void loadCommSetFromMemory()
{
 a02:	cf 93       	push	r28
 a04:	df 93       	push	r29
 a06:	cd b7       	in	r28, 0x3d	; 61
 a08:	de b7       	in	r29, 0x3e	; 62
 a0a:	68 97       	sbiw	r28, 0x18	; 24
 a0c:	0f b6       	in	r0, 0x3f	; 63
 a0e:	f8 94       	cli
 a10:	de bf       	out	0x3e, r29	; 62
 a12:	0f be       	out	0x3f, r0	; 63
 a14:	cd bf       	out	0x3d, r28	; 61
	uint16_t readedMagicWord = eeprom_read_word(0x00);
 a16:	60 e0       	ldi	r22, 0x00	; 0
 a18:	70 e0       	ldi	r23, 0x00	; 0
 a1a:	80 e0       	ldi	r24, 0x00	; 0
 a1c:	82 d4       	rcall	.+2308   	; 0x1322 <eeprom_read_word>
		
	if(readedMagicWord == MEMORY_MAGIC_WORD)
 a1e:	8b 3a       	cpi	r24, 0xAB	; 171
 a20:	9c 4a       	sbci	r25, 0xAC	; 172
 a22:	c1 f4       	brne	.+48     	; 0xa54 <loadCommSetFromMemory+0x52>
	{
		// memory is not empty. Load EEPROM values
		uint8_t readedData[sizeof(MIDICTRL_CommandBlock_t)];
		eeprom_read_block(&readedData, (uint16_t*)MEMORY_USER_COMMANDS_OFFSET, sizeof(MIDICTRL_CommandBlock_t));
 a24:	40 e1       	ldi	r20, 0x10	; 16
 a26:	50 e0       	ldi	r21, 0x00	; 0
 a28:	60 e8       	ldi	r22, 0x80	; 128
 a2a:	28 e1       	ldi	r18, 0x18	; 24
 a2c:	30 e0       	ldi	r19, 0x00	; 0
 a2e:	ce 01       	movw	r24, r28
 a30:	01 96       	adiw	r24, 0x01	; 1
 a32:	9c d3       	rcall	.+1848   	; 0x116c <eeprom_read_block>
		MIDICTRL_CommandBlock_t* userCommands_ptr = (MIDICTRL_CommandBlock_t*)readedData;
		userCommands = *userCommands_ptr;
 a34:	88 e1       	ldi	r24, 0x18	; 24
 a36:	fe 01       	movw	r30, r28
 a38:	31 96       	adiw	r30, 0x01	; 1
 a3a:	a8 e0       	ldi	r26, 0x08	; 8
 a3c:	b1 e0       	ldi	r27, 0x01	; 1
 a3e:	01 90       	ld	r0, Z+
 a40:	0d 92       	st	X+, r0
 a42:	8a 95       	dec	r24
 a44:	e1 f7       	brne	.-8      	; 0xa3e <loadCommSetFromMemory+0x3c>
			
		commandSet = eeprom_read_byte((uint8_t*)MEMORY_COMMAND_BLOCK_TYPE_OFFSET);
 a46:	6b e0       	ldi	r22, 0x0B	; 11
 a48:	70 e0       	ldi	r23, 0x00	; 0
 a4a:	80 e8       	ldi	r24, 0x80	; 128
 a4c:	3b d4       	rcall	.+2166   	; 0x12c4 <eeprom_read_byte>
 a4e:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <commandSet>
 a52:	0b c0       	rjmp	.+22     	; 0xa6a <loadCommSetFromMemory+0x68>
	}
	else
	{
		// memory empty. Load default values
		userCommands = defaultCommands;
 a54:	88 e1       	ldi	r24, 0x18	; 24
 a56:	e6 e8       	ldi	r30, 0x86	; 134
 a58:	f1 e0       	ldi	r31, 0x01	; 1
 a5a:	a8 e0       	ldi	r26, 0x08	; 8
 a5c:	b1 e0       	ldi	r27, 0x01	; 1
 a5e:	01 90       	ld	r0, Z+
 a60:	0d 92       	st	X+, r0
 a62:	8a 95       	dec	r24
 a64:	e1 f7       	brne	.-8      	; 0xa5e <loadCommSetFromMemory+0x5c>
		commandSet = DEFAULT;
 a66:	10 92 21 01 	sts	0x0121, r1	; 0x800121 <commandSet>
	}
}
 a6a:	68 96       	adiw	r28, 0x18	; 24
 a6c:	0f b6       	in	r0, 0x3f	; 63
 a6e:	f8 94       	cli
 a70:	de bf       	out	0x3e, r29	; 62
 a72:	0f be       	out	0x3f, r0	; 63
 a74:	cd bf       	out	0x3d, r28	; 61
 a76:	df 91       	pop	r29
 a78:	cf 91       	pop	r28
 a7a:	08 95       	ret

Disassembly of section .text.setMidiLeds:

00000c66 <setMidiLeds>:

void setMidiLeds()
{
 c66:	cf 93       	push	r28
	if(mode == PROGRAMMING)
 c68:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <mode>
 c6c:	81 30       	cpi	r24, 0x01	; 1
 c6e:	11 f5       	brne	.+68     	; 0xcb4 <setMidiLeds+0x4e>
 c70:	18 c0       	rjmp	.+48     	; 0xca2 <setMidiLeds+0x3c>
	{
		for(uint8_t i=0; i<MIDI_PROG_BTN_COUNT; i++)
		{
			switch(midiProgBtnState[i])
 c72:	ec 2f       	mov	r30, r28
 c74:	f0 e0       	ldi	r31, 0x00	; 0
 c76:	ef 5f       	subi	r30, 0xFF	; 255
 c78:	fe 4f       	sbci	r31, 0xFE	; 254
 c7a:	80 81       	ld	r24, Z
 c7c:	81 30       	cpi	r24, 0x01	; 1
 c7e:	41 f0       	breq	.+16     	; 0xc90 <setMidiLeds+0x2a>
 c80:	18 f0       	brcs	.+6      	; 0xc88 <setMidiLeds+0x22>
 c82:	82 30       	cpi	r24, 0x02	; 2
 c84:	49 f0       	breq	.+18     	; 0xc98 <setMidiLeds+0x32>
 c86:	0b c0       	rjmp	.+22     	; 0xc9e <setMidiLeds+0x38>
			{
				case PROG_CLEAR: SH100HW_SetNewLedState(i, LED_OFF); break;
 c88:	60 e0       	ldi	r22, 0x00	; 0
 c8a:	8c 2f       	mov	r24, r28
 c8c:	56 d1       	rcall	.+684    	; 0xf3a <SH100HW_SetNewLedState>
 c8e:	07 c0       	rjmp	.+14     	; 0xc9e <setMidiLeds+0x38>
				case PROG_ACTING: SH100HW_SetNewLedState(i, LED_FAST_BLINKING); break;
 c90:	62 e0       	ldi	r22, 0x02	; 2
 c92:	8c 2f       	mov	r24, r28
 c94:	52 d1       	rcall	.+676    	; 0xf3a <SH100HW_SetNewLedState>
 c96:	03 c0       	rjmp	.+6      	; 0xc9e <setMidiLeds+0x38>
				case PROG_PROGRAMMED: SH100HW_SetNewLedState(i, LED_ON); break;
 c98:	61 e0       	ldi	r22, 0x01	; 1
 c9a:	8c 2f       	mov	r24, r28
 c9c:	4e d1       	rcall	.+668    	; 0xf3a <SH100HW_SetNewLedState>

void setMidiLeds()
{
	if(mode == PROGRAMMING)
	{
		for(uint8_t i=0; i<MIDI_PROG_BTN_COUNT; i++)
 c9e:	cf 5f       	subi	r28, 0xFF	; 255
 ca0:	01 c0       	rjmp	.+2      	; 0xca4 <setMidiLeds+0x3e>
 ca2:	c0 e0       	ldi	r28, 0x00	; 0
 ca4:	c6 30       	cpi	r28, 0x06	; 6
 ca6:	28 f3       	brcs	.-54     	; 0xc72 <setMidiLeds+0xc>
				case PROG_ACTING: SH100HW_SetNewLedState(i, LED_FAST_BLINKING); break;
				case PROG_PROGRAMMED: SH100HW_SetNewLedState(i, LED_ON); break;
			}
		}
		
		if(currentErrBtnId != MIDI_PROG_BTN_UNDEFINED)
 ca8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 cac:	8f 3f       	cpi	r24, 0xFF	; 255
 cae:	11 f0       	breq	.+4      	; 0xcb4 <setMidiLeds+0x4e>
		{
			SH100HW_SetNewLedState(currentErrBtnId, LED_ON);
 cb0:	61 e0       	ldi	r22, 0x01	; 1
 cb2:	43 d1       	rcall	.+646    	; 0xf3a <SH100HW_SetNewLedState>
		}
	}
}
 cb4:	cf 91       	pop	r28
 cb6:	08 95       	ret

Disassembly of section .text.MIDICTRL_Init:

000010aa <MIDICTRL_Init>:

void MIDICTRL_Init()
{
	// Timer1 init. For error indication
	TCCR1B |= 0x05; // psc = 1024
    10aa:	e1 e8       	ldi	r30, 0x81	; 129
    10ac:	f0 e0       	ldi	r31, 0x00	; 0
    10ae:	80 81       	ld	r24, Z
    10b0:	85 60       	ori	r24, 0x05	; 5
    10b2:	80 83       	st	Z, r24
	TIMSK1 |= 0x01; // OVF INT enable, count pulse = 100us
    10b4:	ef e6       	ldi	r30, 0x6F	; 111
    10b6:	f0 e0       	ldi	r31, 0x00	; 0
    10b8:	80 81       	ld	r24, Z
    10ba:	81 60       	ori	r24, 0x01	; 1
    10bc:	80 83       	st	Z, r24
	TCNT1 = 0;
    10be:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__TEXT_REGION_LENGTH__+0x7fe085>
    10c2:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__TEXT_REGION_LENGTH__+0x7fe084>
	
	currentErrBtnId = MIDI_PROG_BTN_UNDEFINED;
    10c6:	8f ef       	ldi	r24, 0xFF	; 255
    10c8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
	
	loadCommSetFromMemory();
    10cc:	9a dc       	rcall	.-1740   	; 0xa02 <loadCommSetFromMemory>
	mode = RUNNING;
    10ce:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <mode>
    10d2:	08 95       	ret

Disassembly of section .text.MIDICTRL_MidiMode:

0000134a <MIDICTRL_MidiMode>:
}

MIDICTRL_Mode_t MIDICTRL_MidiMode()
{
	return mode;
}
    134a:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <mode>
    134e:	08 95       	ret

Disassembly of section .text.MIDICTRL_SetProgrammingButton:

0000107c <MIDICTRL_SetProgrammingButton>:

void MIDICTRL_SetProgrammingButton(uint8_t progBtnId)
{
	if(midiProgBtnState[currentProgBtn] == PROG_ACTING) 
    107c:	20 91 20 01 	lds	r18, 0x0120	; 0x800120 <currentProgBtn>
    1080:	30 e0       	ldi	r19, 0x00	; 0
    1082:	f9 01       	movw	r30, r18
    1084:	ef 5f       	subi	r30, 0xFF	; 255
    1086:	fe 4f       	sbci	r31, 0xFE	; 254
    1088:	90 81       	ld	r25, Z
    108a:	91 30       	cpi	r25, 0x01	; 1
    108c:	21 f4       	brne	.+8      	; 0x1096 <MIDICTRL_SetProgrammingButton+0x1a>
	{
		midiProgBtnState[currentProgBtn] = PROG_CLEAR;
    108e:	f9 01       	movw	r30, r18
    1090:	ef 5f       	subi	r30, 0xFF	; 255
    1092:	fe 4f       	sbci	r31, 0xFE	; 254
    1094:	10 82       	st	Z, r1
	}
	
	currentProgBtn = progBtnId;
    1096:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <currentProgBtn>
	midiProgBtnState[currentProgBtn] = PROG_ACTING;
    109a:	e8 2f       	mov	r30, r24
    109c:	f0 e0       	ldi	r31, 0x00	; 0
    109e:	ef 5f       	subi	r30, 0xFF	; 255
    10a0:	fe 4f       	sbci	r31, 0xFE	; 254
    10a2:	81 e0       	ldi	r24, 0x01	; 1
    10a4:	80 83       	st	Z, r24
	setMidiLeds();
    10a6:	df dd       	rcall	.-1090   	; 0xc66 <setMidiLeds>
    10a8:	08 95       	ret

Disassembly of section .text.MIDICTRL_SwitchMode:

00000e7a <MIDICTRL_SwitchMode>:
	loadCommSetFromMemory();
	mode = RUNNING;
}

void MIDICTRL_SwitchMode(MIDICTRL_Mode_t newMode)
{	
 e7a:	cf 93       	push	r28
 e7c:	c8 2f       	mov	r28, r24
	if(mode == RUNNING)
 e7e:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <mode>
 e82:	81 11       	cpse	r24, r1
 e84:	15 c0       	rjmp	.+42     	; 0xeb0 <MIDICTRL_SwitchMode+0x36>
	{
		MIDI_SetRetranslateState(false);
 e86:	6d d2       	rcall	.+1242   	; 0x1362 <MIDI_SetRetranslateState>
		
		for(uint8_t i=0; i<MIDI_PROG_BTN_COUNT;i++) 
 e88:	80 e0       	ldi	r24, 0x00	; 0
 e8a:	06 c0       	rjmp	.+12     	; 0xe98 <MIDICTRL_SwitchMode+0x1e>
			midiProgBtnState[i] = PROG_CLEAR;
 e8c:	e8 2f       	mov	r30, r24
 e8e:	f0 e0       	ldi	r31, 0x00	; 0
 e90:	ef 5f       	subi	r30, 0xFF	; 255
 e92:	fe 4f       	sbci	r31, 0xFE	; 254
 e94:	10 82       	st	Z, r1
{	
	if(mode == RUNNING)
	{
		MIDI_SetRetranslateState(false);
		
		for(uint8_t i=0; i<MIDI_PROG_BTN_COUNT;i++) 
 e96:	8f 5f       	subi	r24, 0xFF	; 255
 e98:	86 30       	cpi	r24, 0x06	; 6
 e9a:	c0 f3       	brcs	.-16     	; 0xe8c <MIDICTRL_SwitchMode+0x12>
			midiProgBtnState[i] = PROG_CLEAR;
		
		MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH1);
 e9c:	80 e0       	ldi	r24, 0x00	; 0
 e9e:	ee d0       	rcall	.+476    	; 0x107c <MIDICTRL_SetProgrammingButton>
		setMidiLeds();
 ea0:	e2 de       	rcall	.-572    	; 0xc66 <setMidiLeds>
		
		SH100HW_SetNewLedState(LED_PWR_GRN, LED_SLOW_BLINKING);
 ea2:	63 e0       	ldi	r22, 0x03	; 3
 ea4:	87 e0       	ldi	r24, 0x07	; 7
 ea6:	49 d0       	rcall	.+146    	; 0xf3a <SH100HW_SetNewLedState>
		SH100HW_SetNewLedState(LED_PWR_RED, LED_SLOW_BLINKING);
 ea8:	63 e0       	ldi	r22, 0x03	; 3
 eaa:	88 e0       	ldi	r24, 0x08	; 8
 eac:	46 d0       	rcall	.+140    	; 0xf3a <SH100HW_SetNewLedState>
 eae:	02 c0       	rjmp	.+4      	; 0xeb4 <MIDICTRL_SwitchMode+0x3a>
	}
	else
	{
		MIDI_SetRetranslateState(true);
 eb0:	81 e0       	ldi	r24, 0x01	; 1
 eb2:	57 d2       	rcall	.+1198   	; 0x1362 <MIDI_SetRetranslateState>
	}
	mode = newMode;
 eb4:	c0 93 07 01 	sts	0x0107, r28	; 0x800107 <mode>
}
 eb8:	cf 91       	pop	r28
 eba:	08 95       	ret

Disassembly of section .text.MIDICTRL_SetMidiChannel:

00001350 <MIDICTRL_SetMidiChannel>:
	setMidiLeds();
}

void MIDICTRL_SetMidiChannel(uint8_t midiChNum)
{
	channelNum = midiChNum;
    1350:	80 93 aa 01 	sts	0x01AA, r24	; 0x8001aa <channelNum>
    1354:	08 95       	ret

Disassembly of section .text.MIDICTRL_OmniModeEn:

00001356 <MIDICTRL_OmniModeEn>:
}

void MIDICTRL_OmniModeEn(bool isEnabled)
{
	omniModeEnabled = isEnabled;
    1356:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <omniModeEnabled>
    135a:	08 95       	ret

Disassembly of section .text.MIDICTRL_MuteCommEn:

0000135c <MIDICTRL_MuteCommEn>:
}

void MIDICTRL_MuteCommEn(bool isEnabled)
{
	muteCommandEnabled = isEnabled;
    135c:	80 93 ab 01 	sts	0x01AB, r24	; 0x8001ab <muteCommandEnabled>
    1360:	08 95       	ret

Disassembly of section .text.programmBtn:

00000d54 <programmBtn>:
}

void programmBtn(MIDI_Command_t* targetComm, const MIDI_Command_t* srcComm, uint8_t targetBtnId)
{
 d54:	cf 92       	push	r12
 d56:	df 92       	push	r13
 d58:	ef 92       	push	r14
 d5a:	dc 01       	movw	r26, r24
	if(midiProgBtnState[targetBtnId] == PROG_ACTING)
 d5c:	30 e0       	ldi	r19, 0x00	; 0
 d5e:	f9 01       	movw	r30, r18
 d60:	ef 5f       	subi	r30, 0xFF	; 255
 d62:	fe 4f       	sbci	r31, 0xFE	; 254
 d64:	90 81       	ld	r25, Z
 d66:	91 30       	cpi	r25, 0x01	; 1
 d68:	b9 f4       	brne	.+46     	; 0xd98 <programmBtn+0x44>
 d6a:	6a 01       	movw	r12, r20
 d6c:	e6 2e       	mov	r14, r22
	{
		targetComm->status = srcComm->status;
 d6e:	fa 01       	movw	r30, r20
 d70:	84 91       	lpm	r24, Z
 d72:	e7 fc       	sbrc	r14, 7
 d74:	80 81       	ld	r24, Z
 d76:	8c 93       	st	X, r24
		targetComm->data1 = srcComm->data1;
 d78:	82 e0       	ldi	r24, 0x02	; 2
 d7a:	c8 0e       	add	r12, r24
 d7c:	d1 1c       	adc	r13, r1
 d7e:	e1 1c       	adc	r14, r1
 d80:	f6 01       	movw	r30, r12
 d82:	84 91       	lpm	r24, Z
 d84:	e7 fc       	sbrc	r14, 7
 d86:	80 81       	ld	r24, Z
 d88:	12 96       	adiw	r26, 0x02	; 2
 d8a:	8c 93       	st	X, r24
		midiProgBtnState[targetBtnId] = PROG_PROGRAMMED;
 d8c:	f9 01       	movw	r30, r18
 d8e:	ef 5f       	subi	r30, 0xFF	; 255
 d90:	fe 4f       	sbci	r31, 0xFE	; 254
 d92:	82 e0       	ldi	r24, 0x02	; 2
 d94:	80 83       	st	Z, r24
		setMidiLeds();
 d96:	67 df       	rcall	.-306    	; 0xc66 <setMidiLeds>
	}
}
 d98:	ef 90       	pop	r14
 d9a:	df 90       	pop	r13
 d9c:	cf 90       	pop	r12
 d9e:	08 95       	ret

Disassembly of section .text.MIDICTRL_StoreUserCommands:

00000faa <MIDICTRL_StoreUserCommands>:
	}	
}

void MIDICTRL_StoreUserCommands()
{
	if(mode == PROGRAMMING)
 faa:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <mode>
 fae:	81 30       	cpi	r24, 0x01	; 1
 fb0:	b1 f4       	brne	.+44     	; 0xfde <MIDICTRL_StoreUserCommands+0x34>
	{
		commandSet = USER;
 fb2:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <commandSet>
		
		eeprom_write_word(0x00, MEMORY_MAGIC_WORD);
 fb6:	6b ea       	ldi	r22, 0xAB	; 171
 fb8:	7c ea       	ldi	r23, 0xAC	; 172
 fba:	80 e0       	ldi	r24, 0x00	; 0
 fbc:	90 e0       	ldi	r25, 0x00	; 0
 fbe:	da d1       	rcall	.+948    	; 0x1374 <eeprom_write_word>
		eeprom_write_byte((void*)MEMORY_COMMAND_BLOCK_TYPE_OFFSET, commandSet);
 fc0:	60 91 21 01 	lds	r22, 0x0121	; 0x800121 <commandSet>
 fc4:	8b e0       	ldi	r24, 0x0B	; 11
 fc6:	90 e0       	ldi	r25, 0x00	; 0
 fc8:	16 d1       	rcall	.+556    	; 0x11f6 <eeprom_write_byte>
		eeprom_write_block(&userCommands, (void*)MEMORY_USER_COMMANDS_OFFSET, sizeof(MIDICTRL_CommandBlock_t));
 fca:	68 e0       	ldi	r22, 0x08	; 8
 fcc:	71 e0       	ldi	r23, 0x01	; 1
 fce:	80 e8       	ldi	r24, 0x80	; 128
 fd0:	28 e1       	ldi	r18, 0x18	; 24
 fd2:	30 e0       	ldi	r19, 0x00	; 0
 fd4:	4c e0       	ldi	r20, 0x0C	; 12
 fd6:	50 e0       	ldi	r21, 0x00	; 0
 fd8:	38 d0       	rcall	.+112    	; 0x104a <eeprom_write_block>
		
		mode = RUNNING;
 fda:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <mode>
 fde:	08 95       	ret

Disassembly of section .text.MIDICTRL_DiscardCommands:

0000129e <MIDICTRL_DiscardCommands>:
	}
}

void MIDICTRL_DiscardCommands()
{
	if(mode == PROGRAMMING)
    129e:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <mode>
    12a2:	81 30       	cpi	r24, 0x01	; 1
    12a4:	29 f4       	brne	.+10     	; 0x12b0 <MIDICTRL_DiscardCommands+0x12>
	{
		commandSet = DEFAULT;
    12a6:	10 92 21 01 	sts	0x0121, r1	; 0x800121 <commandSet>
		loadCommSetFromMemory();
    12aa:	ab db       	rcall	.-2218   	; 0xa02 <loadCommSetFromMemory>
		mode = RUNNING;
    12ac:	10 92 07 01 	sts	0x0107, r1	; 0x800107 <mode>
    12b0:	08 95       	ret

Disassembly of section .text.indicateMidiError:

00001148 <indicateMidiError>:
}

//===================ERROR indication=================
void indicateMidiError()
{
	TCNT1 = 100;
    1148:	84 e6       	ldi	r24, 0x64	; 100
    114a:	90 e0       	ldi	r25, 0x00	; 0
    114c:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <__TEXT_REGION_LENGTH__+0x7fe085>
    1150:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <__TEXT_REGION_LENGTH__+0x7fe084>
	currentErrBtnId = currentProgBtn;
    1154:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <currentProgBtn>
    1158:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
	setMidiLeds();
    115c:	84 dd       	rcall	.-1272   	; 0xc66 <setMidiLeds>
	
	SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
    115e:	60 e0       	ldi	r22, 0x00	; 0
    1160:	87 e0       	ldi	r24, 0x07	; 7
    1162:	eb de       	rcall	.-554    	; 0xf3a <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_PWR_RED, LED_ON);
    1164:	61 e0       	ldi	r22, 0x01	; 1
    1166:	88 e0       	ldi	r24, 0x08	; 8
    1168:	e8 de       	rcall	.-560    	; 0xf3a <SH100HW_SetNewLedState>
    116a:	08 95       	ret

Disassembly of section .text.MIDICTRL_HandleCommand:

000007e2 <MIDICTRL_HandleCommand>:
		setMidiLeds();
	}
}

void MIDICTRL_HandleCommand(MIDI_Command_t command)
{
 7e2:	cf 93       	push	r28
 7e4:	df 93       	push	r29
 7e6:	00 d0       	rcall	.+0      	; 0x7e8 <MIDICTRL_HandleCommand+0x6>
 7e8:	00 d0       	rcall	.+0      	; 0x7ea <MIDICTRL_HandleCommand+0x8>
 7ea:	cd b7       	in	r28, 0x3d	; 61
 7ec:	de b7       	in	r29, 0x3e	; 62
 7ee:	69 83       	std	Y+1, r22	; 0x01
 7f0:	7a 83       	std	Y+2, r23	; 0x02
 7f2:	8b 83       	std	Y+3, r24	; 0x03
 7f4:	9c 83       	std	Y+4, r25	; 0x04
	switch(mode)
 7f6:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <mode>
 7fa:	88 23       	and	r24, r24
 7fc:	19 f0       	breq	.+6      	; 0x804 <MIDICTRL_HandleCommand+0x22>
 7fe:	81 30       	cpi	r24, 0x01	; 1
 800:	d9 f1       	breq	.+118    	; 0x878 <MIDICTRL_HandleCommand+0x96>
 802:	8f c0       	rjmp	.+286    	; 0x922 <MIDICTRL_HandleCommand+0x140>
	{
		case RUNNING:
		{
			if(!omniModeEnabled)
 804:	80 91 ac 01 	lds	r24, 0x01AC	; 0x8001ac <omniModeEnabled>
 808:	81 11       	cpse	r24, r1
 80a:	05 c0       	rjmp	.+10     	; 0x816 <MIDICTRL_HandleCommand+0x34>
			{
				if(channelNum != command.channel) return;
 80c:	9a 81       	ldd	r25, Y+2	; 0x02
 80e:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <channelNum>
 812:	98 13       	cpse	r25, r24
 814:	86 c0       	rjmp	.+268    	; 0x922 <MIDICTRL_HandleCommand+0x140>
			}
			
			if(muteCommandEnabled)
 816:	80 91 ab 01 	lds	r24, 0x01AB	; 0x8001ab <muteCommandEnabled>
 81a:	88 23       	and	r24, r24
 81c:	a9 f0       	breq	.+42     	; 0x848 <MIDICTRL_HandleCommand+0x66>
			{
				if(isEqualCommands(command, muteCommand)) 
 81e:	8c ec       	ldi	r24, 0xCC	; 204
 820:	91 e0       	ldi	r25, 0x01	; 1
 822:	a0 e0       	ldi	r26, 0x00	; 0
 824:	fc 01       	movw	r30, r24
 826:	5a 2f       	mov	r21, r26
 828:	24 d5       	rcall	.+2632   	; 0x1272 <__xload_4>
 82a:	9b 01       	movw	r18, r22
 82c:	ac 01       	movw	r20, r24
 82e:	69 81       	ldd	r22, Y+1	; 0x01
 830:	7a 81       	ldd	r23, Y+2	; 0x02
 832:	8b 81       	ldd	r24, Y+3	; 0x03
 834:	9c 81       	ldd	r25, Y+4	; 0x04
 836:	29 d5       	rcall	.+2642   	; 0x128a <isEqualCommands>
 838:	88 23       	and	r24, r24
 83a:	31 f0       	breq	.+12     	; 0x848 <MIDICTRL_HandleCommand+0x66>
				{
					if(command.data2>0) SH100CTRL_MuteAmp();
 83c:	8c 81       	ldd	r24, Y+4	; 0x04
 83e:	88 23       	and	r24, r24
 840:	11 f0       	breq	.+4      	; 0x846 <MIDICTRL_HandleCommand+0x64>
 842:	92 d5       	rcall	.+2852   	; 0x1368 <SH100CTRL_MuteAmp>
 844:	01 c0       	rjmp	.+2      	; 0x848 <MIDICTRL_HandleCommand+0x66>
					else SH100CTRL_UnmuteAmp();
 846:	67 d5       	rcall	.+2766   	; 0x1316 <SH100CTRL_UnmuteAmp>
				}
			}
			
			MIDICTRL_CommandBlock_t* currentCommandBlock;
			if(commandSet == USER) currentCommandBlock = &userCommands;
 848:	80 91 21 01 	lds	r24, 0x0121	; 0x800121 <commandSet>
 84c:	81 30       	cpi	r24, 0x01	; 1
 84e:	19 f4       	brne	.+6      	; 0x856 <MIDICTRL_HandleCommand+0x74>
 850:	e8 e0       	ldi	r30, 0x08	; 8
 852:	f1 e0       	ldi	r31, 0x01	; 1
 854:	02 c0       	rjmp	.+4      	; 0x85a <MIDICTRL_HandleCommand+0x78>
			else currentCommandBlock = &defaultCommands;
 856:	e6 e8       	ldi	r30, 0x86	; 134
 858:	f1 e0       	ldi	r31, 0x01	; 1
			
			// priority ch1, ch2, ch3, ch4, loop, AB. After handling, return. Only one switch by one command
			if(isEqualCommands(command, currentCommandBlock->channel1)) SH100CTRL_SwChannel(0); return;
 85a:	20 81       	ld	r18, Z
 85c:	31 81       	ldd	r19, Z+1	; 0x01
 85e:	42 81       	ldd	r20, Z+2	; 0x02
 860:	53 81       	ldd	r21, Z+3	; 0x03
 862:	69 81       	ldd	r22, Y+1	; 0x01
 864:	7a 81       	ldd	r23, Y+2	; 0x02
 866:	8b 81       	ldd	r24, Y+3	; 0x03
 868:	9c 81       	ldd	r25, Y+4	; 0x04
 86a:	0f d5       	rcall	.+2590   	; 0x128a <isEqualCommands>
 86c:	88 23       	and	r24, r24
 86e:	09 f4       	brne	.+2      	; 0x872 <MIDICTRL_HandleCommand+0x90>
 870:	58 c0       	rjmp	.+176    	; 0x922 <MIDICTRL_HandleCommand+0x140>
 872:	80 e0       	ldi	r24, 0x00	; 0
 874:	5c d5       	rcall	.+2744   	; 0x132e <SH100CTRL_SwChannel>
 876:	55 c0       	rjmp	.+170    	; 0x922 <MIDICTRL_HandleCommand+0x140>
			break;
		}
		
		case PROGRAMMING:
		{
			if(command.status == MIDI_COMM_PROGRAM_CHANGE)
 878:	89 81       	ldd	r24, Y+1	; 0x01
 87a:	80 3c       	cpi	r24, 0xC0	; 192
 87c:	81 f5       	brne	.+96     	; 0x8de <MIDICTRL_HandleCommand+0xfc>
			{
				switch(currentProgBtn)
 87e:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <currentProgBtn>
 882:	81 30       	cpi	r24, 0x01	; 1
 884:	79 f0       	breq	.+30     	; 0x8a4 <MIDICTRL_HandleCommand+0xc2>
 886:	28 f0       	brcs	.+10     	; 0x892 <MIDICTRL_HandleCommand+0xb0>
 888:	82 30       	cpi	r24, 0x02	; 2
 88a:	a9 f0       	breq	.+42     	; 0x8b6 <MIDICTRL_HandleCommand+0xd4>
 88c:	83 30       	cpi	r24, 0x03	; 3
 88e:	e1 f0       	breq	.+56     	; 0x8c8 <MIDICTRL_HandleCommand+0xe6>
 890:	24 c0       	rjmp	.+72     	; 0x8da <MIDICTRL_HandleCommand+0xf8>
				{
					case MIDI_PROG_BTN_CH1: programmBtn(&(userCommands.channel1), &command, MIDI_PROG_BTN_CH1); break;
 892:	ae 01       	movw	r20, r28
 894:	4f 5f       	subi	r20, 0xFF	; 255
 896:	5f 4f       	sbci	r21, 0xFF	; 255
 898:	60 e8       	ldi	r22, 0x80	; 128
 89a:	20 e0       	ldi	r18, 0x00	; 0
 89c:	88 e0       	ldi	r24, 0x08	; 8
 89e:	91 e0       	ldi	r25, 0x01	; 1
 8a0:	59 d2       	rcall	.+1202   	; 0xd54 <programmBtn>
 8a2:	3f c0       	rjmp	.+126    	; 0x922 <MIDICTRL_HandleCommand+0x140>
					case MIDI_PROG_BTN_CH2: programmBtn(&(userCommands.channel2), &command, MIDI_PROG_BTN_CH2); break;
 8a4:	ae 01       	movw	r20, r28
 8a6:	4f 5f       	subi	r20, 0xFF	; 255
 8a8:	5f 4f       	sbci	r21, 0xFF	; 255
 8aa:	60 e8       	ldi	r22, 0x80	; 128
 8ac:	21 e0       	ldi	r18, 0x01	; 1
 8ae:	8c e0       	ldi	r24, 0x0C	; 12
 8b0:	91 e0       	ldi	r25, 0x01	; 1
 8b2:	50 d2       	rcall	.+1184   	; 0xd54 <programmBtn>
 8b4:	36 c0       	rjmp	.+108    	; 0x922 <MIDICTRL_HandleCommand+0x140>
					case MIDI_PROG_BTN_CH3: programmBtn(&(userCommands.channel3), &command, MIDI_PROG_BTN_CH3); break;
 8b6:	ae 01       	movw	r20, r28
 8b8:	4f 5f       	subi	r20, 0xFF	; 255
 8ba:	5f 4f       	sbci	r21, 0xFF	; 255
 8bc:	60 e8       	ldi	r22, 0x80	; 128
 8be:	22 e0       	ldi	r18, 0x02	; 2
 8c0:	80 e1       	ldi	r24, 0x10	; 16
 8c2:	91 e0       	ldi	r25, 0x01	; 1
 8c4:	47 d2       	rcall	.+1166   	; 0xd54 <programmBtn>
 8c6:	2d c0       	rjmp	.+90     	; 0x922 <MIDICTRL_HandleCommand+0x140>
					case MIDI_PROG_BTN_CH4: programmBtn(&(userCommands.channel4), &command, MIDI_PROG_BTN_CH4); break;
 8c8:	ae 01       	movw	r20, r28
 8ca:	4f 5f       	subi	r20, 0xFF	; 255
 8cc:	5f 4f       	sbci	r21, 0xFF	; 255
 8ce:	60 e8       	ldi	r22, 0x80	; 128
 8d0:	23 e0       	ldi	r18, 0x03	; 3
 8d2:	84 e1       	ldi	r24, 0x14	; 20
 8d4:	91 e0       	ldi	r25, 0x01	; 1
 8d6:	3e d2       	rcall	.+1148   	; 0xd54 <programmBtn>
 8d8:	24 c0       	rjmp	.+72     	; 0x922 <MIDICTRL_HandleCommand+0x140>
					default: indicateMidiError(); break; 
 8da:	36 d4       	rcall	.+2156   	; 0x1148 <indicateMidiError>
 8dc:	22 c0       	rjmp	.+68     	; 0x922 <MIDICTRL_HandleCommand+0x140>
				}
			}
			else if(command.status == MIDI_COMM_CONTROL_CHANGE)
 8de:	80 3b       	cpi	r24, 0xB0	; 176
 8e0:	f9 f4       	brne	.+62     	; 0x920 <MIDICTRL_HandleCommand+0x13e>
			{
				if(command.data1 == muteCommand.data1)
 8e2:	8b 81       	ldd	r24, Y+3	; 0x03
 8e4:	87 30       	cpi	r24, 0x07	; 7
 8e6:	11 f4       	brne	.+4      	; 0x8ec <MIDICTRL_HandleCommand+0x10a>
				{
					indicateMidiError();
 8e8:	2f d4       	rcall	.+2142   	; 0x1148 <indicateMidiError>
 8ea:	1b c0       	rjmp	.+54     	; 0x922 <MIDICTRL_HandleCommand+0x140>
				}
				else
				{
					switch(currentProgBtn)
 8ec:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <currentProgBtn>
 8f0:	84 30       	cpi	r24, 0x04	; 4
 8f2:	59 f0       	breq	.+22     	; 0x90a <MIDICTRL_HandleCommand+0x128>
 8f4:	85 30       	cpi	r24, 0x05	; 5
 8f6:	91 f4       	brne	.+36     	; 0x91c <MIDICTRL_HandleCommand+0x13a>
					{
						case MIDI_PROG_BTN_AB: programmBtn(&(userCommands.outAB), &command, MIDI_PROG_BTN_AB); break;
 8f8:	ae 01       	movw	r20, r28
 8fa:	4f 5f       	subi	r20, 0xFF	; 255
 8fc:	5f 4f       	sbci	r21, 0xFF	; 255
 8fe:	60 e8       	ldi	r22, 0x80	; 128
 900:	25 e0       	ldi	r18, 0x05	; 5
 902:	8c e1       	ldi	r24, 0x1C	; 28
 904:	91 e0       	ldi	r25, 0x01	; 1
 906:	26 d2       	rcall	.+1100   	; 0xd54 <programmBtn>
 908:	0c c0       	rjmp	.+24     	; 0x922 <MIDICTRL_HandleCommand+0x140>
						case MIDI_PROG_BTN_LOOP: programmBtn(&(userCommands.loopOn), &command, MIDI_PROG_BTN_LOOP); break;
 90a:	ae 01       	movw	r20, r28
 90c:	4f 5f       	subi	r20, 0xFF	; 255
 90e:	5f 4f       	sbci	r21, 0xFF	; 255
 910:	60 e8       	ldi	r22, 0x80	; 128
 912:	24 e0       	ldi	r18, 0x04	; 4
 914:	88 e1       	ldi	r24, 0x18	; 24
 916:	91 e0       	ldi	r25, 0x01	; 1
 918:	1d d2       	rcall	.+1082   	; 0xd54 <programmBtn>
 91a:	03 c0       	rjmp	.+6      	; 0x922 <MIDICTRL_HandleCommand+0x140>
						default: indicateMidiError(); break;
 91c:	15 d4       	rcall	.+2090   	; 0x1148 <indicateMidiError>
 91e:	01 c0       	rjmp	.+2      	; 0x922 <MIDICTRL_HandleCommand+0x140>
					}
				}
			}
			else
			{
				indicateMidiError();
 920:	13 d4       	rcall	.+2086   	; 0x1148 <indicateMidiError>
			}			
			break;
		}
	}	
}
 922:	0f 90       	pop	r0
 924:	0f 90       	pop	r0
 926:	0f 90       	pop	r0
 928:	0f 90       	pop	r0
 92a:	df 91       	pop	r29
 92c:	cf 91       	pop	r28
 92e:	08 95       	ret

Disassembly of section .text.__vector_13:

00000c12 <__vector_13>:
	SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
	SH100HW_SetNewLedState(LED_PWR_RED, LED_ON);
}

ISR(TIMER1_OVF_vect)
{
 c12:	1f 92       	push	r1
 c14:	0f 92       	push	r0
 c16:	0f b6       	in	r0, 0x3f	; 63
 c18:	0f 92       	push	r0
 c1a:	11 24       	eor	r1, r1
 c1c:	2f 93       	push	r18
 c1e:	3f 93       	push	r19
 c20:	4f 93       	push	r20
 c22:	5f 93       	push	r21
 c24:	6f 93       	push	r22
 c26:	7f 93       	push	r23
 c28:	8f 93       	push	r24
 c2a:	9f 93       	push	r25
 c2c:	af 93       	push	r26
 c2e:	bf 93       	push	r27
 c30:	ef 93       	push	r30
 c32:	ff 93       	push	r31
	currentErrBtnId = MIDI_PROG_BTN_UNDEFINED;
 c34:	8f ef       	ldi	r24, 0xFF	; 255
 c36:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__DATA_REGION_ORIGIN__>
	setMidiLeds();
 c3a:	15 d0       	rcall	.+42     	; 0xc66 <setMidiLeds>
	
	SH100HW_SetPreviousLedState(LED_PWR_GRN);
 c3c:	87 e0       	ldi	r24, 0x07	; 7
 c3e:	4a d2       	rcall	.+1172   	; 0x10d4 <SH100HW_SetPreviousLedState>
	SH100HW_SetPreviousLedState(LED_PWR_RED);
 c40:	88 e0       	ldi	r24, 0x08	; 8
 c42:	48 d2       	rcall	.+1168   	; 0x10d4 <SH100HW_SetPreviousLedState>
 c44:	ff 91       	pop	r31
 c46:	ef 91       	pop	r30
 c48:	bf 91       	pop	r27
 c4a:	af 91       	pop	r26
 c4c:	9f 91       	pop	r25
 c4e:	8f 91       	pop	r24
 c50:	7f 91       	pop	r23
 c52:	6f 91       	pop	r22
 c54:	5f 91       	pop	r21
 c56:	4f 91       	pop	r20
 c58:	3f 91       	pop	r19
 c5a:	2f 91       	pop	r18
 c5c:	0f 90       	pop	r0
 c5e:	0f be       	out	0x3f, r0	; 63
 c60:	0f 90       	pop	r0
 c62:	1f 90       	pop	r1
 c64:	18 95       	reti

Disassembly of section .text.handleRealTimeStatus:

0000137a <handleRealTimeStatus>:
	HADLE_SYS_EX
}state = RESET;

void handleRealTimeStatus(MIDI_Status_t status)
{
	UART_PushWord(status);
    137a:	5c dd       	rcall	.-1352   	; 0xe34 <UART_PushWord>
    137c:	08 95       	ret

Disassembly of section .text.MIDI_ParserTask:

0000068c <MIDI_ParserTask>:
};

uint8_t recievedWord;
void MIDI_ParserTask()
{
	switch(state)
 68c:	e0 91 ad 01 	lds	r30, 0x01AD	; 0x8001ad <state>
 690:	8e 2f       	mov	r24, r30
 692:	90 e0       	ldi	r25, 0x00	; 0
 694:	87 30       	cpi	r24, 0x07	; 7
 696:	91 05       	cpc	r25, r1
 698:	08 f0       	brcs	.+2      	; 0x69c <MIDI_ParserTask+0x10>
 69a:	a2 c0       	rjmp	.+324    	; 0x7e0 <MIDI_ParserTask+0x154>
 69c:	fc 01       	movw	r30, r24
 69e:	e6 56       	subi	r30, 0x66	; 102
 6a0:	ff 4f       	sbci	r31, 0xFF	; 255
 6a2:	09 94       	ijmp
	{
		case RESET:
		{
			currentCommand.status = MIDI_COMM_UNDEFINED;
 6a4:	e4 e2       	ldi	r30, 0x24	; 36
 6a6:	f1 e0       	ldi	r31, 0x01	; 1
 6a8:	10 82       	st	Z, r1
			currentCommand.data1 = 0;
 6aa:	12 82       	std	Z+2, r1	; 0x02
			currentCommand.data2 = 0;
 6ac:	13 82       	std	Z+3, r1	; 0x03
			currentStatusType = MIDI_TYPE_UNDEFINED;
 6ae:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <currentStatusType>
			isSecondDataWord = false;
 6b2:	10 92 23 01 	sts	0x0123, r1	; 0x800123 <isSecondDataWord>
			state = WAIT_WORD;
 6b6:	81 e0       	ldi	r24, 0x01	; 1
 6b8:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <state>
			break;
 6bc:	08 95       	ret
		}
		
		case WAIT_WORD:
		{
			if(UART_RxBufferNotEmpty())
 6be:	0b d6       	rcall	.+3094   	; 0x12d6 <UART_RxBufferNotEmpty>
 6c0:	88 23       	and	r24, r24
 6c2:	09 f4       	brne	.+2      	; 0x6c6 <MIDI_ParserTask+0x3a>
 6c4:	8d c0       	rjmp	.+282    	; 0x7e0 <MIDI_ParserTask+0x154>
			{
				recievedWord = UART_PopWord();
 6c6:	a7 d4       	rcall	.+2382   	; 0x1016 <UART_PopWord>
 6c8:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <recievedWord>
				if(MIDI_IsSysRealTime(recievedWord))
 6cc:	12 d6       	rcall	.+3108   	; 0x12f2 <MIDI_IsSysRealTime>
 6ce:	88 23       	and	r24, r24
 6d0:	21 f0       	breq	.+8      	; 0x6da <MIDI_ParserTask+0x4e>
				{ 
					handleRealTimeStatus((MIDI_Status_t)recievedWord);
 6d2:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <recievedWord>
 6d6:	51 d6       	rcall	.+3234   	; 0x137a <handleRealTimeStatus>
					return;
 6d8:	08 95       	ret
				}
				
				if(MIDI_IsStatusWord(recievedWord))
 6da:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <recievedWord>
 6de:	31 d6       	rcall	.+3170   	; 0x1342 <MIDI_IsStatusWord>
 6e0:	88 23       	and	r24, r24
 6e2:	21 f0       	breq	.+8      	; 0x6ec <MIDI_ParserTask+0x60>
				{					
					state = DISPATCH_STATUS;
 6e4:	82 e0       	ldi	r24, 0x02	; 2
 6e6:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <state>
 6ea:	20 c0       	rjmp	.+64     	; 0x72c <MIDI_ParserTask+0xa0>
				}
				else
				{
					switch(currentStatusType)
 6ec:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <currentStatusType>
 6f0:	82 30       	cpi	r24, 0x02	; 2
 6f2:	49 f0       	breq	.+18     	; 0x706 <MIDI_ParserTask+0x7a>
 6f4:	18 f4       	brcc	.+6      	; 0x6fc <MIDI_ParserTask+0x70>
 6f6:	81 30       	cpi	r24, 0x01	; 1
 6f8:	51 f0       	breq	.+20     	; 0x70e <MIDI_ParserTask+0x82>
 6fa:	15 c0       	rjmp	.+42     	; 0x726 <MIDI_ParserTask+0x9a>
 6fc:	84 30       	cpi	r24, 0x04	; 4
 6fe:	59 f0       	breq	.+22     	; 0x716 <MIDI_ParserTask+0x8a>
 700:	85 30       	cpi	r24, 0x05	; 5
 702:	69 f0       	breq	.+26     	; 0x71e <MIDI_ParserTask+0x92>
 704:	10 c0       	rjmp	.+32     	; 0x726 <MIDI_ParserTask+0x9a>
					{
						case MIDI_TYPE_TWO_BYTE: state = REC_TWO_BYTE; break;
 706:	84 e0       	ldi	r24, 0x04	; 4
 708:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <state>
 70c:	0f c0       	rjmp	.+30     	; 0x72c <MIDI_ParserTask+0xa0>
						case MIDI_TYPE_ONE_BYTE: state = REC_ONE_BYTE; break;
 70e:	83 e0       	ldi	r24, 0x03	; 3
 710:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <state>
 714:	0b c0       	rjmp	.+22     	; 0x72c <MIDI_ParserTask+0xa0>
						case MIDI_TYPE_START_SYS_EX: state = REC_SYS_EX; break;
 716:	85 e0       	ldi	r24, 0x05	; 5
 718:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <state>
 71c:	07 c0       	rjmp	.+14     	; 0x72c <MIDI_ParserTask+0xa0>
						case MIDI_TYPE_STOP_SYS_EX: state = HADLE_SYS_EX; break;
 71e:	86 e0       	ldi	r24, 0x06	; 6
 720:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <state>
 724:	03 c0       	rjmp	.+6      	; 0x72c <MIDI_ParserTask+0xa0>
						default: state = WAIT_WORD;
 726:	81 e0       	ldi	r24, 0x01	; 1
 728:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <state>
					}
				}
				
				if(retranslate)
 72c:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <retranslate>
 730:	88 23       	and	r24, r24
 732:	09 f4       	brne	.+2      	; 0x736 <MIDI_ParserTask+0xaa>
 734:	55 c0       	rjmp	.+170    	; 0x7e0 <MIDI_ParserTask+0x154>
				{
					UART_PushWord(recievedWord);
 736:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <recievedWord>
 73a:	7c d3       	rcall	.+1784   	; 0xe34 <UART_PushWord>
 73c:	08 95       	ret
			break;
		}
		
		case DISPATCH_STATUS:
		{
			currentCommand.status = (MIDI_Status_t)((recievedWord & 0xF0) >> 4);
 73e:	90 91 22 01 	lds	r25, 0x0122	; 0x800122 <recievedWord>
 742:	89 2f       	mov	r24, r25
 744:	82 95       	swap	r24
 746:	8f 70       	andi	r24, 0x0F	; 15
 748:	e4 e2       	ldi	r30, 0x24	; 36
 74a:	f1 e0       	ldi	r31, 0x01	; 1
 74c:	80 83       	st	Z, r24
			currentCommand.channel = recievedWord & 0x0F;
 74e:	9f 70       	andi	r25, 0x0F	; 15
 750:	91 83       	std	Z+1, r25	; 0x01
			currentCommand.data1 = 0;
 752:	12 82       	std	Z+2, r1	; 0x02
			currentCommand.data2 = 0;
 754:	13 82       	std	Z+3, r1	; 0x03
			currentStatusType = MIDI_GetStatusType(currentCommand.status);
 756:	b2 d3       	rcall	.+1892   	; 0xebc <MIDI_GetStatusType>
 758:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <currentStatusType>
			isSecondDataWord = false;
 75c:	10 92 23 01 	sts	0x0123, r1	; 0x800123 <isSecondDataWord>
			state = WAIT_WORD;
 760:	81 e0       	ldi	r24, 0x01	; 1
 762:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <state>
			break;
 766:	08 95       	ret
		}				
		
		case REC_TWO_BYTE:
		{
			if(isSecondDataWord)
 768:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <isSecondDataWord>
 76c:	88 23       	and	r24, r24
 76e:	81 f0       	breq	.+32     	; 0x790 <MIDI_ParserTask+0x104>
			{
				currentCommand.data2 = recievedWord;
 770:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <recievedWord>
 774:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <currentCommand+0x3>
				isSecondDataWord = false;			
 778:	10 92 23 01 	sts	0x0123, r1	; 0x800123 <isSecondDataWord>
				MIDICTRL_HandleCommand(currentCommand);
 77c:	60 91 24 01 	lds	r22, 0x0124	; 0x800124 <currentCommand>
 780:	70 91 25 01 	lds	r23, 0x0125	; 0x800125 <currentCommand+0x1>
 784:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <currentCommand+0x2>
 788:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <currentCommand+0x3>
 78c:	2a d0       	rcall	.+84     	; 0x7e2 <MIDICTRL_HandleCommand>
 78e:	07 c0       	rjmp	.+14     	; 0x79e <MIDI_ParserTask+0x112>
			}
			else
			{
				currentCommand.data1 = recievedWord;
 790:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <recievedWord>
 794:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <currentCommand+0x2>
				isSecondDataWord = true;
 798:	81 e0       	ldi	r24, 0x01	; 1
 79a:	80 93 23 01 	sts	0x0123, r24	; 0x800123 <isSecondDataWord>
			}
			state = WAIT_WORD;
 79e:	81 e0       	ldi	r24, 0x01	; 1
 7a0:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <state>
			break;
 7a4:	08 95       	ret
		}
		
		case REC_ONE_BYTE:
		{
			currentCommand.data1 = recievedWord;
 7a6:	80 91 22 01 	lds	r24, 0x0122	; 0x800122 <recievedWord>
 7aa:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <currentCommand+0x2>
			MIDICTRL_HandleCommand(currentCommand);
 7ae:	60 91 24 01 	lds	r22, 0x0124	; 0x800124 <currentCommand>
 7b2:	70 91 25 01 	lds	r23, 0x0125	; 0x800125 <currentCommand+0x1>
 7b6:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <currentCommand+0x2>
 7ba:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <currentCommand+0x3>
 7be:	11 d0       	rcall	.+34     	; 0x7e2 <MIDICTRL_HandleCommand>
			state = WAIT_WORD;
 7c0:	81 e0       	ldi	r24, 0x01	; 1
 7c2:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <state>
			break;
 7c6:	08 95       	ret
		}
		
		case REC_SYS_EX:
		{
			state = WAIT_WORD;
 7c8:	81 e0       	ldi	r24, 0x01	; 1
 7ca:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <state>
			break;
 7ce:	08 95       	ret
		}
		
		case HADLE_SYS_EX:
		{
			currentCommand.status = MIDI_COMM_UNDEFINED;
 7d0:	e4 e2       	ldi	r30, 0x24	; 36
 7d2:	f1 e0       	ldi	r31, 0x01	; 1
 7d4:	10 82       	st	Z, r1
			currentCommand.data1 = 0;
 7d6:	12 82       	std	Z+2, r1	; 0x02
			currentCommand.data2 = 0;
 7d8:	13 82       	std	Z+3, r1	; 0x03
			state = WAIT_WORD;
 7da:	81 e0       	ldi	r24, 0x01	; 1
 7dc:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <state>
 7e0:	08 95       	ret

Disassembly of section .text.MIDI_SetRetranslateState:

00001362 <MIDI_SetRetranslateState>:
	}
}

void MIDI_SetRetranslateState(bool enabled)
{
	retranslate = enabled;
    1362:	80 93 ae 01 	sts	0x01AE, r24	; 0x8001ae <retranslate>
    1366:	08 95       	ret

Disassembly of section .text.setChannelLeds:

000011b2 <setChannelLeds>:
	SH100CTRL_SetAmpState(ampState);
}

void setChannelLeds()
{
	SH100HW_SetNewLedState(LED_CH1, LED_OFF);
    11b2:	60 e0       	ldi	r22, 0x00	; 0
    11b4:	80 e0       	ldi	r24, 0x00	; 0
    11b6:	c1 de       	rcall	.-638    	; 0xf3a <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_CH2, LED_OFF);
    11b8:	60 e0       	ldi	r22, 0x00	; 0
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	be de       	rcall	.-644    	; 0xf3a <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_CH3, LED_OFF);
    11be:	60 e0       	ldi	r22, 0x00	; 0
    11c0:	82 e0       	ldi	r24, 0x02	; 2
    11c2:	bb de       	rcall	.-650    	; 0xf3a <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_CH4, LED_OFF);
    11c4:	60 e0       	ldi	r22, 0x00	; 0
    11c6:	83 e0       	ldi	r24, 0x03	; 3
    11c8:	b8 de       	rcall	.-656    	; 0xf3a <SH100HW_SetNewLedState>
	
	SH100HW_SetNewLedState(ampState.channelNum, LED_ON);
    11ca:	61 e0       	ldi	r22, 0x01	; 1
    11cc:	80 91 29 01 	lds	r24, 0x0129	; 0x800129 <ampState>
    11d0:	b4 de       	rcall	.-664    	; 0xf3a <SH100HW_SetNewLedState>
    11d2:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetAmpLeds:

000010fc <SH100CTRL_SetAmpLeds>:
}

void SH100CTRL_SetAmpLeds()
{
    10fc:	cf 93       	push	r28
    10fe:	df 93       	push	r29
	setChannelLeds();
    1100:	58 d0       	rcall	.+176    	; 0x11b2 <setChannelLeds>
	SH100HW_SetNewLedState(LED_LOOP, ampState.loopOn);
    1102:	c9 e2       	ldi	r28, 0x29	; 41
    1104:	d1 e0       	ldi	r29, 0x01	; 1
    1106:	69 81       	ldd	r22, Y+1	; 0x01
    1108:	85 e0       	ldi	r24, 0x05	; 5
    110a:	17 df       	rcall	.-466    	; 0xf3a <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_A, !ampState.swAB);
    110c:	6a 81       	ldd	r22, Y+2	; 0x02
    110e:	81 e0       	ldi	r24, 0x01	; 1
    1110:	68 27       	eor	r22, r24
    1112:	86 e0       	ldi	r24, 0x06	; 6
    1114:	12 df       	rcall	.-476    	; 0xf3a <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_B, ampState.swAB);
    1116:	6a 81       	ldd	r22, Y+2	; 0x02
    1118:	87 e0       	ldi	r24, 0x07	; 7
    111a:	0f df       	rcall	.-482    	; 0xf3a <SH100HW_SetNewLedState>
}
    111c:	df 91       	pop	r29
    111e:	cf 91       	pop	r28
    1120:	08 95       	ret

Disassembly of section .text.SH100CTRL_SwChannel:

0000132e <SH100CTRL_SwChannel>:

void SH100CTRL_SwChannel(uint8_t chNum)
{
	ampState.channelNum = chNum;
    132e:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <ampState>
	
	SH100HW_SwitchCh(chNum);
    1332:	c2 dc       	rcall	.-1660   	; 0xcb8 <SH100HW_SwitchCh>
	setChannelLeds();
    1334:	3e df       	rcall	.-388    	; 0x11b2 <setChannelLeds>
    1336:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetLoop:

00001212 <SH100CTRL_SetLoop>:
}

void SH100CTRL_SetLoop(bool en)
{
    1212:	cf 93       	push	r28
    1214:	df 93       	push	r29
	ampState.loopOn = en;
    1216:	c9 e2       	ldi	r28, 0x29	; 41
    1218:	d1 e0       	ldi	r29, 0x01	; 1
    121a:	89 83       	std	Y+1, r24	; 0x01
	SH100HW_LoopEn(ampState.loopOn);
    121c:	06 d0       	rcall	.+12     	; 0x122a <SH100HW_LoopEn>
	SH100HW_SetNewLedState(LED_LOOP, ampState.loopOn);
    121e:	69 81       	ldd	r22, Y+1	; 0x01
    1220:	85 e0       	ldi	r24, 0x05	; 5
    1222:	8b de       	rcall	.-746    	; 0xf3a <SH100HW_SetNewLedState>
}
    1224:	df 91       	pop	r29
    1226:	cf 91       	pop	r28
    1228:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetAB:

000011d4 <SH100CTRL_SetAB>:

void SH100CTRL_SetAB(bool isB)
{
    11d4:	cf 93       	push	r28
    11d6:	df 93       	push	r29
	ampState.swAB = isB;
    11d8:	c9 e2       	ldi	r28, 0x29	; 41
    11da:	d1 e0       	ldi	r29, 0x01	; 1
    11dc:	8a 83       	std	Y+2, r24	; 0x02
	SH100HW_SwitchAB(ampState.swAB);
    11de:	c7 d0       	rcall	.+398    	; 0x136e <SH100HW_SwitchAB>
	SH100HW_SetNewLedState(LED_A, !ampState.swAB);
    11e0:	6a 81       	ldd	r22, Y+2	; 0x02
    11e2:	81 e0       	ldi	r24, 0x01	; 1
    11e4:	68 27       	eor	r22, r24
    11e6:	86 e0       	ldi	r24, 0x06	; 6
    11e8:	a8 de       	rcall	.-688    	; 0xf3a <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_B, ampState.swAB);
    11ea:	6a 81       	ldd	r22, Y+2	; 0x02
    11ec:	87 e0       	ldi	r24, 0x07	; 7
    11ee:	a5 de       	rcall	.-694    	; 0xf3a <SH100HW_SetNewLedState>
}
    11f0:	df 91       	pop	r29
    11f2:	cf 91       	pop	r28
    11f4:	08 95       	ret

Disassembly of section .text.SH100CTRL_SwLoop:

000012fe <SH100CTRL_SwLoop>:

void SH100CTRL_SwLoop()
{
	SH100CTRL_SetLoop(!ampState.loopOn);
    12fe:	90 91 2a 01 	lds	r25, 0x012A	; 0x80012a <ampState+0x1>
    1302:	81 e0       	ldi	r24, 0x01	; 1
    1304:	89 27       	eor	r24, r25
    1306:	85 df       	rcall	.-246    	; 0x1212 <SH100CTRL_SetLoop>
    1308:	08 95       	ret

Disassembly of section .text.SH100CTRL_SwAB:

0000130a <SH100CTRL_SwAB>:
}

void SH100CTRL_SwAB()
{
	SH100CTRL_SetAB(!ampState.swAB);
    130a:	90 91 2b 01 	lds	r25, 0x012B	; 0x80012b <ampState+0x2>
    130e:	81 e0       	ldi	r24, 0x01	; 1
    1310:	89 27       	eor	r24, r25
    1312:	60 df       	rcall	.-320    	; 0x11d4 <SH100CTRL_SetAB>
    1314:	08 95       	ret

Disassembly of section .text.SH100CTRL_MuteAmp:

00001368 <SH100CTRL_MuteAmp>:
}

void SH100CTRL_MuteAmp()
{
	SH100HW_SetPAState(false);
    1368:	80 e0       	ldi	r24, 0x00	; 0
    136a:	db de       	rcall	.-586    	; 0x1122 <SH100HW_SetPAState>
    136c:	08 95       	ret

Disassembly of section .text.SH100CTRL_UnmuteAmp:

00001316 <SH100CTRL_UnmuteAmp>:
}

void SH100CTRL_UnmuteAmp()
{
	if(SH100HW_GetOutputJacks() != OUT_NONE)
    1316:	95 df       	rcall	.-214    	; 0x1242 <SH100HW_GetOutputJacks>
    1318:	88 23       	and	r24, r24
    131a:	11 f0       	breq	.+4      	; 0x1320 <SH100CTRL_UnmuteAmp+0xa>
	{
		SH100HW_SetPAState(true);	
    131c:	81 e0       	ldi	r24, 0x01	; 1
    131e:	01 df       	rcall	.-510    	; 0x1122 <SH100HW_SetPAState>
    1320:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetAmpState:

00000efc <SH100CTRL_SetAmpState>:
	}		
}

void SH100CTRL_SetAmpState(SH100_State_t state)
{
 efc:	cf 93       	push	r28
 efe:	df 93       	push	r29
	ampState = state;
 f00:	60 93 29 01 	sts	0x0129, r22	; 0x800129 <ampState>
 f04:	70 93 2a 01 	sts	0x012A, r23	; 0x80012a <ampState+0x1>
 f08:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <ampState+0x2>
	
	SH100HW_SwitchCh(ampState.channelNum);
 f0c:	c9 e2       	ldi	r28, 0x29	; 41
 f0e:	d1 e0       	ldi	r29, 0x01	; 1
 f10:	86 2f       	mov	r24, r22
 f12:	d2 de       	rcall	.-604    	; 0xcb8 <SH100HW_SwitchCh>
	SH100HW_LoopEn(ampState.loopOn);
 f14:	89 81       	ldd	r24, Y+1	; 0x01
 f16:	89 d1       	rcall	.+786    	; 0x122a <SH100HW_LoopEn>
	SH100HW_SwitchAB(ampState.swAB);
 f18:	8a 81       	ldd	r24, Y+2	; 0x02
 f1a:	29 d2       	rcall	.+1106   	; 0x136e <SH100HW_SwitchAB>
	
	setChannelLeds();
 f1c:	4a d1       	rcall	.+660    	; 0x11b2 <setChannelLeds>
	SH100HW_SetNewLedState(LED_LOOP, ampState.loopOn);
 f1e:	69 81       	ldd	r22, Y+1	; 0x01
 f20:	85 e0       	ldi	r24, 0x05	; 5
 f22:	0b d0       	rcall	.+22     	; 0xf3a <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_A, !ampState.swAB);
 f24:	6a 81       	ldd	r22, Y+2	; 0x02
 f26:	81 e0       	ldi	r24, 0x01	; 1
 f28:	68 27       	eor	r22, r24
 f2a:	86 e0       	ldi	r24, 0x06	; 6
 f2c:	06 d0       	rcall	.+12     	; 0xf3a <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_B, ampState.swAB);
 f2e:	6a 81       	ldd	r22, Y+2	; 0x02
 f30:	87 e0       	ldi	r24, 0x07	; 7
 f32:	03 d0       	rcall	.+6      	; 0xf3a <SH100HW_SetNewLedState>
}
 f34:	df 91       	pop	r29
 f36:	cf 91       	pop	r28
 f38:	08 95       	ret

Disassembly of section .text.SH100CTRL_Init:

00000b50 <SH100CTRL_Init>:

void SH100CTRL_StoreAmpState()
{
	eeprom_write_block(&ampState, (void*)MEMORY_AMP_STATE_OFFSET, sizeof(SH100_State_t));
 b50:	cf 93       	push	r28
 b52:	df 93       	push	r29
 b54:	00 d0       	rcall	.+0      	; 0xb56 <SH100CTRL_Init+0x6>
 b56:	0f 92       	push	r0
 b58:	cd b7       	in	r28, 0x3d	; 61
 b5a:	de b7       	in	r29, 0x3e	; 62
 b5c:	60 e0       	ldi	r22, 0x00	; 0
 b5e:	70 e0       	ldi	r23, 0x00	; 0
 b60:	80 e0       	ldi	r24, 0x00	; 0
 b62:	df d3       	rcall	.+1982   	; 0x1322 <eeprom_read_word>
 b64:	8b 3a       	cpi	r24, 0xAB	; 171
 b66:	9c 4a       	sbci	r25, 0xAC	; 172
 b68:	91 f4       	brne	.+36     	; 0xb8e <SH100CTRL_Init+0x3e>
 b6a:	40 e1       	ldi	r20, 0x10	; 16
 b6c:	50 e0       	ldi	r21, 0x00	; 0
 b6e:	60 e8       	ldi	r22, 0x80	; 128
 b70:	23 e0       	ldi	r18, 0x03	; 3
 b72:	30 e0       	ldi	r19, 0x00	; 0
 b74:	ce 01       	movw	r24, r28
 b76:	01 96       	adiw	r24, 0x01	; 1
 b78:	f9 d2       	rcall	.+1522   	; 0x116c <eeprom_read_block>
 b7a:	89 81       	ldd	r24, Y+1	; 0x01
 b7c:	9a 81       	ldd	r25, Y+2	; 0x02
 b7e:	ab 81       	ldd	r26, Y+3	; 0x03
 b80:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <ampState>
 b84:	90 93 2a 01 	sts	0x012A, r25	; 0x80012a <ampState+0x1>
 b88:	a0 93 2b 01 	sts	0x012B, r26	; 0x80012b <ampState+0x2>
 b8c:	05 c0       	rjmp	.+10     	; 0xb98 <SH100CTRL_Init+0x48>
 b8e:	e9 e2       	ldi	r30, 0x29	; 41
 b90:	f1 e0       	ldi	r31, 0x01	; 1
 b92:	10 82       	st	Z, r1
 b94:	11 82       	std	Z+1, r1	; 0x01
 b96:	12 82       	std	Z+2, r1	; 0x02
 b98:	60 91 29 01 	lds	r22, 0x0129	; 0x800129 <ampState>
 b9c:	70 91 2a 01 	lds	r23, 0x012A	; 0x80012a <ampState+0x1>
 ba0:	80 91 2b 01 	lds	r24, 0x012B	; 0x80012b <ampState+0x2>
 ba4:	ab d1       	rcall	.+854    	; 0xefc <SH100CTRL_SetAmpState>
 ba6:	0f 90       	pop	r0
 ba8:	0f 90       	pop	r0
 baa:	0f 90       	pop	r0
 bac:	df 91       	pop	r29
 bae:	cf 91       	pop	r28
 bb0:	08 95       	ret

Disassembly of section .text.SH100CTRL_CheckOutputJacks:

00000da0 <SH100CTRL_CheckOutputJacks>:
}

void SH100CTRL_CheckOutputJacks()
{
	SH100HW_OutputJacks_t outJacksState = SH100HW_GetOutputJacks();
 da0:	50 d2       	rcall	.+1184   	; 0x1242 <SH100HW_GetOutputJacks>
	
	switch(outJacksState)
 da2:	81 30       	cpi	r24, 0x01	; 1
 da4:	71 f0       	breq	.+28     	; 0xdc2 <SH100CTRL_CheckOutputJacks+0x22>
 da6:	28 f0       	brcs	.+10     	; 0xdb2 <SH100CTRL_CheckOutputJacks+0x12>
 da8:	82 30       	cpi	r24, 0x02	; 2
 daa:	99 f0       	breq	.+38     	; 0xdd2 <SH100CTRL_CheckOutputJacks+0x32>
 dac:	83 30       	cpi	r24, 0x03	; 3
 dae:	c9 f0       	breq	.+50     	; 0xde2 <SH100CTRL_CheckOutputJacks+0x42>
 db0:	08 95       	ret
	{
		case OUT_NONE:
		{
			SH100CTRL_MuteAmp();
 db2:	da d2       	rcall	.+1460   	; 0x1368 <SH100CTRL_MuteAmp>
			SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
 db4:	60 e0       	ldi	r22, 0x00	; 0
 db6:	87 e0       	ldi	r24, 0x07	; 7
 db8:	c0 d0       	rcall	.+384    	; 0xf3a <SH100HW_SetNewLedState>
			SH100HW_SetNewLedState(LED_PWR_RED, LED_ON);
 dba:	61 e0       	ldi	r22, 0x01	; 1
 dbc:	88 e0       	ldi	r24, 0x08	; 8
 dbe:	bd d0       	rcall	.+378    	; 0xf3a <SH100HW_SetNewLedState>
			break;
 dc0:	08 95       	ret
		}
		case OUT_16OHM:
		{
			if(MIDICTRL_MidiMode() == RUNNING)
 dc2:	c3 d2       	rcall	.+1414   	; 0x134a <MIDICTRL_MidiMode>
 dc4:	81 11       	cpse	r24, r1
 dc6:	01 c0       	rjmp	.+2      	; 0xdca <SH100CTRL_CheckOutputJacks+0x2a>
			{
				SH100CTRL_UnmuteAmp();
 dc8:	a6 d2       	rcall	.+1356   	; 0x1316 <SH100CTRL_UnmuteAmp>
			}
			SH100HW_SetNewLedState(LED_PWR_GRN, LED_ON);
 dca:	61 e0       	ldi	r22, 0x01	; 1
 dcc:	87 e0       	ldi	r24, 0x07	; 7
 dce:	b5 d0       	rcall	.+362    	; 0xf3a <SH100HW_SetNewLedState>
			break;
 dd0:	08 95       	ret
		}
		case OUT_8OHM:
		{
			if(MIDICTRL_MidiMode() == RUNNING)
 dd2:	bb d2       	rcall	.+1398   	; 0x134a <MIDICTRL_MidiMode>
 dd4:	81 11       	cpse	r24, r1
 dd6:	01 c0       	rjmp	.+2      	; 0xdda <SH100CTRL_CheckOutputJacks+0x3a>
			{
				SH100CTRL_UnmuteAmp();
 dd8:	9e d2       	rcall	.+1340   	; 0x1316 <SH100CTRL_UnmuteAmp>
			}
			SH100HW_SetNewLedState(LED_PWR_GRN, LED_ON);
 dda:	61 e0       	ldi	r22, 0x01	; 1
 ddc:	87 e0       	ldi	r24, 0x07	; 7
 dde:	ad d0       	rcall	.+346    	; 0xf3a <SH100HW_SetNewLedState>
			break;
 de0:	08 95       	ret
		}
		case OUT_BOTH:
		{
			SH100HW_SetNewLedState(LED_PWR_GRN, LED_SLOW_BLINKING);
 de2:	63 e0       	ldi	r22, 0x03	; 3
 de4:	87 e0       	ldi	r24, 0x07	; 7
 de6:	a9 d0       	rcall	.+338    	; 0xf3a <SH100HW_SetNewLedState>
 de8:	08 95       	ret

Disassembly of section .text.SH100HW_Init:

00000aea <SH100HW_Init>:
SH100HW_Buttons_t buttonsState;
void readButtonsState();
void writeShiftRegs(uint16_t data);

void SH100HW_Init()
{
 aea:	1f 93       	push	r17
 aec:	cf 93       	push	r28
 aee:	df 93       	push	r29
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
 af0:	45 b1       	in	r20, 0x05	; 5
		}

		*((uint8_t *)port + 1) |= pin_mask;
 af2:	84 b1       	in	r24, 0x04	; 4
 af4:	88 62       	ori	r24, 0x28	; 40
		port_pin_flags_t flags)
{
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
 af6:	28 b1       	in	r18, 0x08	; 8
 af8:	32 2f       	mov	r19, r18
 afa:	30 61       	ori	r19, 0x10	; 16
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
		}

		*((uint8_t *)port + 1) |= pin_mask;
 afc:	97 b1       	in	r25, 0x07	; 7
 afe:	90 61       	ori	r25, 0x10	; 16
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
 b00:	5b b1       	in	r21, 0x0b	; 11
		}

		*((uint8_t *)port + 1) |= pin_mask;
 b02:	2a b1       	in	r18, 0x0a	; 10
 b04:	20 6e       	ori	r18, 0xE0	; 224
	} else {
		*((uint8_t *)port + 1) &= ~pin_mask;
 b06:	2b 7e       	andi	r18, 0xEB	; 235
 b08:	9b 7d       	andi	r25, 0xDB	; 219
 b0a:	8c 7f       	andi	r24, 0xFC	; 252
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
 b0c:	53 70       	andi	r21, 0x03	; 3
 b0e:	5b b9       	out	0x0b, r21	; 11
		}

		*((uint8_t *)port + 1) |= pin_mask;
 b10:	28 60       	ori	r18, 0x08	; 8
 b12:	2a b9       	out	0x0a, r18	; 10
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
 b14:	23 2f       	mov	r18, r19
 b16:	21 7d       	andi	r18, 0xD1	; 209
 b18:	28 b9       	out	0x08, r18	; 8
		}

		*((uint8_t *)port + 1) |= pin_mask;
 b1a:	9a 60       	ori	r25, 0x0A	; 10
 b1c:	97 b9       	out	0x07, r25	; 7
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
 b1e:	94 2f       	mov	r25, r20
 b20:	90 7d       	andi	r25, 0xD0	; 208
 b22:	95 b9       	out	0x05, r25	; 5
		}

		*((uint8_t *)port + 1) |= pin_mask;
 b24:	84 60       	ori	r24, 0x04	; 4
 b26:	84 b9       	out	0x04, r24	; 4
	//led_ptr[LED_LOOP] = &ledLoop;
	//led_ptr[LED_A] = &ledA;
	//led_ptr[LED_B] = &ledB;
	//led_ptr[LED_PWR_GRN] = &ledPwrGrn;
	//led_ptr[LED_PWR_RED] = &ledPwrRed;
	for(uint8_t i=0; i < LED_COUNT*2; i++)
 b28:	10 e0       	ldi	r17, 0x00	; 0
 b2a:	0c c0       	rjmp	.+24     	; 0xb44 <SH100HW_Init+0x5a>
	{
		led_ptr[i] = malloc(sizeof(SH100HW_LedState_t));
 b2c:	c1 2f       	mov	r28, r17
 b2e:	d0 e0       	ldi	r29, 0x00	; 0
 b30:	81 e0       	ldi	r24, 0x01	; 1
 b32:	90 e0       	ldi	r25, 0x00	; 0
 b34:	fd de       	rcall	.-518    	; 0x930 <__simple_malloc>
 b36:	cc 0f       	add	r28, r28
 b38:	dd 1f       	adc	r29, r29
 b3a:	cf 5b       	subi	r28, 0xBF	; 191
 b3c:	de 4f       	sbci	r29, 0xFE	; 254
 b3e:	99 83       	std	Y+1, r25	; 0x01
 b40:	88 83       	st	Y, r24
	//led_ptr[LED_LOOP] = &ledLoop;
	//led_ptr[LED_A] = &ledA;
	//led_ptr[LED_B] = &ledB;
	//led_ptr[LED_PWR_GRN] = &ledPwrGrn;
	//led_ptr[LED_PWR_RED] = &ledPwrRed;
	for(uint8_t i=0; i < LED_COUNT*2; i++)
 b42:	1f 5f       	subi	r17, 0xFF	; 255
 b44:	12 31       	cpi	r17, 0x12	; 18
 b46:	90 f3       	brcs	.-28     	; 0xb2c <SH100HW_Init+0x42>
	{
		led_ptr[i] = malloc(sizeof(SH100HW_LedState_t));
	}
}
 b48:	df 91       	pop	r29
 b4a:	cf 91       	pop	r28
 b4c:	1f 91       	pop	r17
 b4e:	08 95       	ret

Disassembly of section .text.SH100HW_GetButtonsState:

000012b2 <SH100HW_GetButtonsState>:

SH100HW_Buttons_t SH100HW_GetButtonsState()
{
	return buttonsState;
    12b2:	2f e0       	ldi	r18, 0x0F	; 15
    12b4:	e2 e3       	ldi	r30, 0x32	; 50
    12b6:	f1 e0       	ldi	r31, 0x01	; 1
    12b8:	dc 01       	movw	r26, r24
    12ba:	01 90       	ld	r0, Z+
    12bc:	0d 92       	st	X+, r0
    12be:	2a 95       	dec	r18
    12c0:	e1 f7       	brne	.-8      	; 0x12ba <SH100HW_GetButtonsState+0x8>
}
    12c2:	08 95       	ret

Disassembly of section .text.SH100HW_SwitchCh:

00000cb8 <SH100HW_SwitchCh>:

void SH100HW_SwitchCh(uint8_t chNum)
{
	switch(chNum)
 cb8:	81 30       	cpi	r24, 0x01	; 1
 cba:	69 f0       	breq	.+26     	; 0xcd6 <SH100HW_SwitchCh+0x1e>
 cbc:	28 f0       	brcs	.+10     	; 0xcc8 <SH100HW_SwitchCh+0x10>
 cbe:	82 30       	cpi	r24, 0x02	; 2
 cc0:	91 f0       	breq	.+36     	; 0xce6 <SH100HW_SwitchCh+0x2e>
 cc2:	83 30       	cpi	r24, 0x03	; 3
 cc4:	c1 f0       	breq	.+48     	; 0xcf6 <SH100HW_SwitchCh+0x3e>
 cc6:	08 95       	ret
	{
		case 0:
		{
			RELAY_13_24 = REL_OFF;
 cc8:	10 92 31 01 	sts	0x0131, r1	; 0x800131 <RELAY_13_24>
			RELAY_1_3 = REL_OFF;
 ccc:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <RELAY_1_3>
			RELAY_2_4 = REL_OFF;
 cd0:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <RELAY_2_4>
			break;
 cd4:	08 95       	ret
		}
		case 1:
		{
			RELAY_13_24 = REL_ON;
 cd6:	81 e0       	ldi	r24, 0x01	; 1
 cd8:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <RELAY_13_24>
			RELAY_1_3 = REL_OFF;
 cdc:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <RELAY_1_3>
			RELAY_2_4 = REL_OFF;
 ce0:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <RELAY_2_4>
			break;
 ce4:	08 95       	ret
		}
		case 2:
		{
			RELAY_13_24 = REL_OFF;
 ce6:	10 92 31 01 	sts	0x0131, r1	; 0x800131 <RELAY_13_24>
			RELAY_1_3 = REL_ON;
 cea:	81 e0       	ldi	r24, 0x01	; 1
 cec:	80 93 2e 01 	sts	0x012E, r24	; 0x80012e <RELAY_1_3>
			RELAY_2_4 = REL_OFF;
 cf0:	10 92 2d 01 	sts	0x012D, r1	; 0x80012d <RELAY_2_4>
			break;
 cf4:	08 95       	ret
		}
		case 3:
		{
			RELAY_13_24 = REL_ON;
 cf6:	81 e0       	ldi	r24, 0x01	; 1
 cf8:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <RELAY_13_24>
			RELAY_1_3 = REL_OFF;
 cfc:	10 92 2e 01 	sts	0x012E, r1	; 0x80012e <RELAY_1_3>
			RELAY_2_4 = REL_ON;
 d00:	80 93 2d 01 	sts	0x012D, r24	; 0x80012d <RELAY_2_4>
 d04:	08 95       	ret

Disassembly of section .text.SH100HW_LoopEn:

0000122a <SH100HW_LoopEn>:
	}
}

void SH100HW_LoopEn(bool isEnabled)
{
	RELAY_LOOP = isEnabled;
    122a:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <RELAY_LOOP>
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
    122e:	88 23       	and	r24, r24
    1230:	21 f0       	breq	.+8      	; 0x123a <SH100HW_LoopEn+0x10>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    1232:	85 b1       	in	r24, 0x05	; 5
    1234:	84 60       	ori	r24, 0x04	; 4
    1236:	85 b9       	out	0x05, r24	; 5
    1238:	08 95       	ret
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    123a:	85 b1       	in	r24, 0x05	; 5
    123c:	8b 7f       	andi	r24, 0xFB	; 251
    123e:	85 b9       	out	0x05, r24	; 5
    1240:	08 95       	ret

Disassembly of section .text.SH100HW_SwitchAB:

0000136e <SH100HW_SwitchAB>:
	ioport_set_pin_level(PIN_RELAY_LOOP, RELAY_LOOP);
}

void SH100HW_SwitchAB(bool isBEn)
{
	RELAY_AB = isBEn;
    136e:	80 93 2c 01 	sts	0x012C, r24	; 0x80012c <RELAY_AB>
    1372:	08 95       	ret

Disassembly of section .text.SH100HW_SetNewLedState:

00000f3a <SH100HW_SetNewLedState>:
}

void SH100HW_SetNewLedState(uint8_t ledId, SH100HW_LedState_t newState)
{
 f3a:	cf 93       	push	r28
 f3c:	df 93       	push	r29
	*led_ptr[ledId+LED_PREVIOUS_STATE_OFFSET] = *led_ptr[ledId];
 f3e:	e8 2f       	mov	r30, r24
 f40:	f0 e0       	ldi	r31, 0x00	; 0
 f42:	df 01       	movw	r26, r30
 f44:	19 96       	adiw	r26, 0x09	; 9
 f46:	aa 0f       	add	r26, r26
 f48:	bb 1f       	adc	r27, r27
 f4a:	af 5b       	subi	r26, 0xBF	; 191
 f4c:	be 4f       	sbci	r27, 0xFE	; 254
 f4e:	0d 90       	ld	r0, X+
 f50:	bc 91       	ld	r27, X
 f52:	a0 2d       	mov	r26, r0
 f54:	ee 0f       	add	r30, r30
 f56:	ff 1f       	adc	r31, r31
 f58:	ef 5b       	subi	r30, 0xBF	; 191
 f5a:	fe 4f       	sbci	r31, 0xFE	; 254
 f5c:	c0 81       	ld	r28, Z
 f5e:	d1 81       	ldd	r29, Z+1	; 0x01
 f60:	88 81       	ld	r24, Y
 f62:	8c 93       	st	X, r24
	*led_ptr[ledId] = newState;
 f64:	01 90       	ld	r0, Z+
 f66:	f0 81       	ld	r31, Z
 f68:	e0 2d       	mov	r30, r0
 f6a:	60 83       	st	Z, r22
}
 f6c:	df 91       	pop	r29
 f6e:	cf 91       	pop	r28
 f70:	08 95       	ret

Disassembly of section .text.SH100HW_SetPreviousLedState:

000010d4 <SH100HW_SetPreviousLedState>:

void SH100HW_SetPreviousLedState(uint8_t ledId)
{
	*led_ptr[ledId] = *led_ptr[ledId+LED_PREVIOUS_STATE_OFFSET];
    10d4:	90 e0       	ldi	r25, 0x00	; 0
    10d6:	fc 01       	movw	r30, r24
    10d8:	ee 0f       	add	r30, r30
    10da:	ff 1f       	adc	r31, r31
    10dc:	ef 5b       	subi	r30, 0xBF	; 191
    10de:	fe 4f       	sbci	r31, 0xFE	; 254
    10e0:	a0 81       	ld	r26, Z
    10e2:	b1 81       	ldd	r27, Z+1	; 0x01
    10e4:	fc 01       	movw	r30, r24
    10e6:	39 96       	adiw	r30, 0x09	; 9
    10e8:	ee 0f       	add	r30, r30
    10ea:	ff 1f       	adc	r31, r31
    10ec:	ef 5b       	subi	r30, 0xBF	; 191
    10ee:	fe 4f       	sbci	r31, 0xFE	; 254
    10f0:	01 90       	ld	r0, Z+
    10f2:	f0 81       	ld	r31, Z
    10f4:	e0 2d       	mov	r30, r0
    10f6:	80 81       	ld	r24, Z
    10f8:	8c 93       	st	X, r24
    10fa:	08 95       	ret

Disassembly of section .text.SH100HW_GetOutputJacks:

00001242 <SH100HW_GetOutputJacks>:
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
    1242:	21 e0       	ldi	r18, 0x01	; 1
    1244:	18 9b       	sbis	0x03, 0	; 3
    1246:	20 e0       	ldi	r18, 0x00	; 0
    1248:	91 e0       	ldi	r25, 0x01	; 1
    124a:	19 9b       	sbis	0x03, 1	; 3
    124c:	90 e0       	ldi	r25, 0x00	; 0

SH100HW_OutputJacks_t SH100HW_GetOutputJacks()
{
	bool is16Ohm = ioport_get_pin_level(PIN_M16_DETECT);
	bool is8Ohm = ioport_get_pin_level(PIN_M8_DETECT);
	return ((is16Ohm) | (is8Ohm<<1));
    124e:	89 2f       	mov	r24, r25
    1250:	90 e0       	ldi	r25, 0x00	; 0
    1252:	88 0f       	add	r24, r24
    1254:	99 1f       	adc	r25, r25
}
    1256:	82 2b       	or	r24, r18
    1258:	08 95       	ret

Disassembly of section .text.SH100HW_SetPAState:

00001122 <SH100HW_SetPAState>:
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
    1122:	81 30       	cpi	r24, 0x01	; 1
    1124:	21 f0       	breq	.+8      	; 0x112e <SH100HW_SetPAState+0xc>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    1126:	98 b1       	in	r25, 0x08	; 8
    1128:	92 60       	ori	r25, 0x02	; 2
    112a:	98 b9       	out	0x08, r25	; 8
    112c:	03 c0       	rjmp	.+6      	; 0x1134 <SH100HW_SetPAState+0x12>
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    112e:	98 b1       	in	r25, 0x08	; 8
    1130:	9d 7f       	andi	r25, 0xFD	; 253
    1132:	98 b9       	out	0x08, r25	; 8
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
    1134:	88 23       	and	r24, r24
    1136:	21 f0       	breq	.+8      	; 0x1140 <SH100HW_SetPAState+0x1e>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    1138:	88 b1       	in	r24, 0x08	; 8
    113a:	88 60       	ori	r24, 0x08	; 8
    113c:	88 b9       	out	0x08, r24	; 8
    113e:	08 95       	ret
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    1140:	88 b1       	in	r24, 0x08	; 8
    1142:	87 7f       	andi	r24, 0xF7	; 247
    1144:	88 b9       	out	0x08, r24	; 8
    1146:	08 95       	ret

Disassembly of section .text.readButtonsState:

00000388 <readButtonsState>:

//=================================== PRIVATE FUNCTIONS==============================
void readButtonsState()
{
	uint8_t midiChBit[4];
	for(uint8_t cnt = 0; cnt<8; cnt++)
 388:	80 e0       	ldi	r24, 0x00	; 0
 38a:	ac c0       	rjmp	.+344    	; 0x4e4 <__DATA_REGION_LENGTH__+0xe4>
	{
		
		switch(cnt)
 38c:	48 2f       	mov	r20, r24
 38e:	50 e0       	ldi	r21, 0x00	; 0
 390:	48 30       	cpi	r20, 0x08	; 8
 392:	51 05       	cpc	r21, r1
 394:	08 f0       	brcs	.+2      	; 0x398 <readButtonsState+0x10>
 396:	a5 c0       	rjmp	.+330    	; 0x4e2 <__DATA_REGION_LENGTH__+0xe2>
 398:	fa 01       	movw	r30, r20
 39a:	ef 55       	subi	r30, 0x5F	; 95
 39c:	ff 4f       	sbci	r31, 0xFF	; 255
 39e:	09 94       	ijmp
 3a0:	3b b1       	in	r19, 0x0b	; 11
 3a2:	3f 7d       	andi	r19, 0xDF	; 223
 3a4:	3b b9       	out	0x0b, r19	; 11
 3a6:	3b b1       	in	r19, 0x0b	; 11
 3a8:	3f 7b       	andi	r19, 0xBF	; 191
 3aa:	3b b9       	out	0x0b, r19	; 11
 3ac:	3b b1       	in	r19, 0x0b	; 11
 3ae:	3f 77       	andi	r19, 0x7F	; 127
 3b0:	3b b9       	out	0x0b, r19	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 3b2:	31 e0       	ldi	r19, 0x01	; 1
 3b4:	4c 9b       	sbis	0x09, 4	; 9
 3b6:	30 e0       	ldi	r19, 0x00	; 0
			{
				arch_ioport_set_pin_level(PIN_A, 0);
				arch_ioport_set_pin_level(PIN_B, 0);
				arch_ioport_set_pin_level(PIN_C, 0);
				
				buttonsState.midiOmni = arch_ioport_get_pin_level(PIN_MIDI_SWITCH);
 3b8:	30 93 33 01 	sts	0x0133, r19	; 0x800133 <buttonsState+0x1>
 3bc:	31 e0       	ldi	r19, 0x01	; 1
 3be:	35 9b       	sbis	0x06, 5	; 6
 3c0:	30 e0       	ldi	r19, 0x00	; 0
				buttonsState.FS2_sleeve = arch_ioport_get_pin_level(PIN_FOOTSWITCH);
 3c2:	30 93 3e 01 	sts	0x013E, r19	; 0x80013e <buttonsState+0xc>
				break;
 3c6:	8d c0       	rjmp	.+282    	; 0x4e2 <__DATA_REGION_LENGTH__+0xe2>
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 3c8:	2b b1       	in	r18, 0x0b	; 11
 3ca:	20 62       	ori	r18, 0x20	; 32
 3cc:	2b b9       	out	0x0b, r18	; 11
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 3ce:	2b b1       	in	r18, 0x0b	; 11
 3d0:	2f 7b       	andi	r18, 0xBF	; 191
 3d2:	2b b9       	out	0x0b, r18	; 11
 3d4:	2b b1       	in	r18, 0x0b	; 11
 3d6:	2f 77       	andi	r18, 0x7F	; 127
 3d8:	2b b9       	out	0x0b, r18	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 3da:	21 e0       	ldi	r18, 0x01	; 1
 3dc:	4c 9b       	sbis	0x09, 4	; 9
 3de:	20 e0       	ldi	r18, 0x00	; 0
 3e0:	31 e0       	ldi	r19, 0x01	; 1
 3e2:	4a 9b       	sbis	0x09, 2	; 9
 3e4:	30 e0       	ldi	r19, 0x00	; 0
				arch_ioport_set_pin_level(PIN_A, 1);
				arch_ioport_set_pin_level(PIN_B, 0);
				arch_ioport_set_pin_level(PIN_C, 0);
				
				midiChBit[3] = arch_ioport_get_pin_level(PIN_MIDI_SWITCH);
				buttonsState.btnAB = arch_ioport_get_pin_level(PIN_BUTTONS);
 3e6:	30 93 39 01 	sts	0x0139, r19	; 0x800139 <buttonsState+0x7>
 3ea:	31 e0       	ldi	r19, 0x01	; 1
 3ec:	35 9b       	sbis	0x06, 5	; 6
 3ee:	30 e0       	ldi	r19, 0x00	; 0
				buttonsState.FS2_presence = arch_ioport_get_pin_level(PIN_FOOTSWITCH);
 3f0:	30 93 40 01 	sts	0x0140, r19	; 0x800140 <buttonsState+0xe>
				break;
 3f4:	76 c0       	rjmp	.+236    	; 0x4e2 <__DATA_REGION_LENGTH__+0xe2>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 3f6:	9b b1       	in	r25, 0x0b	; 11
 3f8:	9f 7d       	andi	r25, 0xDF	; 223
 3fa:	9b b9       	out	0x0b, r25	; 11
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 3fc:	9b b1       	in	r25, 0x0b	; 11
 3fe:	90 64       	ori	r25, 0x40	; 64
 400:	9b b9       	out	0x0b, r25	; 11
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 402:	9b b1       	in	r25, 0x0b	; 11
 404:	9f 77       	andi	r25, 0x7F	; 127
 406:	9b b9       	out	0x0b, r25	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 408:	91 e0       	ldi	r25, 0x01	; 1
 40a:	4c 9b       	sbis	0x09, 4	; 9
 40c:	90 e0       	ldi	r25, 0x00	; 0
 40e:	31 e0       	ldi	r19, 0x01	; 1
 410:	4a 9b       	sbis	0x09, 2	; 9
 412:	30 e0       	ldi	r19, 0x00	; 0
				arch_ioport_set_pin_level(PIN_A, 0);
				arch_ioport_set_pin_level(PIN_B, 1);
				arch_ioport_set_pin_level(PIN_C, 0);
				
				midiChBit[2] = arch_ioport_get_pin_level(PIN_MIDI_SWITCH);
				buttonsState.btnLoop = arch_ioport_get_pin_level(PIN_BUTTONS);
 414:	30 93 3a 01 	sts	0x013A, r19	; 0x80013a <buttonsState+0x8>
 418:	31 e0       	ldi	r19, 0x01	; 1
 41a:	35 9b       	sbis	0x06, 5	; 6
 41c:	30 e0       	ldi	r19, 0x00	; 0
				buttonsState.FS1_presence = arch_ioport_get_pin_level(PIN_FOOTSWITCH);
 41e:	30 93 3d 01 	sts	0x013D, r19	; 0x80013d <buttonsState+0xb>
				break;
 422:	5f c0       	rjmp	.+190    	; 0x4e2 <__DATA_REGION_LENGTH__+0xe2>
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 424:	3b b1       	in	r19, 0x0b	; 11
 426:	30 62       	ori	r19, 0x20	; 32
 428:	3b b9       	out	0x0b, r19	; 11
 42a:	3b b1       	in	r19, 0x0b	; 11
 42c:	30 64       	ori	r19, 0x40	; 64
 42e:	3b b9       	out	0x0b, r19	; 11
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 430:	3b b1       	in	r19, 0x0b	; 11
 432:	3f 77       	andi	r19, 0x7F	; 127
 434:	3b b9       	out	0x0b, r19	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 436:	31 e0       	ldi	r19, 0x01	; 1
 438:	4c 9b       	sbis	0x09, 4	; 9
 43a:	30 e0       	ldi	r19, 0x00	; 0
			{
				arch_ioport_set_pin_level(PIN_A, 1);
				arch_ioport_set_pin_level(PIN_B, 1);
				arch_ioport_set_pin_level(PIN_C, 0);
				
				buttonsState.midiMuteComm = arch_ioport_get_pin_level(PIN_MIDI_SWITCH);
 43c:	30 93 34 01 	sts	0x0134, r19	; 0x800134 <buttonsState+0x2>
 440:	31 e0       	ldi	r19, 0x01	; 1
 442:	35 9b       	sbis	0x06, 5	; 6
 444:	30 e0       	ldi	r19, 0x00	; 0
				buttonsState.FS1_sleeve = arch_ioport_get_pin_level(PIN_FOOTSWITCH);
 446:	30 93 3b 01 	sts	0x013B, r19	; 0x80013b <buttonsState+0x9>
				break;
 44a:	4b c0       	rjmp	.+150    	; 0x4e2 <__DATA_REGION_LENGTH__+0xe2>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 44c:	3b b1       	in	r19, 0x0b	; 11
 44e:	3f 7d       	andi	r19, 0xDF	; 223
 450:	3b b9       	out	0x0b, r19	; 11
 452:	3b b1       	in	r19, 0x0b	; 11
 454:	3f 7b       	andi	r19, 0xBF	; 191
 456:	3b b9       	out	0x0b, r19	; 11
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 458:	3b b1       	in	r19, 0x0b	; 11
 45a:	30 68       	ori	r19, 0x80	; 128
 45c:	3b b9       	out	0x0b, r19	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 45e:	a1 e0       	ldi	r26, 0x01	; 1
 460:	4c 9b       	sbis	0x09, 4	; 9
 462:	a0 e0       	ldi	r26, 0x00	; 0
 464:	31 e0       	ldi	r19, 0x01	; 1
 466:	4a 9b       	sbis	0x09, 2	; 9
 468:	30 e0       	ldi	r19, 0x00	; 0
				arch_ioport_set_pin_level(PIN_A, 0);
				arch_ioport_set_pin_level(PIN_B, 0);
				arch_ioport_set_pin_level(PIN_C, 1);
				
				midiChBit[0] = arch_ioport_get_pin_level(PIN_MIDI_SWITCH);
				buttonsState.btnCh2 = arch_ioport_get_pin_level(PIN_BUTTONS);
 46a:	30 93 36 01 	sts	0x0136, r19	; 0x800136 <buttonsState+0x4>
 46e:	31 e0       	ldi	r19, 0x01	; 1
 470:	35 9b       	sbis	0x06, 5	; 6
 472:	30 e0       	ldi	r19, 0x00	; 0
				buttonsState.FS1_tip = arch_ioport_get_pin_level(PIN_FOOTSWITCH);
 474:	30 93 3c 01 	sts	0x013C, r19	; 0x80013c <buttonsState+0xa>
				break;
 478:	34 c0       	rjmp	.+104    	; 0x4e2 <__DATA_REGION_LENGTH__+0xe2>
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 47a:	3b b1       	in	r19, 0x0b	; 11
 47c:	30 62       	ori	r19, 0x20	; 32
 47e:	3b b9       	out	0x0b, r19	; 11
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 480:	3b b1       	in	r19, 0x0b	; 11
 482:	3f 7b       	andi	r19, 0xBF	; 191
 484:	3b b9       	out	0x0b, r19	; 11
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 486:	3b b1       	in	r19, 0x0b	; 11
 488:	30 68       	ori	r19, 0x80	; 128
 48a:	3b b9       	out	0x0b, r19	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 48c:	31 e0       	ldi	r19, 0x01	; 1
 48e:	4a 9b       	sbis	0x09, 2	; 9
 490:	30 e0       	ldi	r19, 0x00	; 0
			{
				arch_ioport_set_pin_level(PIN_A, 1);
				arch_ioport_set_pin_level(PIN_B, 0);
				arch_ioport_set_pin_level(PIN_C, 1);
				
				buttonsState.btnCh3 = arch_ioport_get_pin_level(PIN_BUTTONS);
 492:	30 93 37 01 	sts	0x0137, r19	; 0x800137 <buttonsState+0x5>
				break;
 496:	25 c0       	rjmp	.+74     	; 0x4e2 <__DATA_REGION_LENGTH__+0xe2>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 498:	9b b1       	in	r25, 0x0b	; 11
 49a:	9f 7d       	andi	r25, 0xDF	; 223
 49c:	9b b9       	out	0x0b, r25	; 11
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 49e:	9b b1       	in	r25, 0x0b	; 11
 4a0:	90 64       	ori	r25, 0x40	; 64
 4a2:	9b b9       	out	0x0b, r25	; 11
 4a4:	9b b1       	in	r25, 0x0b	; 11
 4a6:	90 68       	ori	r25, 0x80	; 128
 4a8:	9b b9       	out	0x0b, r25	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 4aa:	91 e0       	ldi	r25, 0x01	; 1
 4ac:	4c 9b       	sbis	0x09, 4	; 9
 4ae:	90 e0       	ldi	r25, 0x00	; 0
 4b0:	31 e0       	ldi	r19, 0x01	; 1
 4b2:	4a 9b       	sbis	0x09, 2	; 9
 4b4:	30 e0       	ldi	r19, 0x00	; 0
				arch_ioport_set_pin_level(PIN_A, 0);
				arch_ioport_set_pin_level(PIN_B, 1);
				arch_ioport_set_pin_level(PIN_C, 1);
				
				midiChBit[2] = arch_ioport_get_pin_level(PIN_MIDI_SWITCH);
				buttonsState.btnCh4 = arch_ioport_get_pin_level(PIN_BUTTONS);
 4b6:	30 93 38 01 	sts	0x0138, r19	; 0x800138 <buttonsState+0x6>
 4ba:	31 e0       	ldi	r19, 0x01	; 1
 4bc:	35 9b       	sbis	0x06, 5	; 6
 4be:	30 e0       	ldi	r19, 0x00	; 0
				buttonsState.FS2_tip = arch_ioport_get_pin_level(PIN_FOOTSWITCH);
 4c0:	30 93 3f 01 	sts	0x013F, r19	; 0x80013f <buttonsState+0xd>
				break;
 4c4:	0e c0       	rjmp	.+28     	; 0x4e2 <__DATA_REGION_LENGTH__+0xe2>
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 4c6:	3b b1       	in	r19, 0x0b	; 11
 4c8:	30 62       	ori	r19, 0x20	; 32
 4ca:	3b b9       	out	0x0b, r19	; 11
 4cc:	3b b1       	in	r19, 0x0b	; 11
 4ce:	30 64       	ori	r19, 0x40	; 64
 4d0:	3b b9       	out	0x0b, r19	; 11
 4d2:	3b b1       	in	r19, 0x0b	; 11
 4d4:	30 68       	ori	r19, 0x80	; 128
 4d6:	3b b9       	out	0x0b, r19	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 4d8:	31 e0       	ldi	r19, 0x01	; 1
 4da:	4a 9b       	sbis	0x09, 2	; 9
 4dc:	30 e0       	ldi	r19, 0x00	; 0
			{
				arch_ioport_set_pin_level(PIN_A, 1);
				arch_ioport_set_pin_level(PIN_B, 1);
				arch_ioport_set_pin_level(PIN_C, 1);
				
				buttonsState.btnCh1 = arch_ioport_get_pin_level(PIN_BUTTONS);
 4de:	30 93 35 01 	sts	0x0135, r19	; 0x800135 <buttonsState+0x3>

//=================================== PRIVATE FUNCTIONS==============================
void readButtonsState()
{
	uint8_t midiChBit[4];
	for(uint8_t cnt = 0; cnt<8; cnt++)
 4e2:	8f 5f       	subi	r24, 0xFF	; 255
 4e4:	88 30       	cpi	r24, 0x08	; 8
 4e6:	08 f4       	brcc	.+2      	; 0x4ea <__DATA_REGION_LENGTH__+0xea>
 4e8:	51 cf       	rjmp	.-350    	; 0x38c <readButtonsState+0x4>
			}
			default: break;
		}
	}
	
	buttonsState.midiChNum = midiChBit[0] | (midiChBit[1]<<1) | (midiChBit[2]<<2) | (midiChBit[3]<<3);
 4ea:	89 2f       	mov	r24, r25
 4ec:	90 e0       	ldi	r25, 0x00	; 0
 4ee:	88 0f       	add	r24, r24
 4f0:	99 1f       	adc	r25, r25
 4f2:	88 0f       	add	r24, r24
 4f4:	99 1f       	adc	r25, r25
 4f6:	30 e0       	ldi	r19, 0x00	; 0
 4f8:	22 0f       	add	r18, r18
 4fa:	33 1f       	adc	r19, r19
 4fc:	22 0f       	add	r18, r18
 4fe:	33 1f       	adc	r19, r19
 500:	22 0f       	add	r18, r18
 502:	33 1f       	adc	r19, r19
 504:	8a 2b       	or	r24, r26
 506:	82 2b       	or	r24, r18
 508:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <buttonsState>
 50c:	08 95       	ret

Disassembly of section .text.writeShiftRegs:

00000dea <writeShiftRegs>:
}

void writeShiftRegs(uint16_t data)
{
 dea:	ac 01       	movw	r20, r24
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 dec:	88 b1       	in	r24, 0x08	; 8
 dee:	80 61       	ori	r24, 0x10	; 16
 df0:	88 b9       	out	0x08, r24	; 8
	arch_ioport_set_pin_level(PIN_ST, 1);
	for(uint8_t i=0; i<16; i++)
 df2:	90 e0       	ldi	r25, 0x00	; 0
 df4:	16 c0       	rjmp	.+44     	; 0xe22 <writeShiftRegs+0x38>
	{
		data = data << i;
 df6:	09 2e       	mov	r0, r25
 df8:	02 c0       	rjmp	.+4      	; 0xdfe <writeShiftRegs+0x14>
 dfa:	44 0f       	add	r20, r20
 dfc:	55 1f       	adc	r21, r21
 dfe:	0a 94       	dec	r0
 e00:	e2 f7       	brpl	.-8      	; 0xdfa <writeShiftRegs+0x10>
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 e02:	25 b1       	in	r18, 0x05	; 5
 e04:	2f 7d       	andi	r18, 0xDF	; 223
 e06:	25 b9       	out	0x05, r18	; 5
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
 e08:	47 ff       	sbrs	r20, 7
 e0a:	04 c0       	rjmp	.+8      	; 0xe14 <writeShiftRegs+0x2a>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 e0c:	85 b1       	in	r24, 0x05	; 5
 e0e:	88 60       	ori	r24, 0x08	; 8
 e10:	85 b9       	out	0x05, r24	; 5
 e12:	03 c0       	rjmp	.+6      	; 0xe1a <writeShiftRegs+0x30>
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 e14:	85 b1       	in	r24, 0x05	; 5
 e16:	87 7f       	andi	r24, 0xF7	; 247
 e18:	85 b9       	out	0x05, r24	; 5
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 e1a:	25 b1       	in	r18, 0x05	; 5
 e1c:	20 62       	ori	r18, 0x20	; 32
 e1e:	25 b9       	out	0x05, r18	; 5
}

void writeShiftRegs(uint16_t data)
{
	arch_ioport_set_pin_level(PIN_ST, 1);
	for(uint8_t i=0; i<16; i++)
 e20:	9f 5f       	subi	r25, 0xFF	; 255
 e22:	90 31       	cpi	r25, 0x10	; 16
 e24:	40 f3       	brcs	.-48     	; 0xdf6 <writeShiftRegs+0xc>
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 e26:	85 b1       	in	r24, 0x05	; 5
 e28:	8f 7d       	andi	r24, 0xDF	; 223
 e2a:	85 b9       	out	0x05, r24	; 5
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 e2c:	88 b1       	in	r24, 0x08	; 8
 e2e:	80 61       	ori	r24, 0x10	; 16
 e30:	88 b9       	out	0x08, r24	; 8
 e32:	08 95       	ret

Disassembly of section .text.SH100HW_MainTask:

000001d0 <SH100HW_MainTask>:
uint8_t blinkCounter = 0;
bool slowBlink = false;
bool fastBlink = false;
uint8_t indErrorCnt = 0;
void SH100HW_MainTask()
{
 1d0:	cf 93       	push	r28
 1d2:	df 93       	push	r29
 1d4:	cd b7       	in	r28, 0x3d	; 61
 1d6:	de b7       	in	r29, 0x3e	; 62
 1d8:	29 97       	sbiw	r28, 0x09	; 9
 1da:	0f b6       	in	r0, 0x3f	; 63
 1dc:	f8 94       	cli
 1de:	de bf       	out	0x3e, r29	; 62
 1e0:	0f be       	out	0x3f, r0	; 63
 1e2:	cd bf       	out	0x3d, r28	; 61
	readButtonsState();
 1e4:	d1 d0       	rcall	.+418    	; 0x388 <readButtonsState>
	
	// blink work----------------------------------------------
	bool isLedOn[LED_COUNT];	
	if((blinkCounter % 25) == 0 && blinkCounter != 0)
 1e6:	90 91 b1 01 	lds	r25, 0x01B1	; 0x8001b1 <blinkCounter>
 1ea:	89 e2       	ldi	r24, 0x29	; 41
 1ec:	98 9f       	mul	r25, r24
 1ee:	81 2d       	mov	r24, r1
 1f0:	11 24       	eor	r1, r1
 1f2:	86 95       	lsr	r24
 1f4:	86 95       	lsr	r24
 1f6:	39 2f       	mov	r19, r25
 1f8:	29 e1       	ldi	r18, 0x19	; 25
 1fa:	82 9f       	mul	r24, r18
 1fc:	30 19       	sub	r19, r0
 1fe:	11 24       	eor	r1, r1
 200:	31 11       	cpse	r19, r1
 202:	08 c0       	rjmp	.+16     	; 0x214 <__EEPROM_REGION_LENGTH__+0x14>
 204:	99 23       	and	r25, r25
 206:	31 f0       	breq	.+12     	; 0x214 <__EEPROM_REGION_LENGTH__+0x14>
	{
		fastBlink = !fastBlink;
 208:	20 91 af 01 	lds	r18, 0x01AF	; 0x8001af <fastBlink>
 20c:	81 e0       	ldi	r24, 0x01	; 1
 20e:	82 27       	eor	r24, r18
 210:	80 93 af 01 	sts	0x01AF, r24	; 0x8001af <fastBlink>
	}
	
	if(blinkCounter == 100)
 214:	94 36       	cpi	r25, 0x64	; 100
 216:	51 f4       	brne	.+20     	; 0x22c <__EEPROM_REGION_LENGTH__+0x2c>
	{
		blinkCounter = 0;
 218:	10 92 b1 01 	sts	0x01B1, r1	; 0x8001b1 <blinkCounter>
		slowBlink = !slowBlink;
 21c:	90 91 b0 01 	lds	r25, 0x01B0	; 0x8001b0 <slowBlink>
 220:	81 e0       	ldi	r24, 0x01	; 1
 222:	89 27       	eor	r24, r25
 224:	80 93 b0 01 	sts	0x01B0, r24	; 0x8001b0 <slowBlink>
uint8_t blinkCounter = 0;
bool slowBlink = false;
bool fastBlink = false;
uint8_t indErrorCnt = 0;
void SH100HW_MainTask()
{
 228:	20 e0       	ldi	r18, 0x00	; 0
 22a:	3f c0       	rjmp	.+126    	; 0x2aa <__EEPROM_REGION_LENGTH__+0xaa>
		blinkCounter = 0;
		slowBlink = !slowBlink;
	}
	else
	{
		blinkCounter++;
 22c:	9f 5f       	subi	r25, 0xFF	; 255
 22e:	90 93 b1 01 	sts	0x01B1, r25	; 0x8001b1 <blinkCounter>
 232:	fa cf       	rjmp	.-12     	; 0x228 <__EEPROM_REGION_LENGTH__+0x28>
	}
	
	for(uint8_t i=0; i<LED_COUNT; i++)
	{
		switch(*led_ptr[i])
 234:	82 2f       	mov	r24, r18
 236:	90 e0       	ldi	r25, 0x00	; 0
 238:	fc 01       	movw	r30, r24
 23a:	ee 0f       	add	r30, r30
 23c:	ff 1f       	adc	r31, r31
 23e:	ef 5b       	subi	r30, 0xBF	; 191
 240:	fe 4f       	sbci	r31, 0xFE	; 254
 242:	01 90       	ld	r0, Z+
 244:	f0 81       	ld	r31, Z
 246:	e0 2d       	mov	r30, r0
 248:	30 81       	ld	r19, Z
 24a:	31 30       	cpi	r19, 0x01	; 1
 24c:	71 f0       	breq	.+28     	; 0x26a <__EEPROM_REGION_LENGTH__+0x6a>
 24e:	28 f0       	brcs	.+10     	; 0x25a <__EEPROM_REGION_LENGTH__+0x5a>
 250:	32 30       	cpi	r19, 0x02	; 2
 252:	a1 f0       	breq	.+40     	; 0x27c <__EEPROM_REGION_LENGTH__+0x7c>
 254:	33 30       	cpi	r19, 0x03	; 3
 256:	e1 f0       	breq	.+56     	; 0x290 <__EEPROM_REGION_LENGTH__+0x90>
 258:	27 c0       	rjmp	.+78     	; 0x2a8 <__EEPROM_REGION_LENGTH__+0xa8>
		{
			case LED_OFF: isLedOn[i] = false; break;
 25a:	e1 e0       	ldi	r30, 0x01	; 1
 25c:	f0 e0       	ldi	r31, 0x00	; 0
 25e:	ec 0f       	add	r30, r28
 260:	fd 1f       	adc	r31, r29
 262:	e8 0f       	add	r30, r24
 264:	f9 1f       	adc	r31, r25
 266:	10 82       	st	Z, r1
 268:	1f c0       	rjmp	.+62     	; 0x2a8 <__EEPROM_REGION_LENGTH__+0xa8>
			case LED_ON: isLedOn[i] = true; break;
 26a:	e1 e0       	ldi	r30, 0x01	; 1
 26c:	f0 e0       	ldi	r31, 0x00	; 0
 26e:	ec 0f       	add	r30, r28
 270:	fd 1f       	adc	r31, r29
 272:	e8 0f       	add	r30, r24
 274:	f9 1f       	adc	r31, r25
 276:	31 e0       	ldi	r19, 0x01	; 1
 278:	30 83       	st	Z, r19
 27a:	16 c0       	rjmp	.+44     	; 0x2a8 <__EEPROM_REGION_LENGTH__+0xa8>
			case LED_FAST_BLINKING: 
			{
				isLedOn[i] = fastBlink; 
 27c:	e1 e0       	ldi	r30, 0x01	; 1
 27e:	f0 e0       	ldi	r31, 0x00	; 0
 280:	ec 0f       	add	r30, r28
 282:	fd 1f       	adc	r31, r29
 284:	e8 0f       	add	r30, r24
 286:	f9 1f       	adc	r31, r25
 288:	30 91 af 01 	lds	r19, 0x01AF	; 0x8001af <fastBlink>
 28c:	30 83       	st	Z, r19
				//isLedOn[LED_PWR_GRN] = !fastBlink; // Green led blink 180deg phase of red led
				break;
 28e:	0c c0       	rjmp	.+24     	; 0x2a8 <__EEPROM_REGION_LENGTH__+0xa8>
			}
			case LED_SLOW_BLINKING: 
			{
				isLedOn[i] = slowBlink;
 290:	30 91 b0 01 	lds	r19, 0x01B0	; 0x8001b0 <slowBlink>
 294:	e1 e0       	ldi	r30, 0x01	; 1
 296:	f0 e0       	ldi	r31, 0x00	; 0
 298:	ec 0f       	add	r30, r28
 29a:	fd 1f       	adc	r31, r29
 29c:	e8 0f       	add	r30, r24
 29e:	f9 1f       	adc	r31, r25
 2a0:	30 83       	st	Z, r19
				isLedOn[LED_PWR_GRN] = !slowBlink; // Green led slow blink 180deg phase of red led
 2a2:	81 e0       	ldi	r24, 0x01	; 1
 2a4:	83 27       	eor	r24, r19
 2a6:	88 87       	std	Y+8, r24	; 0x08
	else
	{
		blinkCounter++;
	}
	
	for(uint8_t i=0; i<LED_COUNT; i++)
 2a8:	2f 5f       	subi	r18, 0xFF	; 255
 2aa:	29 30       	cpi	r18, 0x09	; 9
 2ac:	18 f2       	brcs	.-122    	; 0x234 <__EEPROM_REGION_LENGTH__+0x34>
			}	
		}
	}
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
 2ae:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <RELAY_13_24>
								((uint16_t)RELAY_1_3 << 1)			|
 2b2:	80 91 2e 01 	lds	r24, 0x012E	; 0x80012e <RELAY_1_3>
 2b6:	90 e0       	ldi	r25, 0x00	; 0
 2b8:	88 0f       	add	r24, r24
 2ba:	99 1f       	adc	r25, r25
			}	
		}
	}
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
 2bc:	ac 01       	movw	r20, r24
 2be:	42 2b       	or	r20, r18
 2c0:	9a 01       	movw	r18, r20
								((uint16_t)RELAY_1_3 << 1)			|
								((uint16_t)isLedOn[LED_CH3] << 2)	|
 2c2:	9b 81       	ldd	r25, Y+3	; 0x03
 2c4:	89 2f       	mov	r24, r25
 2c6:	90 e0       	ldi	r25, 0x00	; 0
 2c8:	88 0f       	add	r24, r24
 2ca:	99 1f       	adc	r25, r25
 2cc:	88 0f       	add	r24, r24
 2ce:	99 1f       	adc	r25, r25
		}
	}
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
								((uint16_t)RELAY_1_3 << 1)			|
 2d0:	82 2b       	or	r24, r18
 2d2:	93 2b       	or	r25, r19
								((uint16_t)isLedOn[LED_CH3] << 2)	|
								((uint16_t)isLedOn[LED_CH1] << 3)	|
 2d4:	29 81       	ldd	r18, Y+1	; 0x01
 2d6:	30 e0       	ldi	r19, 0x00	; 0
 2d8:	22 0f       	add	r18, r18
 2da:	33 1f       	adc	r19, r19
 2dc:	22 0f       	add	r18, r18
 2de:	33 1f       	adc	r19, r19
 2e0:	22 0f       	add	r18, r18
 2e2:	33 1f       	adc	r19, r19
	}
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
								((uint16_t)RELAY_1_3 << 1)			|
								((uint16_t)isLedOn[LED_CH3] << 2)	|
 2e4:	82 2b       	or	r24, r18
 2e6:	93 2b       	or	r25, r19
								((uint16_t)isLedOn[LED_CH1] << 3)	|
								((uint16_t)isLedOn[LED_CH2] << 4)	|
 2e8:	4a 81       	ldd	r20, Y+2	; 0x02
 2ea:	20 e1       	ldi	r18, 0x10	; 16
 2ec:	42 9f       	mul	r20, r18
 2ee:	a0 01       	movw	r20, r0
 2f0:	11 24       	eor	r1, r1
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
								((uint16_t)RELAY_1_3 << 1)			|
								((uint16_t)isLedOn[LED_CH3] << 2)	|
								((uint16_t)isLedOn[LED_CH1] << 3)	|
 2f2:	48 2b       	or	r20, r24
 2f4:	59 2b       	or	r21, r25
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
 2f6:	2c 81       	ldd	r18, Y+4	; 0x04
 2f8:	80 e2       	ldi	r24, 0x20	; 32
 2fa:	28 9f       	mul	r18, r24
 2fc:	90 01       	movw	r18, r0
 2fe:	11 24       	eor	r1, r1
 300:	42 2b       	or	r20, r18
 302:	53 2b       	or	r21, r19
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
 304:	20 91 2f 01 	lds	r18, 0x012F	; 0x80012f <RELAY_8_16>
 308:	80 e8       	ldi	r24, 0x80	; 128
 30a:	28 9f       	mul	r18, r24
 30c:	90 01       	movw	r18, r0
 30e:	11 24       	eor	r1, r1
								((uint16_t)RELAY_1_3 << 1)			|
								((uint16_t)isLedOn[LED_CH3] << 2)	|
								((uint16_t)isLedOn[LED_CH1] << 3)	|
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
 310:	42 2b       	or	r20, r18
 312:	53 2b       	or	r21, r19
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << 8)			|
 314:	80 91 2d 01 	lds	r24, 0x012D	; 0x80012d <RELAY_2_4>
 318:	90 e0       	ldi	r25, 0x00	; 0
 31a:	98 2f       	mov	r25, r24
 31c:	88 27       	eor	r24, r24
								((uint16_t)isLedOn[LED_CH3] << 2)	|
								((uint16_t)isLedOn[LED_CH1] << 3)	|
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
 31e:	48 2b       	or	r20, r24
 320:	59 2b       	or	r21, r25
								((uint16_t)RELAY_2_4 << 8)			|
								((uint16_t)isLedOn[LED_A] << 9)	|
 322:	8f 81       	ldd	r24, Y+7	; 0x07
 324:	90 e0       	ldi	r25, 0x00	; 0
 326:	98 2f       	mov	r25, r24
 328:	88 27       	eor	r24, r24
 32a:	99 0f       	add	r25, r25
								((uint16_t)isLedOn[LED_CH1] << 3)	|
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << 8)			|
 32c:	48 2b       	or	r20, r24
 32e:	59 2b       	or	r21, r25
								((uint16_t)isLedOn[LED_A] << 9)	|
								((uint16_t)isLedOn[LED_B] << 10)	|
 330:	98 85       	ldd	r25, Y+8	; 0x08
 332:	29 2f       	mov	r18, r25
 334:	30 e0       	ldi	r19, 0x00	; 0
 336:	c9 01       	movw	r24, r18
 338:	98 2f       	mov	r25, r24
 33a:	88 27       	eor	r24, r24
 33c:	99 0f       	add	r25, r25
 33e:	99 0f       	add	r25, r25
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << 8)			|
								((uint16_t)isLedOn[LED_A] << 9)	|
 340:	48 2b       	or	r20, r24
 342:	59 2b       	or	r21, r25
								((uint16_t)isLedOn[LED_B] << 10)	|
								((uint16_t)isLedOn[LED_PWR_GRN] << 11)	|
 344:	32 2f       	mov	r19, r18
 346:	22 27       	eor	r18, r18
 348:	33 0f       	add	r19, r19
 34a:	33 0f       	add	r19, r19
 34c:	33 0f       	add	r19, r19
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << 8)			|
								((uint16_t)isLedOn[LED_A] << 9)	|
								((uint16_t)isLedOn[LED_B] << 10)	|
 34e:	24 2b       	or	r18, r20
 350:	35 2b       	or	r19, r21
								((uint16_t)isLedOn[LED_PWR_GRN] << 11)	|
								((uint16_t)isLedOn[LED_PWR_RED] << 12)	|
 352:	89 85       	ldd	r24, Y+9	; 0x09
 354:	90 e0       	ldi	r25, 0x00	; 0
 356:	98 2f       	mov	r25, r24
 358:	88 27       	eor	r24, r24
 35a:	92 95       	swap	r25
 35c:	90 7f       	andi	r25, 0xF0	; 240
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << 8)			|
								((uint16_t)isLedOn[LED_A] << 9)	|
								((uint16_t)isLedOn[LED_B] << 10)	|
								((uint16_t)isLedOn[LED_PWR_GRN] << 11)	|
 35e:	28 2b       	or	r18, r24
 360:	39 2b       	or	r19, r25
								((uint16_t)isLedOn[LED_PWR_RED] << 12)	|
								((uint16_t)isLedOn[LED_LOOP] << 13);
 362:	8e 81       	ldd	r24, Y+6	; 0x06
 364:	90 e0       	ldi	r25, 0x00	; 0
 366:	98 2f       	mov	r25, r24
 368:	88 27       	eor	r24, r24
 36a:	92 95       	swap	r25
 36c:	99 0f       	add	r25, r25
 36e:	90 7e       	andi	r25, 0xE0	; 224

	writeShiftRegs(resultSendWord);
 370:	82 2b       	or	r24, r18
 372:	93 2b       	or	r25, r19
 374:	3a d5       	rcall	.+2676   	; 0xdea <writeShiftRegs>
 376:	29 96       	adiw	r28, 0x09	; 9
 378:	0f b6       	in	r0, 0x3f	; 63
 37a:	f8 94       	cli
 37c:	de bf       	out	0x3e, r29	; 62
 37e:	0f be       	out	0x3f, r0	; 63
 380:	cd bf       	out	0x3d, r28	; 61
 382:	df 91       	pop	r29
 384:	cf 91       	pop	r28
 386:	08 95       	ret

Disassembly of section .text.UART_init:

0000125a <UART_init>:
	// Rx INT: On
	// Tx INT: On
	// Receiver: On
	// Transmitter: On
	
	UCSR0B = (1<<RXCIE0) | (1<<TXCIE0) | (1<<RXEN0) | (1<<TXEN0); //UCSR1B=0x98;
    125a:	88 ed       	ldi	r24, 0xD8	; 216
    125c:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fe0c1>
	
	// 8 Data, 1 Stop, No Parity
	UCSR0C=0x06; 
    1260:	86 e0       	ldi	r24, 0x06	; 6
    1262:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fe0c2>
	
	// USART0 Mode: Asynchronous
	// USART Baud Rate: Fosc/320 = Fosc/16(UBRR+1)
	UBRR0H=0x00;
    1266:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fe0c5>
	UBRR0L=0x13;
    126a:	83 e1       	ldi	r24, 0x13	; 19
    126c:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fe0c4>
    1270:	08 95       	ret

Disassembly of section .text.__vector_18:

00000bb2 <__vector_18>:
uint8_t rx_wr_index, rx_rd_index, rx_counter;

bool rx_buffer_overflow;

ISR(USART_RX_vect)
{
 bb2:	1f 92       	push	r1
 bb4:	1f b6       	in	r1, 0x3f	; 63
 bb6:	1f 92       	push	r1
 bb8:	11 24       	eor	r1, r1
 bba:	8f 93       	push	r24
 bbc:	9f 93       	push	r25
 bbe:	ef 93       	push	r30
 bc0:	ff 93       	push	r31
	uint8_t status, data;
	status = UCSR0A;
 bc2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fe0c0>
	data = UDR0;
 bc6:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fe0c6>
	
	if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
 bca:	8c 71       	andi	r24, 0x1C	; 28
 bcc:	d1 f4       	brne	.+52     	; 0xc02 <__vector_18+0x50>
	{
		rx_buffer0[rx_wr_index++] = data;
 bce:	e0 91 65 01 	lds	r30, 0x0165	; 0x800165 <rx_wr_index>
 bd2:	81 e0       	ldi	r24, 0x01	; 1
 bd4:	8e 0f       	add	r24, r30
 bd6:	80 93 65 01 	sts	0x0165, r24	; 0x800165 <rx_wr_index>
 bda:	f0 e0       	ldi	r31, 0x00	; 0
 bdc:	ef 58       	subi	r30, 0x8F	; 143
 bde:	fe 4f       	sbci	r31, 0xFE	; 254
 be0:	90 83       	st	Z, r25
		
		if (rx_wr_index == RX_BUFFER_SIZE) rx_wr_index=0;
 be2:	80 31       	cpi	r24, 0x10	; 16
 be4:	11 f4       	brne	.+4      	; 0xbea <__vector_18+0x38>
 be6:	10 92 65 01 	sts	0x0165, r1	; 0x800165 <rx_wr_index>
		
		if (++rx_counter == RX_BUFFER_SIZE)
 bea:	80 91 70 01 	lds	r24, 0x0170	; 0x800170 <rx_counter>
 bee:	8f 5f       	subi	r24, 0xFF	; 255
 bf0:	80 93 70 01 	sts	0x0170, r24	; 0x800170 <rx_counter>
 bf4:	80 31       	cpi	r24, 0x10	; 16
 bf6:	29 f4       	brne	.+10     	; 0xc02 <__vector_18+0x50>
		{
			rx_counter=0;
 bf8:	10 92 70 01 	sts	0x0170, r1	; 0x800170 <rx_counter>
			rx_buffer_overflow=1;
 bfc:	81 e0       	ldi	r24, 0x01	; 1
 bfe:	80 93 66 01 	sts	0x0166, r24	; 0x800166 <rx_buffer_overflow>
		}
	}
}
 c02:	ff 91       	pop	r31
 c04:	ef 91       	pop	r30
 c06:	9f 91       	pop	r25
 c08:	8f 91       	pop	r24
 c0a:	1f 90       	pop	r1
 c0c:	1f be       	out	0x3f, r1	; 63
 c0e:	1f 90       	pop	r1
 c10:	18 95       	reti

Disassembly of section .text.UART_PopWord:

00001016 <UART_PopWord>:

uint8_t UART_PopWord()
{
	uint8_t data;
	
	while (rx_counter == 0); // blocking
    1016:	80 91 70 01 	lds	r24, 0x0170	; 0x800170 <rx_counter>
    101a:	88 23       	and	r24, r24
    101c:	e1 f3       	breq	.-8      	; 0x1016 <UART_PopWord>
	
	data = rx_buffer0[rx_rd_index++];
    101e:	e0 91 81 01 	lds	r30, 0x0181	; 0x800181 <rx_rd_index>
    1022:	91 e0       	ldi	r25, 0x01	; 1
    1024:	9e 0f       	add	r25, r30
    1026:	90 93 81 01 	sts	0x0181, r25	; 0x800181 <rx_rd_index>
    102a:	f0 e0       	ldi	r31, 0x00	; 0
    102c:	ef 58       	subi	r30, 0x8F	; 143
    102e:	fe 4f       	sbci	r31, 0xFE	; 254
    1030:	80 81       	ld	r24, Z
	
	#if RX_BUFFER_SIZE != 256
		if (rx_rd_index == RX_BUFFER_SIZE) rx_rd_index = 0;
    1032:	90 31       	cpi	r25, 0x10	; 16
    1034:	11 f4       	brne	.+4      	; 0x103a <UART_PopWord+0x24>
    1036:	10 92 81 01 	sts	0x0181, r1	; 0x800181 <rx_rd_index>
	#endif
	
	cpu_irq_disable();
    103a:	f8 94       	cli
	--rx_counter;
    103c:	90 91 70 01 	lds	r25, 0x0170	; 0x800170 <rx_counter>
    1040:	91 50       	subi	r25, 0x01	; 1
    1042:	90 93 70 01 	sts	0x0170, r25	; 0x800170 <rx_counter>
	cpu_irq_enable();
    1046:	78 94       	sei
	return data;
}
    1048:	08 95       	ret

Disassembly of section .text.UART_RxBufferNotEmpty:

000012d6 <UART_RxBufferNotEmpty>:

bool UART_RxBufferNotEmpty()
{
	return (bool)rx_counter;
    12d6:	81 e0       	ldi	r24, 0x01	; 1
    12d8:	90 91 70 01 	lds	r25, 0x0170	; 0x800170 <rx_counter>
    12dc:	91 11       	cpse	r25, r1
    12de:	01 c0       	rjmp	.+2      	; 0x12e2 <UART_RxBufferNotEmpty+0xc>
    12e0:	80 e0       	ldi	r24, 0x00	; 0
}
    12e2:	08 95       	ret

Disassembly of section .text.__vector_20:

00000d06 <__vector_20>:
uint8_t tx_buffer[TX_BUFFER_SIZE];
uint8_t tx_wr_index, tx_rd_index, tx_counter;

// USART Transmitter interrupt service routine
ISR(USART_TX_vect)
{
 d06:	1f 92       	push	r1
 d08:	1f b6       	in	r1, 0x3f	; 63
 d0a:	1f 92       	push	r1
 d0c:	11 24       	eor	r1, r1
 d0e:	8f 93       	push	r24
 d10:	ef 93       	push	r30
 d12:	ff 93       	push	r31
	if (tx_counter)
 d14:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <tx_counter>
 d18:	88 23       	and	r24, r24
 d1a:	a9 f0       	breq	.+42     	; 0xd46 <__vector_20+0x40>
	{
		--tx_counter;
 d1c:	81 50       	subi	r24, 0x01	; 1
 d1e:	80 93 67 01 	sts	0x0167, r24	; 0x800167 <tx_counter>
		UDR0=tx_buffer[tx_rd_index++];
 d22:	e0 91 82 01 	lds	r30, 0x0182	; 0x800182 <tx_rd_index>
 d26:	81 e0       	ldi	r24, 0x01	; 1
 d28:	8e 0f       	add	r24, r30
 d2a:	80 93 82 01 	sts	0x0182, r24	; 0x800182 <tx_rd_index>
 d2e:	f0 e0       	ldi	r31, 0x00	; 0
 d30:	e8 59       	subi	r30, 0x98	; 152
 d32:	fe 4f       	sbci	r31, 0xFE	; 254
 d34:	80 81       	ld	r24, Z
 d36:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fe0c6>
		
		#if TX_BUFFER_SIZE != 256
			if (tx_rd_index == TX_BUFFER_SIZE) tx_rd_index = 0;
 d3a:	80 91 82 01 	lds	r24, 0x0182	; 0x800182 <tx_rd_index>
 d3e:	88 30       	cpi	r24, 0x08	; 8
 d40:	11 f4       	brne	.+4      	; 0xd46 <__vector_20+0x40>
 d42:	10 92 82 01 	sts	0x0182, r1	; 0x800182 <tx_rd_index>
		#endif
	}
}
 d46:	ff 91       	pop	r31
 d48:	ef 91       	pop	r30
 d4a:	8f 91       	pop	r24
 d4c:	1f 90       	pop	r1
 d4e:	1f be       	out	0x3f, r1	; 63
 d50:	1f 90       	pop	r1
 d52:	18 95       	reti

Disassembly of section .text.UART_PushWord:

00000e34 <UART_PushWord>:

// Write a character to the USART Transmitter buffer
void UART_PushWord(uint8_t c)
{	
	while (tx_counter == TX_BUFFER_SIZE);
 e34:	90 91 67 01 	lds	r25, 0x0167	; 0x800167 <tx_counter>
 e38:	98 30       	cpi	r25, 0x08	; 8
 e3a:	e1 f3       	breq	.-8      	; 0xe34 <UART_PushWord>
	
	cpu_irq_disable();
 e3c:	f8 94       	cli
	
	if (tx_counter || ((UCSR0A & DATA_REGISTER_EMPTY)==0))
 e3e:	90 91 67 01 	lds	r25, 0x0167	; 0x800167 <tx_counter>
 e42:	91 11       	cpse	r25, r1
 e44:	04 c0       	rjmp	.+8      	; 0xe4e <UART_PushWord+0x1a>
 e46:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fe0c0>
 e4a:	25 fd       	sbrc	r18, 5
 e4c:	12 c0       	rjmp	.+36     	; 0xe72 <UART_PushWord+0x3e>
	{
		tx_buffer[tx_wr_index++] = c;
 e4e:	e0 91 83 01 	lds	r30, 0x0183	; 0x800183 <tx_wr_index>
 e52:	21 e0       	ldi	r18, 0x01	; 1
 e54:	2e 0f       	add	r18, r30
 e56:	20 93 83 01 	sts	0x0183, r18	; 0x800183 <tx_wr_index>
 e5a:	f0 e0       	ldi	r31, 0x00	; 0
 e5c:	e8 59       	subi	r30, 0x98	; 152
 e5e:	fe 4f       	sbci	r31, 0xFE	; 254
 e60:	80 83       	st	Z, r24
		
		#if TX_BUFFER_SIZE0 != 256
			if (tx_wr_index == TX_BUFFER_SIZE) tx_wr_index=0;
 e62:	28 30       	cpi	r18, 0x08	; 8
 e64:	11 f4       	brne	.+4      	; 0xe6a <UART_PushWord+0x36>
 e66:	10 92 83 01 	sts	0x0183, r1	; 0x800183 <tx_wr_index>
		#endif
		
		++tx_counter;
 e6a:	9f 5f       	subi	r25, 0xFF	; 255
 e6c:	90 93 67 01 	sts	0x0167, r25	; 0x800167 <tx_counter>
 e70:	02 c0       	rjmp	.+4      	; 0xe76 <UART_PushWord+0x42>
	}
	else UDR0=c;
 e72:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fe0c6>
	
	cpu_irq_enable();
 e76:	78 94       	sei
 e78:	08 95       	ret

Disassembly of section .text.libgcc:

00001272 <__xload_4>:
    1272:	57 fd       	sbrc	r21, 7
    1274:	05 c0       	rjmp	.+10     	; 0x1280 <__xload_4+0xe>
    1276:	65 91       	lpm	r22, Z+
    1278:	75 91       	lpm	r23, Z+
    127a:	85 91       	lpm	r24, Z+
    127c:	95 91       	lpm	r25, Z+
    127e:	08 95       	ret
    1280:	61 91       	ld	r22, Z+
    1282:	71 91       	ld	r23, Z+
    1284:	81 91       	ld	r24, Z+
    1286:	91 91       	ld	r25, Z+
    1288:	08 95       	ret

Disassembly of section .text.__dummy_fini:

00001380 <_fini>:
    1380:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

00001382 <__funcs_on_exit>:
    1382:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

00001384 <__simulator_exit>:
    1384:	08 95       	ret

Disassembly of section .text.exit:

000012e4 <exit>:
    12e4:	ec 01       	movw	r28, r24
    12e6:	4d d0       	rcall	.+154    	; 0x1382 <__funcs_on_exit>
    12e8:	4b d0       	rcall	.+150    	; 0x1380 <_fini>
    12ea:	ce 01       	movw	r24, r28
    12ec:	4b d0       	rcall	.+150    	; 0x1384 <__simulator_exit>
    12ee:	ce 01       	movw	r24, r28
    12f0:	4a d0       	rcall	.+148    	; 0x1386 <_Exit>

Disassembly of section .text.__simple_malloc:

00000930 <__simple_malloc>:
 930:	a2 e0       	ldi	r26, 0x02	; 2
 932:	b0 e0       	ldi	r27, 0x00	; 0
 934:	ed e9       	ldi	r30, 0x9D	; 157
 936:	f4 e0       	ldi	r31, 0x04	; 4
 938:	26 c3       	rjmp	.+1612   	; 0xf86 <__prologue_saves__+0x14>
 93a:	8c 01       	movw	r16, r24
 93c:	80 e0       	ldi	r24, 0x00	; 0
 93e:	90 e0       	ldi	r25, 0x00	; 0
 940:	01 15       	cp	r16, r1
 942:	11 05       	cpc	r17, r1
 944:	09 f4       	brne	.+2      	; 0x948 <__simple_malloc+0x18>
 946:	53 c0       	rjmp	.+166    	; 0x9ee <__simple_malloc+0xbe>
 948:	89 2b       	or	r24, r25
 94a:	71 f0       	breq	.+28     	; 0x968 <__simple_malloc+0x38>
 94c:	02 30       	cpi	r16, 0x02	; 2
 94e:	11 05       	cpc	r17, r1
 950:	10 f4       	brcc	.+4      	; 0x956 <__simple_malloc+0x26>
 952:	02 e0       	ldi	r16, 0x02	; 2
 954:	10 e0       	ldi	r17, 0x00	; 0
 956:	c8 01       	movw	r24, r16
 958:	53 db       	rcall	.-2394   	; 0x0 <__TEXT_REGION_ORIGIN__>
 95a:	00 97       	sbiw	r24, 0x00	; 0
 95c:	09 f0       	breq	.+2      	; 0x960 <__simple_malloc+0x30>
 95e:	4e c0       	rjmp	.+156    	; 0x9fc <__simple_malloc+0xcc>
 960:	92 e0       	ldi	r25, 0x02	; 2
 962:	e9 2e       	mov	r14, r25
 964:	f1 2c       	mov	r15, r1
 966:	04 c0       	rjmp	.+8      	; 0x970 <__simple_malloc+0x40>
 968:	80 e0       	ldi	r24, 0x00	; 0
 96a:	e8 2e       	mov	r14, r24
 96c:	80 e0       	ldi	r24, 0x00	; 0
 96e:	f8 2e       	mov	r15, r24
 970:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <end.1483>
 974:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <end.1483+0x1>
 978:	20 91 a0 01 	lds	r18, 0x01A0	; 0x8001a0 <cur.1482>
 97c:	30 91 a1 01 	lds	r19, 0x01A1	; 0x8001a1 <cur.1482+0x1>
 980:	82 1b       	sub	r24, r18
 982:	93 0b       	sbc	r25, r19
 984:	67 01       	movw	r12, r14
 986:	c0 0e       	add	r12, r16
 988:	d1 1e       	adc	r13, r17
 98a:	80 17       	cp	r24, r16
 98c:	91 07       	cpc	r25, r17
 98e:	e8 f4       	brcc	.+58     	; 0x9ca <__simple_malloc+0x9a>
 990:	da 82       	std	Y+2, r13	; 0x02
 992:	c9 82       	std	Y+1, r12	; 0x01
 994:	ce 01       	movw	r24, r28
 996:	01 96       	adiw	r24, 0x01	; 1
 998:	71 d0       	rcall	.+226    	; 0xa7c <__expand_heap>
 99a:	00 97       	sbiw	r24, 0x00	; 0
 99c:	19 f4       	brne	.+6      	; 0x9a4 <__simple_malloc+0x74>
 99e:	80 e0       	ldi	r24, 0x00	; 0
 9a0:	90 e0       	ldi	r25, 0x00	; 0
 9a2:	2c c0       	rjmp	.+88     	; 0x9fc <__simple_malloc+0xcc>
 9a4:	20 91 9e 01 	lds	r18, 0x019E	; 0x80019e <end.1483>
 9a8:	30 91 9f 01 	lds	r19, 0x019F	; 0x80019f <end.1483+0x1>
 9ac:	82 17       	cp	r24, r18
 9ae:	93 07       	cpc	r25, r19
 9b0:	21 f0       	breq	.+8      	; 0x9ba <__simple_malloc+0x8a>
 9b2:	90 93 a1 01 	sts	0x01A1, r25	; 0x8001a1 <cur.1482+0x1>
 9b6:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <cur.1482>
 9ba:	29 81       	ldd	r18, Y+1	; 0x01
 9bc:	3a 81       	ldd	r19, Y+2	; 0x02
 9be:	82 0f       	add	r24, r18
 9c0:	93 1f       	adc	r25, r19
 9c2:	90 93 9f 01 	sts	0x019F, r25	; 0x80019f <end.1483+0x1>
 9c6:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <end.1483>
 9ca:	e0 91 a0 01 	lds	r30, 0x01A0	; 0x8001a0 <cur.1482>
 9ce:	f0 91 a1 01 	lds	r31, 0x01A1	; 0x8001a1 <cur.1482+0x1>
 9d2:	cf 01       	movw	r24, r30
 9d4:	e1 14       	cp	r14, r1
 9d6:	f1 04       	cpc	r15, r1
 9d8:	19 f0       	breq	.+6      	; 0x9e0 <__simple_malloc+0xb0>
 9da:	02 96       	adiw	r24, 0x02	; 2
 9dc:	11 83       	std	Z+1, r17	; 0x01
 9de:	00 83       	st	Z, r16
 9e0:	ce 0e       	add	r12, r30
 9e2:	df 1e       	adc	r13, r31
 9e4:	d0 92 a1 01 	sts	0x01A1, r13	; 0x8001a1 <cur.1482+0x1>
 9e8:	c0 92 a0 01 	sts	0x01A0, r12	; 0x8001a0 <cur.1482>
 9ec:	07 c0       	rjmp	.+14     	; 0x9fc <__simple_malloc+0xcc>
 9ee:	00 97       	sbiw	r24, 0x00	; 0
 9f0:	09 f0       	breq	.+2      	; 0x9f4 <__simple_malloc+0xc4>
 9f2:	af cf       	rjmp	.-162    	; 0x952 <__simple_malloc+0x22>
 9f4:	7c 01       	movw	r14, r24
 9f6:	01 e0       	ldi	r16, 0x01	; 1
 9f8:	10 e0       	ldi	r17, 0x00	; 0
 9fa:	ba cf       	rjmp	.-140    	; 0x970 <__simple_malloc+0x40>
 9fc:	22 96       	adiw	r28, 0x02	; 2
 9fe:	e8 e0       	ldi	r30, 0x08	; 8
 a00:	f9 c2       	rjmp	.+1522   	; 0xff4 <__epilogue_restores__+0x14>

Disassembly of section .text._Exit:

00001386 <_Exit>:
    1386:	20 d7       	rcall	.+3648   	; 0x21c8 <__TEXT_REGION_LENGTH__+0x1c8>

Disassembly of section .text.__expand_heap:

00000a7c <__expand_heap>:
 a7c:	fc 01       	movw	r30, r24
 a7e:	40 81       	ld	r20, Z
 a80:	51 81       	ldd	r21, Z+1	; 0x01
 a82:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <__brkval>
 a86:	90 91 a3 01 	lds	r25, 0x01A3	; 0x8001a3 <__brkval+0x1>
 a8a:	89 2b       	or	r24, r25
 a8c:	41 f4       	brne	.+16     	; 0xa9e <__expand_heap+0x22>
 a8e:	80 91 a6 01 	lds	r24, 0x01A6	; 0x8001a6 <__malloc_heap_start>
 a92:	90 91 a7 01 	lds	r25, 0x01A7	; 0x8001a7 <__malloc_heap_start+0x1>
 a96:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <__brkval+0x1>
 a9a:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <__brkval>
 a9e:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <__malloc_heap_end>
 aa2:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <__malloc_heap_end+0x1>
 aa6:	00 97       	sbiw	r24, 0x00	; 0
 aa8:	19 f4       	brne	.+6      	; 0xab0 <__expand_heap+0x34>
 aaa:	8d b7       	in	r24, 0x3d	; 61
 aac:	9e b7       	in	r25, 0x3e	; 62
 aae:	80 97       	sbiw	r24, 0x20	; 32
 ab0:	20 91 a2 01 	lds	r18, 0x01A2	; 0x8001a2 <__brkval>
 ab4:	30 91 a3 01 	lds	r19, 0x01A3	; 0x8001a3 <__brkval+0x1>
 ab8:	28 17       	cp	r18, r24
 aba:	39 07       	cpc	r19, r25
 abc:	48 f0       	brcs	.+18     	; 0xad0 <__expand_heap+0x54>
 abe:	8c e0       	ldi	r24, 0x0C	; 12
 ac0:	90 e0       	ldi	r25, 0x00	; 0
 ac2:	90 93 85 01 	sts	0x0185, r25	; 0x800185 <__errno_val+0x1>
 ac6:	80 93 84 01 	sts	0x0184, r24	; 0x800184 <__errno_val>
 aca:	80 e0       	ldi	r24, 0x00	; 0
 acc:	90 e0       	ldi	r25, 0x00	; 0
 ace:	08 95       	ret
 ad0:	82 1b       	sub	r24, r18
 ad2:	93 0b       	sbc	r25, r19
 ad4:	84 17       	cp	r24, r20
 ad6:	95 07       	cpc	r25, r21
 ad8:	90 f3       	brcs	.-28     	; 0xabe <__expand_heap+0x42>
 ada:	42 0f       	add	r20, r18
 adc:	53 1f       	adc	r21, r19
 ade:	50 93 a3 01 	sts	0x01A3, r21	; 0x8001a3 <__brkval+0x1>
 ae2:	40 93 a2 01 	sts	0x01A2, r20	; 0x8001a2 <__brkval>
 ae6:	c9 01       	movw	r24, r18
 ae8:	08 95       	ret

Disassembly of section .text.avrlibc:

0000116c <eeprom_read_block>:
    116c:	ba 01       	movw	r22, r20
    116e:	a9 01       	movw	r20, r18
    1170:	dc 01       	movw	r26, r24
    1172:	cb 01       	movw	r24, r22

00001174 <eeprom_read_blraw>:
    1174:	fc 01       	movw	r30, r24
    1176:	f9 99       	sbic	0x1f, 1	; 31
    1178:	fe cf       	rjmp	.-4      	; 0x1176 <eeprom_read_blraw+0x2>
    117a:	06 c0       	rjmp	.+12     	; 0x1188 <eeprom_read_blraw+0x14>
    117c:	f2 bd       	out	0x22, r31	; 34
    117e:	e1 bd       	out	0x21, r30	; 33
    1180:	f8 9a       	sbi	0x1f, 0	; 31
    1182:	31 96       	adiw	r30, 0x01	; 1
    1184:	00 b4       	in	r0, 0x20	; 32
    1186:	0d 92       	st	X+, r0
    1188:	41 50       	subi	r20, 0x01	; 1
    118a:	50 40       	sbci	r21, 0x00	; 0
    118c:	b8 f7       	brcc	.-18     	; 0x117c <eeprom_read_blraw+0x8>
    118e:	08 95       	ret

Disassembly of section .text.avrlibc:

000012c4 <eeprom_read_byte>:
    12c4:	cb 01       	movw	r24, r22
    12c6:	f9 99       	sbic	0x1f, 1	; 31
    12c8:	fe cf       	rjmp	.-4      	; 0x12c6 <eeprom_read_byte+0x2>
    12ca:	92 bd       	out	0x22, r25	; 34
    12cc:	81 bd       	out	0x21, r24	; 33
    12ce:	f8 9a       	sbi	0x1f, 0	; 31
    12d0:	99 27       	eor	r25, r25
    12d2:	80 b5       	in	r24, 0x20	; 32
    12d4:	08 95       	ret

Disassembly of section .text.avrlibc:

00001322 <eeprom_read_word>:
    1322:	cb 01       	movw	r24, r22
    1324:	a8 e1       	ldi	r26, 0x18	; 24
    1326:	b0 e0       	ldi	r27, 0x00	; 0
    1328:	42 e0       	ldi	r20, 0x02	; 2
    132a:	50 e0       	ldi	r21, 0x00	; 0
    132c:	23 cf       	rjmp	.-442    	; 0x1174 <eeprom_read_blraw>

Disassembly of section .text.avrlibc:

0000104a <eeprom_write_block>:
    104a:	cf 92       	push	r12
    104c:	df 92       	push	r13
    104e:	ef 92       	push	r14
    1050:	6b 01       	movw	r12, r22
    1052:	e8 2e       	mov	r14, r24
    1054:	ca 01       	movw	r24, r20
    1056:	42 2f       	mov	r20, r18
    1058:	73 2f       	mov	r23, r19
    105a:	09 c0       	rjmp	.+18     	; 0x106e <eeprom_write_block+0x24>
    105c:	f6 01       	movw	r30, r12
    105e:	5e 2d       	mov	r21, r14
    1060:	6b d1       	rcall	.+726    	; 0x1338 <__xload_1>
    1062:	26 2f       	mov	r18, r22
    1064:	c9 d0       	rcall	.+402    	; 0x11f8 <eeprom_write_r18>
    1066:	3f ef       	ldi	r19, 0xFF	; 255
    1068:	c3 1a       	sub	r12, r19
    106a:	d3 0a       	sbc	r13, r19
    106c:	e3 0a       	sbc	r14, r19
    106e:	41 50       	subi	r20, 0x01	; 1
    1070:	70 40       	sbci	r23, 0x00	; 0
    1072:	a0 f7       	brcc	.-24     	; 0x105c <eeprom_write_block+0x12>
    1074:	ef 90       	pop	r14
    1076:	df 90       	pop	r13
    1078:	cf 90       	pop	r12
    107a:	08 95       	ret

Disassembly of section .text.avrlibc:

000011f6 <eeprom_write_byte>:
    11f6:	26 2f       	mov	r18, r22

000011f8 <eeprom_write_r18>:
    11f8:	f9 99       	sbic	0x1f, 1	; 31
    11fa:	fe cf       	rjmp	.-4      	; 0x11f8 <eeprom_write_r18>
    11fc:	1f ba       	out	0x1f, r1	; 31
    11fe:	92 bd       	out	0x22, r25	; 34
    1200:	81 bd       	out	0x21, r24	; 33
    1202:	20 bd       	out	0x20, r18	; 32
    1204:	0f b6       	in	r0, 0x3f	; 63
    1206:	f8 94       	cli
    1208:	fa 9a       	sbi	0x1f, 2	; 31
    120a:	f9 9a       	sbi	0x1f, 1	; 31
    120c:	0f be       	out	0x3f, r0	; 63
    120e:	01 96       	adiw	r24, 0x01	; 1
    1210:	08 95       	ret

Disassembly of section .text.avrlibc:

00001374 <eeprom_write_word>:
    1374:	40 df       	rcall	.-384    	; 0x11f6 <eeprom_write_byte>
    1376:	27 2f       	mov	r18, r23
    1378:	3f cf       	rjmp	.-386    	; 0x11f8 <eeprom_write_r18>

Disassembly of section .text.libgcc.prologue:

00000f72 <__prologue_saves__>:
 f72:	2f 92       	push	r2
 f74:	3f 92       	push	r3
 f76:	4f 92       	push	r4
 f78:	5f 92       	push	r5
 f7a:	6f 92       	push	r6
 f7c:	7f 92       	push	r7
 f7e:	8f 92       	push	r8
 f80:	9f 92       	push	r9
 f82:	af 92       	push	r10
 f84:	bf 92       	push	r11
 f86:	cf 92       	push	r12
 f88:	df 92       	push	r13
 f8a:	ef 92       	push	r14
 f8c:	ff 92       	push	r15
 f8e:	0f 93       	push	r16
 f90:	1f 93       	push	r17
 f92:	cf 93       	push	r28
 f94:	df 93       	push	r29
 f96:	cd b7       	in	r28, 0x3d	; 61
 f98:	de b7       	in	r29, 0x3e	; 62
 f9a:	ca 1b       	sub	r28, r26
 f9c:	db 0b       	sbc	r29, r27
 f9e:	0f b6       	in	r0, 0x3f	; 63
 fa0:	f8 94       	cli
 fa2:	de bf       	out	0x3e, r29	; 62
 fa4:	0f be       	out	0x3f, r0	; 63
 fa6:	cd bf       	out	0x3d, r28	; 61
 fa8:	09 94       	ijmp

Disassembly of section .text.libgcc.prologue:

00000fe0 <__epilogue_restores__>:
     fe0:	2a 88       	ldd	r2, Y+18	; 0x12
     fe2:	39 88       	ldd	r3, Y+17	; 0x11
     fe4:	48 88       	ldd	r4, Y+16	; 0x10
     fe6:	5f 84       	ldd	r5, Y+15	; 0x0f
     fe8:	6e 84       	ldd	r6, Y+14	; 0x0e
     fea:	7d 84       	ldd	r7, Y+13	; 0x0d
     fec:	8c 84       	ldd	r8, Y+12	; 0x0c
     fee:	9b 84       	ldd	r9, Y+11	; 0x0b
     ff0:	aa 84       	ldd	r10, Y+10	; 0x0a
     ff2:	b9 84       	ldd	r11, Y+9	; 0x09
     ff4:	c8 84       	ldd	r12, Y+8	; 0x08
     ff6:	df 80       	ldd	r13, Y+7	; 0x07
     ff8:	ee 80       	ldd	r14, Y+6	; 0x06
     ffa:	fd 80       	ldd	r15, Y+5	; 0x05
     ffc:	0c 81       	ldd	r16, Y+4	; 0x04
     ffe:	1b 81       	ldd	r17, Y+3	; 0x03
    1000:	aa 81       	ldd	r26, Y+2	; 0x02
    1002:	b9 81       	ldd	r27, Y+1	; 0x01
    1004:	ce 0f       	add	r28, r30
    1006:	d1 1d       	adc	r29, r1
    1008:	0f b6       	in	r0, 0x3f	; 63
    100a:	f8 94       	cli
    100c:	de bf       	out	0x3e, r29	; 62
    100e:	0f be       	out	0x3f, r0	; 63
    1010:	cd bf       	out	0x3d, r28	; 61
    1012:	ed 01       	movw	r28, r26
    1014:	08 95       	ret

Disassembly of section .text.libgcc:

00001338 <__xload_1>:
    1338:	57 fd       	sbrc	r21, 7
    133a:	60 81       	ld	r22, Z
    133c:	57 ff       	sbrs	r21, 7
    133e:	64 91       	lpm	r22, Z
    1340:	08 95       	ret
