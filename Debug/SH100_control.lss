
SH100_control.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00001dcf  2**0
                  ALLOC, LOAD, DATA
  1 .text         000000cc  00000000  00000000  00000154  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000085  00800100  00800100  00001dcf  2**0
                  ALLOC
  3 .comment      0000002f  00000000  00000000  00001dcf  2**0
                  CONTENTS, READONLY
  4 .stack.descriptors.hdr 000000a8  00000000  00000000  00001dfe  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 000003f8  00000000  00000000  00001ea8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000794c  00000000  00000000  000022a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000013a2  00000000  00000000  00009bec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002409  00000000  00000000  0000af8e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000824  00000000  00000000  0000d398  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000085b  00000000  00000000  0000dbbc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001dc8  00000000  00000000  0000e417  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002c0  00000000  00000000  000101df  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .text         00000002  00001c56  00001c56  00001daa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000104a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .text.FSW_Init 00000056  0000130c  0000130c  00001460  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.FSW_SetMode 0000000e  00001b8e  00001b8e  00001ce2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.FSW_MainTask 0000020c  00000564  00000564  000006b8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.FSW_BlockFrontControls 0000001c  00001a3e  00001a3e  00001b92  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .data.zzCh34  00000001  0080019d  00001c78  00001dcc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 20 .bss.zzCh12   00000001  0080019e  0080019e  00001dcf  2**0
                  ALLOC
 21 .text.FBTNS_MainTask 0000024e  000000d0  000000d0  00000224  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .bss.abSwitched 00000001  0080019f  0080019f  00001dcf  2**0
                  ALLOC
 23 .bss.loopSwitched 00000001  008001a0  008001a0  00001dcf  2**0
                  ALLOC
 24 .bss.setFSWRelayMode_cnt 00000001  008001a1  008001a1  00001dcf  2**0
                  ALLOC
 25 .bss.setFSWZigzagMode_cnt 00000001  008001a2  008001a2  00001dcf  2**0
                  ALLOC
 26 .bss.setFSWRingMode_cnt 00000001  008001a3  008001a3  00001dcf  2**0
                  ALLOC
 27 .bss.leaveDefSettings_cnt 00000001  008001a4  008001a4  00001dcf  2**0
                  ALLOC
 28 .bss.swProgrammingMode_cnt 00000001  008001a5  008001a5  00001dcf  2**0
                  ALLOC
 29 .data.protectionInterval_cnt 00000001  008001a6  00001c79  00001dcd  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 30 .text.__portable_avr_delay_cycles 00000016  00001b28  00001b28  00001c7c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.initTest 000000d8  00000c64  00000c64  00000db8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .text.ISRInit 0000002a  0000191e  0000191e  00001a72  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .text.main    00000014  00001b54  00001b54  00001ca8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 34 .text.__vector_16 000000b2  00000dfe  00000dfe  00000f52  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 35 .text.__vector_21 000000c2  00000d3c  00000d3c  00000e90  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 36 .text.__vector_4 00000048  0000149c  0000149c  000015f0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 37 .bss.measSwitch 00000001  008001a7  008001a7  00001dcf  2**0
                  ALLOC
 38 .bss.isAmpStarted 00000001  008001a8  008001a8  00001dcf  2**0
                  ALLOC
 39 .text.MIDI_IsStatusWord 00000008  00001c0c  00001c0c  00001d60  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 40 .text.MIDI_IsSysRealTime 0000000c  00001bd4  00001bd4  00001d28  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 41 .text.MIDI_GetStatusType 00000070  0000110c  0000110c  00001260  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 42 .text.isEqualCommands 00000042  00001572  00001572  000016c6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 43 .text.loadCommSetFromMemory 0000007a  00000eb0  00000eb0  00001004  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 44 .text.setMidiLeds 00000052  00001362  00001362  000014b6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 45 .text.MIDICTRL_Init 0000000e  00001b9c  00001b9c  00001cf0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 46 .text.MIDICTRL_MidiMode 00000006  00001c1c  00001c1c  00001d70  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 47 .text.MIDICTRL_SetProgrammingButton 0000002e  00001896  00001896  000019ea  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 48 .text.MIDICTRL_EnterProgrammingMode 00000038  000016f2  000016f2  00001846  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 49 .text.MIDICTRL_SetMidiChannel 00000006  00001c22  00001c22  00001d76  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 50 .text.MIDICTRL_OmniModeEn 00000006  00001c28  00001c28  00001d7c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 51 .text.MIDICTRL_MuteCommEn 00000006  00001c2e  00001c2e  00001d82  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 52 .text.programmBtn 0000004c  00001450  00001450  000015a4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .text.MIDICTRL_SendSwChComm 0000006a  0000117c  0000117c  000012d0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .text.MIDICTRL_SendLoopEnComm 00000034  00001762  00001762  000018b6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 55 .text.MIDICTRL_SendSwABComm 00000034  00001796  00001796  000018ea  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 56 .text.MIDICTRL_StoreUserCommands 0000003e  00001678  00001678  000017cc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 57 .text.MIDICTRL_DiscardCommands 00000022  000019b8  000019b8  00001b0c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .text.indicateMidiError 00000038  0000172a  0000172a  0000187e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .text.MIDICTRL_HandleCommand 000001f2  00000770  00000770  000008c4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 60 .text.__vector_13 00000064  000011e6  000011e6  0000133a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 61 .data.defaultCommands 00000018  00800185  00001c60  00001db4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 62 .progmemx.data.muteCommand 00000004  000000cc  000000cc  00000220  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, PROGMEMX
 63 .bss.channelNum 00000001  008001a9  008001a9  00001dcf  2**0
                  ALLOC
 64 .bss.muteCommandEnabled 00000001  008001aa  008001aa  00001dcf  2**0
                  ALLOC
 65 .bss.omniModeEnabled 00000001  008001ab  008001ab  00001dcf  2**0
                  ALLOC
 66 .text.handleRealTimeStatus 00000004  00001c52  00001c52  00001da6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 67 .text.MIDI_ParserTask 00000142  00000b22  00000b22  00000c76  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 68 .text.MIDI_SetRetranslateState 00000006  00001c34  00001c34  00001d88  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 69 .text.MIDI_SendCommand 00000078  00000fa4  00000fa4  000010f8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 70 .bss.state    00000001  008001ac  008001ac  00001dcf  2**0
                  ALLOC
 71 .data.retranslate 00000001  008001ad  00001c7a  00001dce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 72 .text.SH100CTRL_GetAmpState 00000042  000015b4  000015b4  00001708  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 73 .text.setChannelLeds 00000022  000019da  000019da  00001b2e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 74 .text.SH100CTRL_SetAmpLeds 0000002e  000018c4  000018c4  00001a18  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 75 .text.SH100CTRL_StoreAmpState 0000001c  00001a5a  00001a5a  00001bae  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 76 .text.SH100CTRL_SetLoop 00000028  00001948  00001948  00001a9c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 77 .text.SH100CTRL_SetChannel 00000020  00001a1e  00001a1e  00001b72  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 78 .text.SH100CTRL_FsSetChannel 00000016  00001b3e  00001b3e  00001c92  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 79 .text.SH100CTRL_SwLoop 00000034  000017ca  000017ca  0000191e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 80 .text.SH100CTRL_BtnSetChannel 0000001c  00001a76  00001a76  00001bca  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 81 .text.SH100CTRL_SetAB 00000022  000019fc  000019fc  00001b50  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 82 .text.SH100CTRL_SetAmpState 00000032  00001832  00001832  00001986  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 83 .text.SH100CTRL_Init 00000078  0000101c  0000101c  00001170  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 84 .text.SH100CTRL_SwAB 00000024  00001970  00001970  00001ac4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 85 .text.SH100CTRL_MuteAmp 00000006  00001c3a  00001c3a  00001d8e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 86 .text.SH100CTRL_UnmuteAmp 0000000c  00001be0  00001be0  00001d34  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 87 .text.SH100CTRL_CheckOutputJacks 00000078  00001094  00001094  000011e8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 88 .text.SH100HW_Init 00000062  0000124a  0000124a  0000139e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 89 .text.SH100HW_SetPAFailure 0000000e  00001baa  00001baa  00001cfe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 90 .text.SH100HW_GetPAFailure 0000000a  00001bf8  00001bf8  00001d4c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 91 .text.SH100HW_SetCh 0000004e  000013b4  000013b4  00001508  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 92 .text.SH100HW_LoopEn 00000018  00001ac8  00001ac8  00001c1c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 93 .text.SH100HW_SetAB 00000006  00001c40  00001c40  00001d94  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 94 .text.SH100HW_SetNewLedState 0000002c  000018f2  000018f2  00001a46  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 95 .text.SH100HW_SetPreviousLedState 00000018  00001ae0  00001ae0  00001c34  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 96 .text.SH100HW_SetLedBlinkCount 00000040  00001638  00001638  0000178c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 97 .text.SH100HW_GetOutputJacks 00000018  00001af8  00001af8  00001c4c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 98 .text.SH100HW_SetPAState 0000003c  000016b6  000016b6  0000180a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 99 .text.SH100HW_SetOutputMode 00000006  00001c46  00001c46  00001d9a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
100 .text.SH100HW_StartADConvertion 00000014  00001b68  00001b68  00001cbc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
101 .text.SH100HW_GetControlsState 000001c0  00000962  00000962  00000ab6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
102 .text.writeShiftRegs 00000042  000015f6  000015f6  0000174a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
103 .text.SH100HW_MainTask 00000246  0000031e  0000031e  00000472  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
104 .bss.fastBlink 00000001  008001ae  008001ae  00001dcf  2**0
                  ALLOC
105 .bss.slowBlink 00000001  008001af  008001af  00001dcf  2**0
                  ALLOC
106 .bss.blinkCounter 00000001  008001b0  008001b0  00001dcf  2**0
                  ALLOC
107 .text.UART_init 00000018  00001b10  00001b10  00001c64  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
108 .text.__vector_18 00000060  000012ac  000012ac  00001400  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
109 .text.UART_PopWord 00000034  000017fe  000017fe  00001952  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
110 .text.UART_RxBufferNotEmpty 0000000e  00001bb8  00001bb8  00001d0c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
111 .text.__vector_20 0000004e  00001402  00001402  00001556  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
112 .text.UART_PushWord 00000046  0000152c  0000152c  00001680  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
113 .text         0000007a  00000f2a  00000f2a  0000107e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
114 .text         00000008  00001c14  00001c14  00001d68  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
115 .text         00000048  000014e4  000014e4  00001638  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
116 .text.libgcc  0000001a  00001aae  00001aae  00001c02  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
117 .text.__dummy_fini 00000002  00001c58  00001c58  00001dac  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
118 .text.__dummy_funcs_on_exit 00000002  00001c5a  00001c5a  00001dae  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
119 .text.__dummy_simulator_exit 00000002  00001c5c  00001c5c  00001db0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
120 .text.exit    0000000e  00001bc6  00001bc6  00001d1a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
121 .text._Exit   00000002  00001c5e  00001c5e  00001db2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
122 .text.avrlibc 00000024  00001994  00001994  00001ae8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
123 .text.avrlibc 00000012  00001b7c  00001b7c  00001cd0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
124 .text.avrlibc 0000000c  00001bec  00001bec  00001d40  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
125 .text.avrlibc 00000032  00001864  00001864  000019b8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
126 .text.avrlibc 0000001c  00001a92  00001a92  00001be6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
127 .text.avrlibc 00000006  00001c4c  00001c4c  00001da0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
128 .text.libgcc  0000000a  00001c02  00001c02  00001d56  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	3d c0       	rjmp	.+122    	; 0x7c <__ctors_end>
   2:	29 ce       	rjmp	.-942    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
   4:	28 ce       	rjmp	.-944    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
   6:	27 ce       	rjmp	.-946    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
   8:	49 ca       	rjmp	.-2926   	; 0xfffff49c <__eeprom_end+0xff7ef49c>
   a:	25 ce       	rjmp	.-950    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
   c:	24 ce       	rjmp	.-952    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
   e:	23 ce       	rjmp	.-954    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  10:	22 ce       	rjmp	.-956    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  12:	21 ce       	rjmp	.-958    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  14:	20 ce       	rjmp	.-960    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  16:	1f ce       	rjmp	.-962    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  18:	1e ce       	rjmp	.-964    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  1a:	e5 c8       	rjmp	.-3638   	; 0xfffff1e6 <__eeprom_end+0xff7ef1e6>
  1c:	1c ce       	rjmp	.-968    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  1e:	1b ce       	rjmp	.-970    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  20:	ee c6       	rjmp	.+3548   	; 0xdfe <__vector_16>
  22:	19 ce       	rjmp	.-974    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  24:	43 c9       	rjmp	.-3450   	; 0xfffff2ac <__eeprom_end+0xff7ef2ac>
  26:	17 ce       	rjmp	.-978    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  28:	ec c9       	rjmp	.-3112   	; 0xfffff402 <__eeprom_end+0xff7ef402>
  2a:	88 c6       	rjmp	.+3344   	; 0xd3c <__vector_21>
  2c:	14 ce       	rjmp	.-984    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  2e:	13 ce       	rjmp	.-986    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  30:	12 ce       	rjmp	.-988    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  32:	11 ce       	rjmp	.-990    	; 0xfffffc56 <__eeprom_end+0xff7efc56>
  34:	82 c5       	rjmp	.+2820   	; 0xb3a <MIDI_ParserTask+0x18>
  36:	8e c5       	rjmp	.+2844   	; 0xb54 <MIDI_ParserTask+0x32>
  38:	cd c5       	rjmp	.+2970   	; 0xbd4 <MIDI_ParserTask+0xb2>
  3a:	fb c5       	rjmp	.+3062   	; 0xc32 <MIDI_ParserTask+0x110>
  3c:	e0 c5       	rjmp	.+3008   	; 0xbfe <MIDI_ParserTask+0xdc>
  3e:	05 c6       	rjmp	.+3082   	; 0xc4a <MIDI_ParserTask+0x128>
  40:	08 c6       	rjmp	.+3088   	; 0xc52 <MIDI_ParserTask+0x130>
  42:	9e c4       	rjmp	.+2364   	; 0x980 <SH100HW_GetControlsState+0x1e>
  44:	b3 c4       	rjmp	.+2406   	; 0x9ac <SH100HW_GetControlsState+0x4a>
  46:	cc c4       	rjmp	.+2456   	; 0x9e0 <SH100HW_GetControlsState+0x7e>
  48:	e5 c4       	rjmp	.+2506   	; 0xa14 <SH100HW_GetControlsState+0xb2>
  4a:	fa c4       	rjmp	.+2548   	; 0xa40 <SH100HW_GetControlsState+0xde>
  4c:	13 c5       	rjmp	.+2598   	; 0xa74 <SH100HW_GetControlsState+0x112>
  4e:	22 c5       	rjmp	.+2628   	; 0xa94 <SH100HW_GetControlsState+0x132>
  50:	3b c5       	rjmp	.+2678   	; 0xac8 <SH100HW_GetControlsState+0x166>

00000052 <.dinit>:
  52:	01 00       	.word	0x0001	; ????
  54:	01 85       	ldd	r16, Z+9	; 0x09
  56:	80 01       	movw	r16, r0
  58:	85 01       	movw	r16, r10
  5a:	9e 00       	.word	0x009e	; ????
  5c:	1c 60       	ori	r17, 0x0C	; 12
  5e:	01 9e       	mul	r0, r17
  60:	01 a6       	std	Z+41, r0	; 0x29
  62:	80 01       	movw	r16, r0
  64:	a6 01       	movw	r20, r12
  66:	a7 00       	.word	0x00a7	; ????
  68:	1c 79       	andi	r17, 0x9C	; 156
  6a:	01 a7       	std	Z+41, r16	; 0x29
  6c:	01 ad       	ldd	r16, Z+57	; 0x39
  6e:	80 01       	movw	r16, r0
  70:	ad 01       	movw	r20, r26
  72:	ae 00       	.word	0x00ae	; ????
  74:	1c 7a       	andi	r17, 0xAC	; 172
  76:	01 ae       	std	Z+57, r0	; 0x39
  78:	01 b1       	in	r16, 0x01	; 1
  7a:	80 00       	.word	0x0080	; ????

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d4 e0       	ldi	r29, 0x04	; 4
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
  88:	e2 e5       	ldi	r30, 0x52	; 82
  8a:	f0 e0       	ldi	r31, 0x00	; 0
  8c:	40 e0       	ldi	r20, 0x00	; 0
  8e:	17 c0       	rjmp	.+46     	; 0xbe <__do_clear_bss+0x8>
  90:	b5 91       	lpm	r27, Z+
  92:	a5 91       	lpm	r26, Z+
  94:	35 91       	lpm	r19, Z+
  96:	25 91       	lpm	r18, Z+
  98:	05 91       	lpm	r16, Z+
  9a:	07 fd       	sbrc	r16, 7
  9c:	0c c0       	rjmp	.+24     	; 0xb6 <__do_clear_bss>
  9e:	95 91       	lpm	r25, Z+
  a0:	85 91       	lpm	r24, Z+
  a2:	ef 01       	movw	r28, r30
  a4:	f9 2f       	mov	r31, r25
  a6:	e8 2f       	mov	r30, r24
  a8:	05 90       	lpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a2 17       	cp	r26, r18
  ae:	b3 07       	cpc	r27, r19
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x20>
  b2:	fe 01       	movw	r30, r28
  b4:	04 c0       	rjmp	.+8      	; 0xbe <__do_clear_bss+0x8>

000000b6 <__do_clear_bss>:
  b6:	1d 92       	st	X+, r1
  b8:	a2 17       	cp	r26, r18
  ba:	b3 07       	cpc	r27, r19
  bc:	e1 f7       	brne	.-8      	; 0xb6 <__do_clear_bss>
  be:	eb 37       	cpi	r30, 0x7B	; 123
  c0:	f4 07       	cpc	r31, r20
  c2:	31 f7       	brne	.-52     	; 0x90 <__do_copy_data+0x8>
  c4:	47 dd       	rcall	.-1394   	; 0xfffffb54 <__eeprom_end+0xff7efb54>
  c6:	7f cd       	rjmp	.-1282   	; 0xfffffbc6 <__eeprom_end+0xff7efbc6>

000000c8 <_exit>:
  c8:	f8 94       	cli

000000ca <__stop_program>:
  ca:	ff cf       	rjmp	.-2      	; 0xca <__stop_program>

Disassembly of section .text:

00001c56 <__bad_interrupt>:
    1c56:	d4 c1       	rjmp	.+936    	; 0x2000 <__TEXT_REGION_LENGTH__>

Disassembly of section .text.FSW_Init:

0000130c <FSW_Init>:
FSW_SwitchMode_t switchMode;
SH100HW_Controls_t ctrlsPrevState;
uint8_t protectionInterval_cnt;

void FSW_Init()
{
    130c:	cf 93       	push	r28
    130e:	df 93       	push	r29
    1310:	cd b7       	in	r28, 0x3d	; 61
    1312:	de b7       	in	r29, 0x3e	; 62
    1314:	2f 97       	sbiw	r28, 0x0f	; 15
    1316:	0f b6       	in	r0, 0x3f	; 63
    1318:	f8 94       	cli
    131a:	de bf       	out	0x3e, r29	; 62
    131c:	0f be       	out	0x3f, r0	; 63
    131e:	cd bf       	out	0x3d, r28	; 61
	switchMode = eeprom_read_byte((uint8_t*)MEMORY_FSW_MODE_OFFSET);
    1320:	67 e0       	ldi	r22, 0x07	; 7
    1322:	70 e0       	ldi	r23, 0x00	; 0
    1324:	80 e8       	ldi	r24, 0x80	; 128
    1326:	2a d4       	rcall	.+2132   	; 0x1b7c <eeprom_read_byte>
    1328:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
	
	if(switchMode > 2) switchMode = 0;
    132c:	83 30       	cpi	r24, 0x03	; 3
    132e:	10 f0       	brcs	.+4      	; 0x1334 <FSW_Init+0x28>
    1330:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <_edata>
	
	ctrlsPrevState = SH100HW_GetControlsState();
    1334:	ce 01       	movw	r24, r28
    1336:	01 96       	adiw	r24, 0x01	; 1
    1338:	14 db       	rcall	.-2520   	; 0x962 <SH100HW_GetControlsState>
    133a:	8f e0       	ldi	r24, 0x0F	; 15
    133c:	fe 01       	movw	r30, r28
    133e:	31 96       	adiw	r30, 0x01	; 1
    1340:	a1 e0       	ldi	r26, 0x01	; 1
    1342:	b1 e0       	ldi	r27, 0x01	; 1
    1344:	01 90       	ld	r0, Z+
    1346:	0d 92       	st	X+, r0
    1348:	8a 95       	dec	r24
    134a:	e1 f7       	brne	.-8      	; 0x1344 <FSW_Init+0x38>
	protectionInterval_cnt = 0;
    134c:	10 92 a6 01 	sts	0x01A6, r1	; 0x8001a6 <protectionInterval_cnt>
}
    1350:	2f 96       	adiw	r28, 0x0f	; 15
    1352:	0f b6       	in	r0, 0x3f	; 63
    1354:	f8 94       	cli
    1356:	de bf       	out	0x3e, r29	; 62
    1358:	0f be       	out	0x3f, r0	; 63
    135a:	cd bf       	out	0x3d, r28	; 61
    135c:	df 91       	pop	r29
    135e:	cf 91       	pop	r28
    1360:	08 95       	ret

Disassembly of section .text.FSW_SetMode:

00001b8e <FSW_SetMode>:

void FSW_SetMode(FSW_SwitchMode_t newSwitchMode)
{
	switchMode = newSwitchMode;
    1b8e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
	eeprom_write_byte((uint8_t*)MEMORY_FSW_MODE_OFFSET, switchMode);
    1b92:	68 2f       	mov	r22, r24
    1b94:	87 e0       	ldi	r24, 0x07	; 7
    1b96:	90 e0       	ldi	r25, 0x00	; 0
    1b98:	7c df       	rcall	.-264    	; 0x1a92 <eeprom_write_byte>
    1b9a:	08 95       	ret

Disassembly of section .text.FSW_MainTask:

00000564 <FSW_MainTask>:

#define FSW_PROTECTION_INTERVAL 100
uint8_t zzCh12 = SH100_CHANNEL1;
uint8_t zzCh34 = SH100_CHANNEL3;
void FSW_MainTask(const SH100HW_Controls_t* activatedCtrls)
{
 564:	cf 92       	push	r12
 566:	df 92       	push	r13
 568:	ef 92       	push	r14
 56a:	0f 93       	push	r16
 56c:	1f 93       	push	r17
 56e:	cf 93       	push	r28
 570:	df 93       	push	r29
 572:	cd b7       	in	r28, 0x3d	; 61
 574:	de b7       	in	r29, 0x3e	; 62
 576:	62 97       	sbiw	r28, 0x12	; 18
 578:	0f b6       	in	r0, 0x3f	; 63
 57a:	f8 94       	cli
 57c:	de bf       	out	0x3e, r29	; 62
 57e:	0f be       	out	0x3f, r0	; 63
 580:	cd bf       	out	0x3d, r28	; 61
 582:	6b 01       	movw	r12, r22
 584:	e8 2e       	mov	r14, r24
	if(protectionInterval_cnt == 0)
 586:	80 91 a6 01 	lds	r24, 0x01A6	; 0x8001a6 <protectionInterval_cnt>
 58a:	81 11       	cpse	r24, r1
 58c:	da c0       	rjmp	.+436    	; 0x742 <FSW_MainTask+0x1de>
	{		
		if (activatedCtrls->FS1_presence == FSW_PRESENT)
 58e:	ae 2d       	mov	r26, r14
 590:	c6 01       	movw	r24, r12
 592:	0b 96       	adiw	r24, 0x0b	; 11
 594:	a1 1d       	adc	r26, r1
 596:	fc 01       	movw	r30, r24
 598:	84 91       	lpm	r24, Z
 59a:	a7 fd       	sbrc	r26, 7
 59c:	80 81       	ld	r24, Z
 59e:	81 30       	cpi	r24, 0x01	; 1
 5a0:	09 f0       	breq	.+2      	; 0x5a4 <FSW_MainTask+0x40>
 5a2:	a4 c0       	rjmp	.+328    	; 0x6ec <FSW_MainTask+0x188>
		{
			switch(switchMode)
 5a4:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
 5a8:	81 30       	cpi	r24, 0x01	; 1
 5aa:	09 f4       	brne	.+2      	; 0x5ae <FSW_MainTask+0x4a>
 5ac:	63 c0       	rjmp	.+198    	; 0x674 <FSW_MainTask+0x110>
 5ae:	48 f1       	brcs	.+82     	; 0x602 <FSW_MainTask+0x9e>
 5b0:	82 30       	cpi	r24, 0x02	; 2
 5b2:	09 f0       	breq	.+2      	; 0x5b6 <FSW_MainTask+0x52>
 5b4:	9b c0       	rjmp	.+310    	; 0x6ec <FSW_MainTask+0x188>
			{		
				case FSW_RELAY:
				{
					uint8_t channelNum = (!(activatedCtrls->FS1_sleeve) << 1) | (!(activatedCtrls->FS1_tip));
 5b6:	ae 2d       	mov	r26, r14
 5b8:	c6 01       	movw	r24, r12
 5ba:	09 96       	adiw	r24, 0x09	; 9
 5bc:	a1 1d       	adc	r26, r1
 5be:	fc 01       	movw	r30, r24
 5c0:	84 91       	lpm	r24, Z
 5c2:	a7 fd       	sbrc	r26, 7
 5c4:	80 81       	ld	r24, Z
 5c6:	81 11       	cpse	r24, r1
 5c8:	02 c0       	rjmp	.+4      	; 0x5ce <FSW_MainTask+0x6a>
 5ca:	12 e0       	ldi	r17, 0x02	; 2
 5cc:	01 c0       	rjmp	.+2      	; 0x5d0 <FSW_MainTask+0x6c>
 5ce:	10 e0       	ldi	r17, 0x00	; 0
 5d0:	ae 2d       	mov	r26, r14
 5d2:	c6 01       	movw	r24, r12
 5d4:	0a 96       	adiw	r24, 0x0a	; 10
 5d6:	a1 1d       	adc	r26, r1
 5d8:	fc 01       	movw	r30, r24
 5da:	94 91       	lpm	r25, Z
 5dc:	a7 fd       	sbrc	r26, 7
 5de:	90 81       	ld	r25, Z
 5e0:	81 e0       	ldi	r24, 0x01	; 1
 5e2:	91 11       	cpse	r25, r1
 5e4:	80 e0       	ldi	r24, 0x00	; 0
 5e6:	18 2b       	or	r17, r24
			
					if(SH100CTRL_GetAmpState().channelNum != channelNum)
 5e8:	e5 d7       	rcall	.+4042   	; 0x15b4 <SH100CTRL_GetAmpState>
 5ea:	2d 87       	std	Y+13, r18	; 0x0d
 5ec:	3e 87       	std	Y+14, r19	; 0x0e
 5ee:	4f 87       	std	Y+15, r20	; 0x0f
 5f0:	58 8b       	std	Y+16, r21	; 0x10
 5f2:	69 8b       	std	Y+17, r22	; 0x11
 5f4:	7a 8b       	std	Y+18, r23	; 0x12
 5f6:	12 17       	cp	r17, r18
 5f8:	09 f4       	brne	.+2      	; 0x5fc <FSW_MainTask+0x98>
 5fa:	78 c0       	rjmp	.+240    	; 0x6ec <FSW_MainTask+0x188>
					{
						SH100CTRL_FsSetChannel(channelNum); // send midi comm only once
 5fc:	81 2f       	mov	r24, r17
 5fe:	9f da       	rcall	.-2754   	; 0xfffffb3e <__eeprom_end+0xff7efb3e>
 600:	75 c0       	rjmp	.+234    	; 0x6ec <FSW_MainTask+0x188>
					}		
					break;	
				}
				case FSW_RING:
				{
					uint8_t currentChannel = SH100CTRL_GetAmpState().channelNum;
 602:	d8 d7       	rcall	.+4016   	; 0x15b4 <SH100CTRL_GetAmpState>
 604:	12 2f       	mov	r17, r18
 606:	2f 83       	std	Y+7, r18	; 0x07
 608:	38 87       	std	Y+8, r19	; 0x08
 60a:	49 87       	std	Y+9, r20	; 0x09
 60c:	5a 87       	std	Y+10, r21	; 0x0a
 60e:	6b 87       	std	Y+11, r22	; 0x0b
 610:	7c 87       	std	Y+12, r23	; 0x0c
 612:	02 2f       	mov	r16, r18
					if(ctrlsPrevState.FS1_tip != activatedCtrls->FS1_tip)
 614:	20 91 0b 01 	lds	r18, 0x010B	; 0x80010b <ctrlsPrevState+0xa>
 618:	ae 2d       	mov	r26, r14
 61a:	c6 01       	movw	r24, r12
 61c:	0a 96       	adiw	r24, 0x0a	; 10
 61e:	a1 1d       	adc	r26, r1
 620:	fc 01       	movw	r30, r24
 622:	84 91       	lpm	r24, Z
 624:	a7 fd       	sbrc	r26, 7
 626:	80 81       	ld	r24, Z
 628:	28 17       	cp	r18, r24
 62a:	59 f0       	breq	.+22     	; 0x642 <FSW_MainTask+0xde>
					{
						protectionInterval_cnt = FSW_PROTECTION_INTERVAL;
 62c:	84 e6       	ldi	r24, 0x64	; 100
 62e:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
											
						if(currentChannel > SH100_CHANNEL1) SH100CTRL_FsSetChannel(currentChannel-1);
 632:	11 23       	and	r17, r17
 634:	21 f0       	breq	.+8      	; 0x63e <FSW_MainTask+0xda>
 636:	8f ef       	ldi	r24, 0xFF	; 255
 638:	81 0f       	add	r24, r17
 63a:	81 da       	rcall	.-2814   	; 0xfffffb3e <__eeprom_end+0xff7efb3e>
 63c:	02 c0       	rjmp	.+4      	; 0x642 <FSW_MainTask+0xde>
						else SH100CTRL_FsSetChannel(SH100_CHANNEL4);
 63e:	83 e0       	ldi	r24, 0x03	; 3
 640:	7e da       	rcall	.-2820   	; 0xfffffb3e <__eeprom_end+0xff7efb3e>
					}
			
					if(ctrlsPrevState.FS1_sleeve != activatedCtrls->FS1_sleeve)
 642:	20 91 0a 01 	lds	r18, 0x010A	; 0x80010a <ctrlsPrevState+0x9>
 646:	ae 2d       	mov	r26, r14
 648:	c6 01       	movw	r24, r12
 64a:	09 96       	adiw	r24, 0x09	; 9
 64c:	a1 1d       	adc	r26, r1
 64e:	fc 01       	movw	r30, r24
 650:	84 91       	lpm	r24, Z
 652:	a7 fd       	sbrc	r26, 7
 654:	80 81       	ld	r24, Z
 656:	28 17       	cp	r18, r24
 658:	09 f4       	brne	.+2      	; 0x65c <FSW_MainTask+0xf8>
 65a:	48 c0       	rjmp	.+144    	; 0x6ec <FSW_MainTask+0x188>
					{
						protectionInterval_cnt = FSW_PROTECTION_INTERVAL;
 65c:	84 e6       	ldi	r24, 0x64	; 100
 65e:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
						
						if(currentChannel < SH100_CHANNEL4) SH100CTRL_FsSetChannel(currentChannel+1);
 662:	03 30       	cpi	r16, 0x03	; 3
 664:	20 f4       	brcc	.+8      	; 0x66e <FSW_MainTask+0x10a>
 666:	81 e0       	ldi	r24, 0x01	; 1
 668:	81 0f       	add	r24, r17
 66a:	69 da       	rcall	.-2862   	; 0xfffffb3e <__eeprom_end+0xff7efb3e>
 66c:	3f c0       	rjmp	.+126    	; 0x6ec <FSW_MainTask+0x188>
						else SH100CTRL_FsSetChannel(SH100_CHANNEL1);
 66e:	80 e0       	ldi	r24, 0x00	; 0
 670:	66 da       	rcall	.-2868   	; 0xfffffb3e <__eeprom_end+0xff7efb3e>
 672:	3c c0       	rjmp	.+120    	; 0x6ec <FSW_MainTask+0x188>
					}
					break;
				}
				case FSW_ZIGZAG:
				{
					uint8_t currentChannel = SH100CTRL_GetAmpState().channelNum;
 674:	9f d7       	rcall	.+3902   	; 0x15b4 <SH100CTRL_GetAmpState>
 676:	29 83       	std	Y+1, r18	; 0x01
 678:	3a 83       	std	Y+2, r19	; 0x02
 67a:	4b 83       	std	Y+3, r20	; 0x03
 67c:	5c 83       	std	Y+4, r21	; 0x04
 67e:	6d 83       	std	Y+5, r22	; 0x05
 680:	7e 83       	std	Y+6, r23	; 0x06
 682:	12 2f       	mov	r17, r18
					if(ctrlsPrevState.FS1_tip != activatedCtrls->FS1_tip)
 684:	20 91 0b 01 	lds	r18, 0x010B	; 0x80010b <ctrlsPrevState+0xa>
 688:	ae 2d       	mov	r26, r14
 68a:	c6 01       	movw	r24, r12
 68c:	0a 96       	adiw	r24, 0x0a	; 10
 68e:	a1 1d       	adc	r26, r1
 690:	fc 01       	movw	r30, r24
 692:	84 91       	lpm	r24, Z
 694:	a7 fd       	sbrc	r26, 7
 696:	80 81       	ld	r24, Z
 698:	28 17       	cp	r18, r24
 69a:	69 f0       	breq	.+26     	; 0x6b6 <FSW_MainTask+0x152>
					{
						protectionInterval_cnt = FSW_PROTECTION_INTERVAL;
 69c:	84 e6       	ldi	r24, 0x64	; 100
 69e:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
						if(currentChannel < SH100_CHANNEL3)
 6a2:	12 30       	cpi	r17, 0x02	; 2
 6a4:	28 f4       	brcc	.+10     	; 0x6b0 <FSW_MainTask+0x14c>
						{
							zzCh12 = (currentChannel == SH100_CHANNEL1) ? SH100_CHANNEL2 : SH100_CHANNEL1;
 6a6:	81 e0       	ldi	r24, 0x01	; 1
 6a8:	11 11       	cpse	r17, r1
 6aa:	80 e0       	ldi	r24, 0x00	; 0
 6ac:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <zzCh12>
						}					
						SH100CTRL_FsSetChannel(zzCh12);
 6b0:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <zzCh12>
 6b4:	44 da       	rcall	.-2936   	; 0xfffffb3e <__eeprom_end+0xff7efb3e>
					}
				
					if(ctrlsPrevState.FS1_sleeve != activatedCtrls->FS1_sleeve)
 6b6:	20 91 0a 01 	lds	r18, 0x010A	; 0x80010a <ctrlsPrevState+0x9>
 6ba:	ae 2d       	mov	r26, r14
 6bc:	c6 01       	movw	r24, r12
 6be:	09 96       	adiw	r24, 0x09	; 9
 6c0:	a1 1d       	adc	r26, r1
 6c2:	fc 01       	movw	r30, r24
 6c4:	84 91       	lpm	r24, Z
 6c6:	a7 fd       	sbrc	r26, 7
 6c8:	80 81       	ld	r24, Z
 6ca:	28 17       	cp	r18, r24
 6cc:	79 f0       	breq	.+30     	; 0x6ec <FSW_MainTask+0x188>
					{
						protectionInterval_cnt = FSW_PROTECTION_INTERVAL;
 6ce:	84 e6       	ldi	r24, 0x64	; 100
 6d0:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
						if(currentChannel > SH100_CHANNEL2)
 6d4:	12 30       	cpi	r17, 0x02	; 2
 6d6:	38 f0       	brcs	.+14     	; 0x6e6 <FSW_MainTask+0x182>
						{
							zzCh34 = (currentChannel == SH100_CHANNEL3) ? SH100_CHANNEL4 : SH100_CHANNEL3;
 6d8:	12 30       	cpi	r17, 0x02	; 2
 6da:	11 f4       	brne	.+4      	; 0x6e0 <FSW_MainTask+0x17c>
 6dc:	83 e0       	ldi	r24, 0x03	; 3
 6de:	01 c0       	rjmp	.+2      	; 0x6e2 <FSW_MainTask+0x17e>
 6e0:	82 e0       	ldi	r24, 0x02	; 2
 6e2:	80 93 9d 01 	sts	0x019D, r24	; 0x80019d <zzCh34>
						}
						SH100CTRL_FsSetChannel(zzCh34);
 6e6:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <zzCh34>
 6ea:	29 da       	rcall	.-2990   	; 0xfffffb3e <__eeprom_end+0xff7efb3e>
					break;
				}
			}
		}

		if (activatedCtrls->FS2_presence == FSW_PRESENT)
 6ec:	ae 2d       	mov	r26, r14
 6ee:	c6 01       	movw	r24, r12
 6f0:	0e 96       	adiw	r24, 0x0e	; 14
 6f2:	a1 1d       	adc	r26, r1
 6f4:	fc 01       	movw	r30, r24
 6f6:	84 91       	lpm	r24, Z
 6f8:	a7 fd       	sbrc	r26, 7
 6fa:	80 81       	ld	r24, Z
 6fc:	81 30       	cpi	r24, 0x01	; 1
 6fe:	21 f5       	brne	.+72     	; 0x748 <FSW_MainTask+0x1e4>
		{
			if(ctrlsPrevState.FS2_sleeve != activatedCtrls->FS2_sleeve)
 700:	20 91 0d 01 	lds	r18, 0x010D	; 0x80010d <ctrlsPrevState+0xc>
 704:	ae 2d       	mov	r26, r14
 706:	c6 01       	movw	r24, r12
 708:	0c 96       	adiw	r24, 0x0c	; 12
 70a:	a1 1d       	adc	r26, r1
 70c:	fc 01       	movw	r30, r24
 70e:	84 91       	lpm	r24, Z
 710:	a7 fd       	sbrc	r26, 7
 712:	80 81       	ld	r24, Z
 714:	28 17       	cp	r18, r24
 716:	21 f0       	breq	.+8      	; 0x720 <FSW_MainTask+0x1bc>
			{
				protectionInterval_cnt = FSW_PROTECTION_INTERVAL;
 718:	84 e6       	ldi	r24, 0x64	; 100
 71a:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
				SH100CTRL_SwLoop();
 71e:	55 d8       	rcall	.-3926   	; 0xfffff7ca <__eeprom_end+0xff7ef7ca>
			}
		
			if (ctrlsPrevState.FS2_tip != activatedCtrls->FS2_tip)
 720:	20 91 0e 01 	lds	r18, 0x010E	; 0x80010e <ctrlsPrevState+0xd>
 724:	ae 2d       	mov	r26, r14
 726:	c6 01       	movw	r24, r12
 728:	0d 96       	adiw	r24, 0x0d	; 13
 72a:	a1 1d       	adc	r26, r1
 72c:	fc 01       	movw	r30, r24
 72e:	84 91       	lpm	r24, Z
 730:	a7 fd       	sbrc	r26, 7
 732:	80 81       	ld	r24, Z
 734:	28 17       	cp	r18, r24
 736:	41 f0       	breq	.+16     	; 0x748 <FSW_MainTask+0x1e4>
			{
				protectionInterval_cnt = FSW_PROTECTION_INTERVAL;
 738:	84 e6       	ldi	r24, 0x64	; 100
 73a:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
				SH100CTRL_SwAB();
 73e:	18 d9       	rcall	.-3536   	; 0xfffff970 <__eeprom_end+0xff7ef970>
 740:	03 c0       	rjmp	.+6      	; 0x748 <FSW_MainTask+0x1e4>
			}
		}			
	}
	else
	{
		protectionInterval_cnt--;
 742:	81 50       	subi	r24, 0x01	; 1
 744:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
	}	
	
	ctrlsPrevState = *activatedCtrls;	
 748:	8f e0       	ldi	r24, 0x0F	; 15
 74a:	f6 01       	movw	r30, r12
 74c:	a1 e0       	ldi	r26, 0x01	; 1
 74e:	b1 e0       	ldi	r27, 0x01	; 1
 750:	7e 2d       	mov	r23, r14
 752:	ad d9       	rcall	.-3238   	; 0xfffffaae <__eeprom_end+0xff7efaae>
}
 754:	62 96       	adiw	r28, 0x12	; 18
 756:	0f b6       	in	r0, 0x3f	; 63
 758:	f8 94       	cli
 75a:	de bf       	out	0x3e, r29	; 62
 75c:	0f be       	out	0x3f, r0	; 63
 75e:	cd bf       	out	0x3d, r28	; 61
 760:	df 91       	pop	r29
 762:	cf 91       	pop	r28
 764:	1f 91       	pop	r17
 766:	0f 91       	pop	r16
 768:	ef 90       	pop	r14
 76a:	df 90       	pop	r13
 76c:	cf 90       	pop	r12
 76e:	08 95       	ret

Disassembly of section .text.FSW_BlockFrontControls:

00001a3e <FSW_BlockFrontControls>:

bool FSW_BlockFrontControls()
{
	return ((switchMode == FSW_RELAY) && (ctrlsPrevState.FS1_presence == FSW_PRESENT));
    1a3e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
    1a42:	82 30       	cpi	r24, 0x02	; 2
    1a44:	31 f4       	brne	.+12     	; 0x1a52 <FSW_BlockFrontControls+0x14>
    1a46:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <ctrlsPrevState+0xb>
    1a4a:	81 30       	cpi	r24, 0x01	; 1
    1a4c:	21 f0       	breq	.+8      	; 0x1a56 <FSW_BlockFrontControls+0x18>
    1a4e:	80 e0       	ldi	r24, 0x00	; 0
    1a50:	08 95       	ret
    1a52:	80 e0       	ldi	r24, 0x00	; 0
    1a54:	08 95       	ret
    1a56:	81 e0       	ldi	r24, 0x01	; 1
    1a58:	08 95       	ret

Disassembly of section .text.FBTNS_MainTask:

000000d0 <FBTNS_MainTask>:

bool loopSwitched = false;
bool abSwitched = false;

void FBTNS_MainTask(const SH100HW_Controls_t* pressedButtons)
{
  d0:	cf 92       	push	r12
  d2:	df 92       	push	r13
  d4:	ef 92       	push	r14
  d6:	9b 01       	movw	r18, r22
  d8:	48 2f       	mov	r20, r24
	if(protectionInterval_cnt == 0)
  da:	80 91 a6 01 	lds	r24, 0x01A6	; 0x8001a6 <protectionInterval_cnt>
  de:	81 11       	cpse	r24, r1
  e0:	17 c1       	rjmp	.+558    	; 0x310 <__EEPROM_REGION_LENGTH__+0x110>
  e2:	69 01       	movw	r12, r18
  e4:	e4 2e       	mov	r14, r20
	{
		if(FSW_BlockFrontControls()) return;
  e6:	ab dc       	rcall	.-1706   	; 0xfffffa3e <__eeprom_end+0xff7efa3e>
  e8:	81 11       	cpse	r24, r1
  ea:	15 c1       	rjmp	.+554    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		
		//=============BTN CH1==========================
		if(pressedButtons->btnCh1 == BT_ON)
  ec:	ae 2d       	mov	r26, r14
  ee:	c6 01       	movw	r24, r12
  f0:	03 96       	adiw	r24, 0x03	; 3
  f2:	a1 1d       	adc	r26, r1
  f4:	fc 01       	movw	r30, r24
  f6:	84 91       	lpm	r24, Z
  f8:	a7 fd       	sbrc	r26, 7
  fa:	80 81       	ld	r24, Z
  fc:	81 11       	cpse	r24, r1
  fe:	24 c0       	rjmp	.+72     	; 0x148 <FBTNS_MainTask+0x78>
		{
			protectionInterval_cnt = BTN_PROTECTION_INTERVAL;
 100:	84 e1       	ldi	r24, 0x14	; 20
 102:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
			if(swProgrammingMode_cnt == SWITCH_MODE_DELAY)
 106:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <swProgrammingMode_cnt>
 10a:	8a 30       	cpi	r24, 0x0A	; 10
 10c:	51 f4       	brne	.+20     	; 0x122 <FBTNS_MainTask+0x52>
			{
				//enter prog mode, or save settings
				if(MIDICTRL_MidiMode() == RUNNING)
 10e:	86 dd       	rcall	.-1268   	; 0xfffffc1c <__eeprom_end+0xff7efc1c>
 110:	81 11       	cpse	r24, r1
 112:	03 c0       	rjmp	.+6      	; 0x11a <FBTNS_MainTask+0x4a>
				{
					MIDICTRL_EnterProgrammingMode();
 114:	ee da       	rcall	.-2596   	; 0xfffff6f2 <__eeprom_end+0xff7ef6f2>
					SH100CTRL_MuteAmp();
 116:	91 dd       	rcall	.-1246   	; 0xfffffc3a <__eeprom_end+0xff7efc3a>
 118:	11 c0       	rjmp	.+34     	; 0x13c <FBTNS_MainTask+0x6c>
				}
				else
				{
					MIDICTRL_StoreUserCommands();
 11a:	ae da       	rcall	.-2724   	; 0xfffff678 <__eeprom_end+0xff7ef678>
					SH100CTRL_SetAmpLeds();
 11c:	d3 db       	rcall	.-2138   	; 0xfffff8c4 <__eeprom_end+0xff7ef8c4>
					SH100CTRL_UnmuteAmp();
 11e:	60 dd       	rcall	.-1344   	; 0xfffffbe0 <__eeprom_end+0xff7efbe0>
 120:	0d c0       	rjmp	.+26     	; 0x13c <FBTNS_MainTask+0x6c>
				}
			}
			else
			{
				if(swProgrammingMode_cnt == 0)
 122:	81 11       	cpse	r24, r1
 124:	0b c0       	rjmp	.+22     	; 0x13c <FBTNS_MainTask+0x6c>
				{
					switch(MIDICTRL_MidiMode())
 126:	7a dd       	rcall	.-1292   	; 0xfffffc1c <__eeprom_end+0xff7efc1c>
 128:	88 23       	and	r24, r24
 12a:	19 f0       	breq	.+6      	; 0x132 <FBTNS_MainTask+0x62>
 12c:	81 30       	cpi	r24, 0x01	; 1
 12e:	21 f0       	breq	.+8      	; 0x138 <FBTNS_MainTask+0x68>
 130:	05 c0       	rjmp	.+10     	; 0x13c <FBTNS_MainTask+0x6c>
					{
						case RUNNING: SH100CTRL_BtnSetChannel(SH100_CHANNEL1); break;
 132:	80 e0       	ldi	r24, 0x00	; 0
 134:	a0 dc       	rcall	.-1728   	; 0xfffffa76 <__eeprom_end+0xff7efa76>
 136:	02 c0       	rjmp	.+4      	; 0x13c <FBTNS_MainTask+0x6c>
						case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH1); break;
 138:	80 e0       	ldi	r24, 0x00	; 0
 13a:	ad db       	rcall	.-2214   	; 0xfffff896 <__eeprom_end+0xff7ef896>
					}
				}
				
			}
			swProgrammingMode_cnt++;
 13c:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <swProgrammingMode_cnt>
 140:	8f 5f       	subi	r24, 0xFF	; 255
 142:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <swProgrammingMode_cnt>
			return;
 146:	e7 c0       	rjmp	.+462    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		}
		else swProgrammingMode_cnt=0;
 148:	10 92 a5 01 	sts	0x01A5, r1	; 0x8001a5 <swProgrammingMode_cnt>
		
		//=============BTN CH2==========================
		if(pressedButtons->btnCh2 == BT_ON)
 14c:	ae 2d       	mov	r26, r14
 14e:	c6 01       	movw	r24, r12
 150:	04 96       	adiw	r24, 0x04	; 4
 152:	a1 1d       	adc	r26, r1
 154:	fc 01       	movw	r30, r24
 156:	84 91       	lpm	r24, Z
 158:	a7 fd       	sbrc	r26, 7
 15a:	80 81       	ld	r24, Z
 15c:	81 11       	cpse	r24, r1
 15e:	23 c0       	rjmp	.+70     	; 0x1a6 <FBTNS_MainTask+0xd6>
		{
			protectionInterval_cnt = BTN_PROTECTION_INTERVAL;
 160:	84 e1       	ldi	r24, 0x14	; 20
 162:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
			if(setFSWRelayMode_cnt == SWITCH_MODE_DELAY)
 166:	80 91 a1 01 	lds	r24, 0x01A1	; 0x8001a1 <setFSWRelayMode_cnt>
 16a:	8a 30       	cpi	r24, 0x0A	; 10
 16c:	49 f4       	brne	.+18     	; 0x180 <FBTNS_MainTask+0xb0>
			{
				if(MIDICTRL_MidiMode() == RUNNING)
 16e:	56 dd       	rcall	.-1364   	; 0xfffffc1c <__eeprom_end+0xff7efc1c>
 170:	81 11       	cpse	r24, r1
 172:	13 c0       	rjmp	.+38     	; 0x19a <FBTNS_MainTask+0xca>
				{
					FSW_SetMode(FSW_RELAY);
 174:	82 e0       	ldi	r24, 0x02	; 2
 176:	0b dd       	rcall	.-1514   	; 0xfffffb8e <__eeprom_end+0xff7efb8e>
					SH100HW_SetLedBlinkCount(LED_CH2, 2);
 178:	62 e0       	ldi	r22, 0x02	; 2
 17a:	81 e0       	ldi	r24, 0x01	; 1
 17c:	5d da       	rcall	.-2886   	; 0xfffff638 <__eeprom_end+0xff7ef638>
 17e:	0d c0       	rjmp	.+26     	; 0x19a <FBTNS_MainTask+0xca>
				}				
			}
			else
			{
				if(setFSWRelayMode_cnt == 0)
 180:	81 11       	cpse	r24, r1
 182:	0b c0       	rjmp	.+22     	; 0x19a <FBTNS_MainTask+0xca>
				{
					switch(MIDICTRL_MidiMode())
 184:	4b dd       	rcall	.-1386   	; 0xfffffc1c <__eeprom_end+0xff7efc1c>
 186:	88 23       	and	r24, r24
 188:	19 f0       	breq	.+6      	; 0x190 <FBTNS_MainTask+0xc0>
 18a:	81 30       	cpi	r24, 0x01	; 1
 18c:	21 f0       	breq	.+8      	; 0x196 <FBTNS_MainTask+0xc6>
 18e:	05 c0       	rjmp	.+10     	; 0x19a <FBTNS_MainTask+0xca>
					{
						case RUNNING: SH100CTRL_BtnSetChannel(SH100_CHANNEL2); break;
 190:	81 e0       	ldi	r24, 0x01	; 1
 192:	71 dc       	rcall	.-1822   	; 0xfffffa76 <__eeprom_end+0xff7efa76>
 194:	02 c0       	rjmp	.+4      	; 0x19a <FBTNS_MainTask+0xca>
						case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH2); break;
 196:	81 e0       	ldi	r24, 0x01	; 1
 198:	7e db       	rcall	.-2308   	; 0xfffff896 <__eeprom_end+0xff7ef896>
					}
				}
			}
			setFSWRelayMode_cnt++;
 19a:	80 91 a1 01 	lds	r24, 0x01A1	; 0x8001a1 <setFSWRelayMode_cnt>
 19e:	8f 5f       	subi	r24, 0xFF	; 255
 1a0:	80 93 a1 01 	sts	0x01A1, r24	; 0x8001a1 <setFSWRelayMode_cnt>
			return;
 1a4:	b8 c0       	rjmp	.+368    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		}
		else setFSWRelayMode_cnt = 0;
 1a6:	10 92 a1 01 	sts	0x01A1, r1	; 0x8001a1 <setFSWRelayMode_cnt>
		
		//=============BTN CH3==========================
		if(pressedButtons->btnCh3 == BT_ON)
 1aa:	ae 2d       	mov	r26, r14
 1ac:	c6 01       	movw	r24, r12
 1ae:	05 96       	adiw	r24, 0x05	; 5
 1b0:	a1 1d       	adc	r26, r1
 1b2:	fc 01       	movw	r30, r24
 1b4:	84 91       	lpm	r24, Z
 1b6:	a7 fd       	sbrc	r26, 7
 1b8:	80 81       	ld	r24, Z
 1ba:	81 11       	cpse	r24, r1
 1bc:	22 c0       	rjmp	.+68     	; 0x202 <__EEPROM_REGION_LENGTH__+0x2>
		{
			protectionInterval_cnt = BTN_PROTECTION_INTERVAL;
 1be:	84 e1       	ldi	r24, 0x14	; 20
 1c0:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
			if(setFSWRingMode_cnt == SWITCH_MODE_DELAY)
 1c4:	80 91 a3 01 	lds	r24, 0x01A3	; 0x8001a3 <setFSWRingMode_cnt>
 1c8:	8a 30       	cpi	r24, 0x0A	; 10
 1ca:	41 f4       	brne	.+16     	; 0x1dc <FBTNS_MainTask+0x10c>
			{
				if(MIDICTRL_MidiMode() == RUNNING)
 1cc:	27 dd       	rcall	.-1458   	; 0xfffffc1c <__eeprom_end+0xff7efc1c>
 1ce:	81 11       	cpse	r24, r1
 1d0:	12 c0       	rjmp	.+36     	; 0x1f6 <FBTNS_MainTask+0x126>
				{
					FSW_SetMode(FSW_RING);
 1d2:	dd dc       	rcall	.-1606   	; 0xfffffb8e <__eeprom_end+0xff7efb8e>
					SH100HW_SetLedBlinkCount(LED_CH3, 2);
 1d4:	62 e0       	ldi	r22, 0x02	; 2
 1d6:	82 e0       	ldi	r24, 0x02	; 2
 1d8:	2f da       	rcall	.-2978   	; 0xfffff638 <__eeprom_end+0xff7ef638>
 1da:	0d c0       	rjmp	.+26     	; 0x1f6 <FBTNS_MainTask+0x126>
				}
			}
			else
			{
				if(setFSWRingMode_cnt == 0)
 1dc:	81 11       	cpse	r24, r1
 1de:	0b c0       	rjmp	.+22     	; 0x1f6 <FBTNS_MainTask+0x126>
				{
					switch(MIDICTRL_MidiMode())
 1e0:	1d dd       	rcall	.-1478   	; 0xfffffc1c <__eeprom_end+0xff7efc1c>
 1e2:	88 23       	and	r24, r24
 1e4:	19 f0       	breq	.+6      	; 0x1ec <FBTNS_MainTask+0x11c>
 1e6:	81 30       	cpi	r24, 0x01	; 1
 1e8:	21 f0       	breq	.+8      	; 0x1f2 <FBTNS_MainTask+0x122>
 1ea:	05 c0       	rjmp	.+10     	; 0x1f6 <FBTNS_MainTask+0x126>
					{
						case RUNNING: SH100CTRL_BtnSetChannel(SH100_CHANNEL3); break;
 1ec:	82 e0       	ldi	r24, 0x02	; 2
 1ee:	43 dc       	rcall	.-1914   	; 0xfffffa76 <__eeprom_end+0xff7efa76>
 1f0:	02 c0       	rjmp	.+4      	; 0x1f6 <FBTNS_MainTask+0x126>
						case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH3); break;
 1f2:	82 e0       	ldi	r24, 0x02	; 2
 1f4:	50 db       	rcall	.-2400   	; 0xfffff896 <__eeprom_end+0xff7ef896>
					}
				}				
			}
			setFSWRingMode_cnt++;
 1f6:	80 91 a3 01 	lds	r24, 0x01A3	; 0x8001a3 <setFSWRingMode_cnt>
 1fa:	8f 5f       	subi	r24, 0xFF	; 255
 1fc:	80 93 a3 01 	sts	0x01A3, r24	; 0x8001a3 <setFSWRingMode_cnt>
			return;			
 200:	8a c0       	rjmp	.+276    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		}
		else setFSWRingMode_cnt = 0;
 202:	10 92 a3 01 	sts	0x01A3, r1	; 0x8001a3 <setFSWRingMode_cnt>
		
		//=============BTN CH4==========================
		if(pressedButtons->btnCh4 == BT_ON)
 206:	ae 2d       	mov	r26, r14
 208:	c6 01       	movw	r24, r12
 20a:	06 96       	adiw	r24, 0x06	; 6
 20c:	a1 1d       	adc	r26, r1
 20e:	fc 01       	movw	r30, r24
 210:	84 91       	lpm	r24, Z
 212:	a7 fd       	sbrc	r26, 7
 214:	80 81       	ld	r24, Z
 216:	81 11       	cpse	r24, r1
 218:	23 c0       	rjmp	.+70     	; 0x260 <__EEPROM_REGION_LENGTH__+0x60>
		{
			protectionInterval_cnt = BTN_PROTECTION_INTERVAL;
 21a:	84 e1       	ldi	r24, 0x14	; 20
 21c:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
			if(setFSWZigzagMode_cnt == SWITCH_MODE_DELAY)
 220:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <setFSWZigzagMode_cnt>
 224:	8a 30       	cpi	r24, 0x0A	; 10
 226:	49 f4       	brne	.+18     	; 0x23a <__EEPROM_REGION_LENGTH__+0x3a>
			{
				if(MIDICTRL_MidiMode() == RUNNING)
 228:	f9 dc       	rcall	.-1550   	; 0xfffffc1c <__eeprom_end+0xff7efc1c>
 22a:	81 11       	cpse	r24, r1
 22c:	13 c0       	rjmp	.+38     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
				{
					FSW_SetMode(FSW_ZIGZAG);
 22e:	81 e0       	ldi	r24, 0x01	; 1
 230:	ae dc       	rcall	.-1700   	; 0xfffffb8e <__eeprom_end+0xff7efb8e>
					SH100HW_SetLedBlinkCount(LED_CH4, 2);
 232:	62 e0       	ldi	r22, 0x02	; 2
 234:	83 e0       	ldi	r24, 0x03	; 3
 236:	00 da       	rcall	.-3072   	; 0xfffff638 <__eeprom_end+0xff7ef638>
 238:	0d c0       	rjmp	.+26     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
				}
			}
			else
			{
				if(setFSWZigzagMode_cnt == 0)
 23a:	81 11       	cpse	r24, r1
 23c:	0b c0       	rjmp	.+22     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
				{
					switch(MIDICTRL_MidiMode())
 23e:	ee dc       	rcall	.-1572   	; 0xfffffc1c <__eeprom_end+0xff7efc1c>
 240:	88 23       	and	r24, r24
 242:	19 f0       	breq	.+6      	; 0x24a <__EEPROM_REGION_LENGTH__+0x4a>
 244:	81 30       	cpi	r24, 0x01	; 1
 246:	21 f0       	breq	.+8      	; 0x250 <__EEPROM_REGION_LENGTH__+0x50>
 248:	05 c0       	rjmp	.+10     	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
					{
						case RUNNING: SH100CTRL_BtnSetChannel(SH100_CHANNEL4); break;
 24a:	83 e0       	ldi	r24, 0x03	; 3
 24c:	14 dc       	rcall	.-2008   	; 0xfffffa76 <__eeprom_end+0xff7efa76>
 24e:	02 c0       	rjmp	.+4      	; 0x254 <__EEPROM_REGION_LENGTH__+0x54>
						case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH4); break;
 250:	83 e0       	ldi	r24, 0x03	; 3
 252:	21 db       	rcall	.-2494   	; 0xfffff896 <__eeprom_end+0xff7ef896>
					}
				}	
			}
			setFSWZigzagMode_cnt++;	
 254:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <setFSWZigzagMode_cnt>
 258:	8f 5f       	subi	r24, 0xFF	; 255
 25a:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <setFSWZigzagMode_cnt>
			return;
 25e:	5b c0       	rjmp	.+182    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		}
		else setFSWZigzagMode_cnt = 0;
 260:	10 92 a2 01 	sts	0x01A2, r1	; 0x8001a2 <setFSWZigzagMode_cnt>
		
		//=============BTN LOOP=========================
		if(pressedButtons->btnLoop == BT_ON)
 264:	ae 2d       	mov	r26, r14
 266:	c6 01       	movw	r24, r12
 268:	08 96       	adiw	r24, 0x08	; 8
 26a:	a1 1d       	adc	r26, r1
 26c:	fc 01       	movw	r30, r24
 26e:	84 91       	lpm	r24, Z
 270:	a7 fd       	sbrc	r26, 7
 272:	80 81       	ld	r24, Z
 274:	81 11       	cpse	r24, r1
 276:	15 c0       	rjmp	.+42     	; 0x2a2 <__EEPROM_REGION_LENGTH__+0xa2>
		{
			protectionInterval_cnt = BTN_PROTECTION_INTERVAL;
 278:	84 e1       	ldi	r24, 0x14	; 20
 27a:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>

			switch(MIDICTRL_MidiMode())
 27e:	ce dc       	rcall	.-1636   	; 0xfffffc1c <__eeprom_end+0xff7efc1c>
 280:	88 23       	and	r24, r24
 282:	19 f0       	breq	.+6      	; 0x28a <__EEPROM_REGION_LENGTH__+0x8a>
 284:	81 30       	cpi	r24, 0x01	; 1
 286:	51 f0       	breq	.+20     	; 0x29c <__EEPROM_REGION_LENGTH__+0x9c>
 288:	46 c0       	rjmp	.+140    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
			{
				case RUNNING:
				{
					if(!loopSwitched) SH100CTRL_SwLoop();
 28a:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <loopSwitched>
 28e:	81 11       	cpse	r24, r1
 290:	01 c0       	rjmp	.+2      	; 0x294 <__EEPROM_REGION_LENGTH__+0x94>
 292:	9b da       	rcall	.-2762   	; 0xfffff7ca <__eeprom_end+0xff7ef7ca>
					loopSwitched = true;
 294:	81 e0       	ldi	r24, 0x01	; 1
 296:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <loopSwitched>
					break;
 29a:	3d c0       	rjmp	.+122    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
				}
				case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_LOOP); break;
 29c:	84 e0       	ldi	r24, 0x04	; 4
 29e:	fb da       	rcall	.-2570   	; 0xfffff896 <__eeprom_end+0xff7ef896>
 2a0:	3a c0       	rjmp	.+116    	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
			}
			return;
		}
		else loopSwitched = false;
 2a2:	10 92 a0 01 	sts	0x01A0, r1	; 0x8001a0 <loopSwitched>
		
		//=============BTN AB===========================
		if(pressedButtons->btnAB == BT_ON)
 2a6:	4e 2d       	mov	r20, r14
 2a8:	96 01       	movw	r18, r12
 2aa:	29 5f       	subi	r18, 0xF9	; 249
 2ac:	3f 4f       	sbci	r19, 0xFF	; 255
 2ae:	4f 4f       	sbci	r20, 0xFF	; 255
 2b0:	f9 01       	movw	r30, r18
 2b2:	84 91       	lpm	r24, Z
 2b4:	47 fd       	sbrc	r20, 7
 2b6:	80 81       	ld	r24, Z
 2b8:	81 11       	cpse	r24, r1
 2ba:	25 c0       	rjmp	.+74     	; 0x306 <__EEPROM_REGION_LENGTH__+0x106>
		{
			protectionInterval_cnt = BTN_PROTECTION_INTERVAL;
 2bc:	84 e1       	ldi	r24, 0x14	; 20
 2be:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
			if(leaveDefSettings_cnt == SWITCH_MODE_DELAY)
 2c2:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <leaveDefSettings_cnt>
 2c6:	8a 30       	cpi	r24, 0x0A	; 10
 2c8:	39 f4       	brne	.+14     	; 0x2d8 <__EEPROM_REGION_LENGTH__+0xd8>
			{
				if(MIDICTRL_MidiMode() == PROGRAMMING)
 2ca:	a8 dc       	rcall	.-1712   	; 0xfffffc1c <__eeprom_end+0xff7efc1c>
 2cc:	81 30       	cpi	r24, 0x01	; 1
 2ce:	a9 f4       	brne	.+42     	; 0x2fa <__EEPROM_REGION_LENGTH__+0xfa>
				{
					MIDICTRL_DiscardCommands();
 2d0:	73 db       	rcall	.-2330   	; 0xfffff9b8 <__eeprom_end+0xff7ef9b8>
					SH100CTRL_SetAmpLeds();
 2d2:	f8 da       	rcall	.-2576   	; 0xfffff8c4 <__eeprom_end+0xff7ef8c4>
					SH100CTRL_UnmuteAmp();
 2d4:	85 dc       	rcall	.-1782   	; 0xfffffbe0 <__eeprom_end+0xff7efbe0>
 2d6:	11 c0       	rjmp	.+34     	; 0x2fa <__EEPROM_REGION_LENGTH__+0xfa>
				}
			}
			else
			{				
				switch(MIDICTRL_MidiMode())
 2d8:	a1 dc       	rcall	.-1726   	; 0xfffffc1c <__eeprom_end+0xff7efc1c>
 2da:	88 23       	and	r24, r24
 2dc:	19 f0       	breq	.+6      	; 0x2e4 <__EEPROM_REGION_LENGTH__+0xe4>
 2de:	81 30       	cpi	r24, 0x01	; 1
 2e0:	51 f0       	breq	.+20     	; 0x2f6 <__EEPROM_REGION_LENGTH__+0xf6>
 2e2:	0b c0       	rjmp	.+22     	; 0x2fa <__EEPROM_REGION_LENGTH__+0xfa>
				{
					case RUNNING:
					{
						if(!abSwitched) SH100CTRL_SwAB();
 2e4:	80 91 9f 01 	lds	r24, 0x019F	; 0x80019f <abSwitched>
 2e8:	81 11       	cpse	r24, r1
 2ea:	01 c0       	rjmp	.+2      	; 0x2ee <__EEPROM_REGION_LENGTH__+0xee>
 2ec:	41 db       	rcall	.-2430   	; 0xfffff970 <__eeprom_end+0xff7ef970>
						abSwitched = true;
 2ee:	81 e0       	ldi	r24, 0x01	; 1
 2f0:	80 93 9f 01 	sts	0x019F, r24	; 0x80019f <abSwitched>
						break;
 2f4:	02 c0       	rjmp	.+4      	; 0x2fa <__EEPROM_REGION_LENGTH__+0xfa>
					}
					case PROGRAMMING: MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_AB); break;
 2f6:	85 e0       	ldi	r24, 0x05	; 5
 2f8:	ce da       	rcall	.-2660   	; 0xfffff896 <__eeprom_end+0xff7ef896>
				}
			}
			leaveDefSettings_cnt++;
 2fa:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <leaveDefSettings_cnt>
 2fe:	8f 5f       	subi	r24, 0xFF	; 255
 300:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <leaveDefSettings_cnt>
			return;
 304:	08 c0       	rjmp	.+16     	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		}
		else 
		{
			leaveDefSettings_cnt=0;
 306:	10 92 a4 01 	sts	0x01A4, r1	; 0x8001a4 <leaveDefSettings_cnt>
			abSwitched = false;
 30a:	10 92 9f 01 	sts	0x019F, r1	; 0x80019f <abSwitched>
 30e:	03 c0       	rjmp	.+6      	; 0x316 <__EEPROM_REGION_LENGTH__+0x116>
		}
	}
	else
	{
		protectionInterval_cnt--;
 310:	81 50       	subi	r24, 0x01	; 1
 312:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <protectionInterval_cnt>
	}
 316:	ef 90       	pop	r14
 318:	df 90       	pop	r13
 31a:	cf 90       	pop	r12
 31c:	08 95       	ret

Disassembly of section .text.__portable_avr_delay_cycles:

00001b28 <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
    1b28:	04 c0       	rjmp	.+8      	; 0x1b32 <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
    1b2a:	61 50       	subi	r22, 0x01	; 1
    1b2c:	71 09       	sbc	r23, r1
    1b2e:	81 09       	sbc	r24, r1
    1b30:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
    1b32:	61 15       	cp	r22, r1
    1b34:	71 05       	cpc	r23, r1
    1b36:	81 05       	cpc	r24, r1
    1b38:	91 05       	cpc	r25, r1
    1b3a:	b9 f7       	brne	.-18     	; 0x1b2a <__portable_avr_delay_cycles+0x2>
    1b3c:	08 95       	ret

Disassembly of section .text.initTest:

00000c64 <initTest>:
bool isAmpStarted = false;
int16_t negVdd;
int16_t posVdd;
void initTest()
{
	SH100HW_SetNewLedState(LED_PWR_GRN, LED_FAST_BLINKING);
 c64:	62 e0       	ldi	r22, 0x02	; 2
 c66:	87 e0       	ldi	r24, 0x07	; 7
 c68:	44 d6       	rcall	.+3208   	; 0x18f2 <SH100HW_SetNewLedState>
	delay_ms(20000);
 c6a:	66 ed       	ldi	r22, 0xD6	; 214
 c6c:	7c ed       	ldi	r23, 0xDC	; 220
 c6e:	82 e3       	ldi	r24, 0x32	; 50
 c70:	90 e0       	ldi	r25, 0x00	; 0
 c72:	5a d7       	rcall	.+3764   	; 0x1b28 <__portable_avr_delay_cycles>
	
	SH100HW_StartADConvertion(ADC_V_SIGNAL);
 c74:	86 e0       	ldi	r24, 0x06	; 6
 c76:	78 d7       	rcall	.+3824   	; 0x1b68 <SH100HW_StartADConvertion>
	while(ADCSRA & (1<<ADSC)){}
 c78:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7fe07a>
 c7c:	86 fd       	sbrc	r24, 6
 c7e:	fc cf       	rjmp	.-8      	; 0xc78 <initTest+0x14>
		
	int32_t outLineValue = ADC;
 c80:	60 91 78 00 	lds	r22, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7fe078>
 c84:	70 91 79 00 	lds	r23, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7fe079>
 c88:	cb 01       	movw	r24, r22
 c8a:	a0 e0       	ldi	r26, 0x00	; 0
 c8c:	b0 e0       	ldi	r27, 0x00	; 0
	
	if(fabs(outLineValue - 0x3FF/2) > 100)
 c8e:	bc 01       	movw	r22, r24
 c90:	cd 01       	movw	r24, r26
 c92:	6f 5f       	subi	r22, 0xFF	; 255
 c94:	71 40       	sbci	r23, 0x01	; 1
 c96:	81 09       	sbc	r24, r1
 c98:	91 09       	sbc	r25, r1
 c9a:	49 d1       	rcall	.+658    	; 0xf2e <__floatsisf>
 c9c:	9f 77       	andi	r25, 0x7F	; 127
 c9e:	20 e0       	ldi	r18, 0x00	; 0
 ca0:	30 e0       	ldi	r19, 0x00	; 0
 ca2:	48 ec       	ldi	r20, 0xC8	; 200
 ca4:	52 e4       	ldi	r21, 0x42	; 66
 ca6:	b6 d7       	rcall	.+3948   	; 0x1c14 <__gesf2>
 ca8:	18 16       	cp	r1, r24
 caa:	4c f4       	brge	.+18     	; 0xcbe <initTest+0x5a>
	{
		// DC on output!
		SH100HW_SetPAFailure(true);
 cac:	81 e0       	ldi	r24, 0x01	; 1
 cae:	7d d7       	rcall	.+3834   	; 0x1baa <SH100HW_SetPAFailure>
		SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
 cb0:	60 e0       	ldi	r22, 0x00	; 0
 cb2:	87 e0       	ldi	r24, 0x07	; 7
 cb4:	1e d6       	rcall	.+3132   	; 0x18f2 <SH100HW_SetNewLedState>
		SH100HW_SetNewLedState(LED_PWR_RED, LED_FAST_BLINKING);
 cb6:	62 e0       	ldi	r22, 0x02	; 2
 cb8:	88 e0       	ldi	r24, 0x08	; 8
 cba:	1b d6       	rcall	.+3126   	; 0x18f2 <SH100HW_SetNewLedState>
 cbc:	ff cf       	rjmp	.-2      	; 0xcbc <initTest+0x58>
		while(1) {}
	}
	
	SH100HW_StartADConvertion(ADC_V_NEGATIVE);
 cbe:	87 e0       	ldi	r24, 0x07	; 7
 cc0:	53 d7       	rcall	.+3750   	; 0x1b68 <SH100HW_StartADConvertion>
	while(ADCSRA & (1<<ADSC)){}
 cc2:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7fe07a>
 cc6:	86 fd       	sbrc	r24, 6
 cc8:	fc cf       	rjmp	.-8      	; 0xcc2 <initTest+0x5e>
		
	negVdd = ADC;
 cca:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7fe078>
 cce:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7fe079>
 cd2:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <negVdd+0x1>
 cd6:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <negVdd>
	
	SH100HW_StartADConvertion(ADC_V_POSITIVE);
 cda:	80 e0       	ldi	r24, 0x00	; 0
 cdc:	45 d7       	rcall	.+3722   	; 0x1b68 <SH100HW_StartADConvertion>
	while(ADCSRA & (1<<ADSC)){}
 cde:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7fe07a>
 ce2:	86 fd       	sbrc	r24, 6
 ce4:	fc cf       	rjmp	.-8      	; 0xcde <initTest+0x7a>
		
	posVdd = ADC;
 ce6:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7fe078>
 cea:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7fe079>
 cee:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <posVdd+0x1>
 cf2:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <posVdd>
	
	if(fabs(negVdd-posVdd) > 100)
 cf6:	60 91 10 01 	lds	r22, 0x0110	; 0x800110 <negVdd>
 cfa:	70 91 11 01 	lds	r23, 0x0111	; 0x800111 <negVdd+0x1>
 cfe:	68 1b       	sub	r22, r24
 d00:	79 0b       	sbc	r23, r25
 d02:	07 2e       	mov	r0, r23
 d04:	00 0c       	add	r0, r0
 d06:	88 0b       	sbc	r24, r24
 d08:	99 0b       	sbc	r25, r25
 d0a:	11 d1       	rcall	.+546    	; 0xf2e <__floatsisf>
 d0c:	9f 77       	andi	r25, 0x7F	; 127
 d0e:	20 e0       	ldi	r18, 0x00	; 0
 d10:	30 e0       	ldi	r19, 0x00	; 0
 d12:	48 ec       	ldi	r20, 0xC8	; 200
 d14:	52 e4       	ldi	r21, 0x42	; 66
 d16:	7e d7       	rcall	.+3836   	; 0x1c14 <__gesf2>
 d18:	18 16       	cp	r1, r24
 d1a:	4c f4       	brge	.+18     	; 0xd2e <initTest+0xca>
	{
		// one of Vdd rail is out
		SH100HW_SetPAFailure(true);
 d1c:	81 e0       	ldi	r24, 0x01	; 1
 d1e:	45 d7       	rcall	.+3722   	; 0x1baa <SH100HW_SetPAFailure>
		SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
 d20:	60 e0       	ldi	r22, 0x00	; 0
 d22:	87 e0       	ldi	r24, 0x07	; 7
 d24:	e6 d5       	rcall	.+3020   	; 0x18f2 <SH100HW_SetNewLedState>
		SH100HW_SetNewLedState(LED_PWR_RED, LED_FAST_BLINKING);
 d26:	62 e0       	ldi	r22, 0x02	; 2
 d28:	88 e0       	ldi	r24, 0x08	; 8
 d2a:	e3 d5       	rcall	.+3014   	; 0x18f2 <SH100HW_SetNewLedState>
 d2c:	ff cf       	rjmp	.-2      	; 0xd2c <initTest+0xc8>
		while(1) {}
	}
		
	SH100HW_SetPAFailure(false);
 d2e:	80 e0       	ldi	r24, 0x00	; 0
 d30:	3c d7       	rcall	.+3704   	; 0x1baa <SH100HW_SetPAFailure>
	SH100CTRL_CheckOutputJacks();
 d32:	b0 d1       	rcall	.+864    	; 0x1094 <SH100CTRL_CheckOutputJacks>
	isAmpStarted = true;
 d34:	81 e0       	ldi	r24, 0x01	; 1
 d36:	80 93 a8 01 	sts	0x01A8, r24	; 0x8001a8 <isAmpStarted>
 d3a:	08 95       	ret

Disassembly of section .text.ISRInit:

0000191e <ISRInit>:

#define MAIN_TIMER_PERIOD 97
void ISRInit()
{
	// Timer0 init. For main task
	TCCR0B |= 0x05; // psc = 1024
    191e:	85 b5       	in	r24, 0x25	; 37
    1920:	85 60       	ori	r24, 0x05	; 5
    1922:	85 bd       	out	0x25, r24	; 37
	TIMSK0 |= 0x01; // OVF INT enable, count pulse = 100us
    1924:	ee e6       	ldi	r30, 0x6E	; 110
    1926:	f0 e0       	ldi	r31, 0x00	; 0
    1928:	80 81       	ld	r24, Z
    192a:	81 60       	ori	r24, 0x01	; 1
    192c:	80 83       	st	Z, r24
	TCNT0 = 0xFF - MAIN_TIMER_PERIOD;
    192e:	8e e9       	ldi	r24, 0x9E	; 158
    1930:	86 bd       	out	0x26, r24	; 38
		
	// PCINT10, interrupt for PC2 pin(SW detect)
	PCICR |= 0x02;
    1932:	e8 e6       	ldi	r30, 0x68	; 104
    1934:	f0 e0       	ldi	r31, 0x00	; 0
    1936:	80 81       	ld	r24, Z
    1938:	82 60       	ori	r24, 0x02	; 2
    193a:	80 83       	st	Z, r24
	PCMSK1 |= 0x04;
    193c:	ec e6       	ldi	r30, 0x6C	; 108
    193e:	f0 e0       	ldi	r31, 0x00	; 0
    1940:	80 81       	ld	r24, Z
    1942:	84 60       	ori	r24, 0x04	; 4
    1944:	80 83       	st	Z, r24
    1946:	08 95       	ret

Disassembly of section .text.main:

00001b54 <main>:
}

int main(void)
{
	UART_init();
    1b54:	dd df       	rcall	.-70     	; 0x1b10 <UART_init>
	SH100HW_Init();
    1b56:	79 db       	rcall	.-2318   	; 0x124a <SH100HW_Init>
	SH100CTRL_Init();
    1b58:	61 da       	rcall	.-2878   	; 0x101c <SH100CTRL_Init>
	MIDICTRL_Init();
    1b5a:	20 d0       	rcall	.+64     	; 0x1b9c <MIDICTRL_Init>
	FSW_Init();
    1b5c:	d7 db       	rcall	.-2130   	; 0x130c <FSW_Init>
	
	ISRInit();	
    1b5e:	df de       	rcall	.-578    	; 0x191e <ISRInit>
	cpu_irq_enable();
    1b60:	78 94       	sei
	
	initTest();
    1b62:	80 d8       	rcall	.-3840   	; 0xc64 <initTest>
		
    while(1)
    {
		MIDI_ParserTask();
    1b64:	de d7       	rcall	.+4028   	; 0x2b22 <__TEXT_REGION_LENGTH__+0xb22>
    1b66:	fe cf       	rjmp	.-4      	; 0x1b64 <main+0x10>

Disassembly of section .text.__vector_16:

00000dfe <__vector_16>:
	}
}

//==========================Main AMP task=======================================
ISR(TIMER0_OVF_vect)
{
 dfe:	1f 92       	push	r1
 e00:	0f 92       	push	r0
 e02:	0f b6       	in	r0, 0x3f	; 63
 e04:	0f 92       	push	r0
 e06:	11 24       	eor	r1, r1
 e08:	cf 92       	push	r12
 e0a:	df 92       	push	r13
 e0c:	ef 92       	push	r14
 e0e:	0f 93       	push	r16
 e10:	1f 93       	push	r17
 e12:	2f 93       	push	r18
 e14:	3f 93       	push	r19
 e16:	4f 93       	push	r20
 e18:	5f 93       	push	r21
 e1a:	6f 93       	push	r22
 e1c:	7f 93       	push	r23
 e1e:	8f 93       	push	r24
 e20:	9f 93       	push	r25
 e22:	af 93       	push	r26
 e24:	bf 93       	push	r27
 e26:	ef 93       	push	r30
 e28:	ff 93       	push	r31
 e2a:	cf 93       	push	r28
 e2c:	df 93       	push	r29
 e2e:	cd b7       	in	r28, 0x3d	; 61
 e30:	de b7       	in	r29, 0x3e	; 62
 e32:	2f 97       	sbiw	r28, 0x0f	; 15
 e34:	de bf       	out	0x3e, r29	; 62
 e36:	cd bf       	out	0x3d, r28	; 61
	SH100HW_MainTask();
 e38:	72 da       	rcall	.-2844   	; 0x31e <SH100HW_MainTask>
	
	if(isAmpStarted)
 e3a:	80 91 a8 01 	lds	r24, 0x01A8	; 0x8001a8 <isAmpStarted>
 e3e:	88 23       	and	r24, r24
 e40:	19 f0       	breq	.+6      	; 0xe48 <__vector_16+0x4a>
	{
		SH100CTRL_CheckOutputJacks();
 e42:	28 d1       	rcall	.+592    	; 0x1094 <SH100CTRL_CheckOutputJacks>
		SH100HW_StartADConvertion(ADC_V_NEGATIVE);
 e44:	87 e0       	ldi	r24, 0x07	; 7
 e46:	90 d6       	rcall	.+3360   	; 0x1b68 <SH100HW_StartADConvertion>
	}
	
	SH100HW_Controls_t pressedButtons = SH100HW_GetControlsState();
 e48:	8e 01       	movw	r16, r28
 e4a:	0f 5f       	subi	r16, 0xFF	; 255
 e4c:	1f 4f       	sbci	r17, 0xFF	; 255
 e4e:	c8 01       	movw	r24, r16
 e50:	88 dd       	rcall	.-1264   	; 0x962 <SH100HW_GetControlsState>
	
	MIDICTRL_SetMidiChannel(pressedButtons.midiChNum);
 e52:	89 81       	ldd	r24, Y+1	; 0x01
 e54:	e6 d6       	rcall	.+3532   	; 0x1c22 <MIDICTRL_SetMidiChannel>
	MIDICTRL_OmniModeEn(pressedButtons.midiOmni);
 e56:	8a 81       	ldd	r24, Y+2	; 0x02
 e58:	e7 d6       	rcall	.+3534   	; 0x1c28 <MIDICTRL_OmniModeEn>
	MIDICTRL_MuteCommEn(pressedButtons.midiMuteComm);
 e5a:	8b 81       	ldd	r24, Y+3	; 0x03
 e5c:	e8 d6       	rcall	.+3536   	; 0x1c2e <MIDICTRL_MuteCommEn>
	
	FBTNS_MainTask(&pressedButtons);
 e5e:	68 01       	movw	r12, r16
 e60:	80 e8       	ldi	r24, 0x80	; 128
 e62:	e8 2e       	mov	r14, r24
 e64:	8e 2d       	mov	r24, r14
 e66:	b6 01       	movw	r22, r12
 e68:	33 d9       	rcall	.-3482   	; 0xd0 <FBTNS_MainTask>
	FSW_MainTask(&pressedButtons);
 e6a:	8e 2d       	mov	r24, r14
 e6c:	b6 01       	movw	r22, r12
 e6e:	7a db       	rcall	.-2316   	; 0x564 <FSW_MainTask>
	
	TCNT0 = 0xFF - MAIN_TIMER_PERIOD;
 e70:	8e e9       	ldi	r24, 0x9E	; 158
 e72:	86 bd       	out	0x26, r24	; 38
}
 e74:	2f 96       	adiw	r28, 0x0f	; 15
 e76:	0f b6       	in	r0, 0x3f	; 63
 e78:	f8 94       	cli
 e7a:	de bf       	out	0x3e, r29	; 62
 e7c:	0f be       	out	0x3f, r0	; 63
 e7e:	cd bf       	out	0x3d, r28	; 61
 e80:	df 91       	pop	r29
 e82:	cf 91       	pop	r28
 e84:	ff 91       	pop	r31
 e86:	ef 91       	pop	r30
 e88:	bf 91       	pop	r27
 e8a:	af 91       	pop	r26
 e8c:	9f 91       	pop	r25
 e8e:	8f 91       	pop	r24
 e90:	7f 91       	pop	r23
 e92:	6f 91       	pop	r22
 e94:	5f 91       	pop	r21
 e96:	4f 91       	pop	r20
 e98:	3f 91       	pop	r19
 e9a:	2f 91       	pop	r18
 e9c:	1f 91       	pop	r17
 e9e:	0f 91       	pop	r16
 ea0:	ef 90       	pop	r14
 ea2:	df 90       	pop	r13
 ea4:	cf 90       	pop	r12
 ea6:	0f 90       	pop	r0
 ea8:	0f be       	out	0x3f, r0	; 63
 eaa:	0f 90       	pop	r0
 eac:	1f 90       	pop	r1
 eae:	18 95       	reti

Disassembly of section .text.__vector_21:

00000d3c <__vector_21>:

int16_t negVdd;
int16_t posVdd;
bool measSwitch = false;
ISR(ADC_vect)
{
 d3c:	1f 92       	push	r1
 d3e:	0f 92       	push	r0
 d40:	0f b6       	in	r0, 0x3f	; 63
 d42:	0f 92       	push	r0
 d44:	11 24       	eor	r1, r1
 d46:	2f 93       	push	r18
 d48:	3f 93       	push	r19
 d4a:	4f 93       	push	r20
 d4c:	5f 93       	push	r21
 d4e:	6f 93       	push	r22
 d50:	7f 93       	push	r23
 d52:	8f 93       	push	r24
 d54:	9f 93       	push	r25
 d56:	af 93       	push	r26
 d58:	bf 93       	push	r27
 d5a:	ef 93       	push	r30
 d5c:	ff 93       	push	r31
	if(isAmpStarted)
 d5e:	80 91 a8 01 	lds	r24, 0x01A8	; 0x8001a8 <isAmpStarted>
 d62:	88 23       	and	r24, r24
 d64:	d9 f1       	breq	.+118    	; 0xddc <__vector_21+0xa0>
	{
		if(measSwitch)
 d66:	80 91 a7 01 	lds	r24, 0x01A7	; 0x8001a7 <measSwitch>
 d6a:	88 23       	and	r24, r24
 d6c:	59 f0       	breq	.+22     	; 0xd84 <__vector_21+0x48>
		{
			posVdd = ADC;
 d6e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7fe078>
 d72:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7fe079>
 d76:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <posVdd+0x1>
 d7a:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <posVdd>
			measSwitch = false;
 d7e:	10 92 a7 01 	sts	0x01A7, r1	; 0x8001a7 <measSwitch>
 d82:	0d c0       	rjmp	.+26     	; 0xd9e <__vector_21+0x62>
			//SH100HW_StartADConvertion(ADC_V_NEGATIVE);
		}
		else
		{
			negVdd = ADC;
 d84:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7fe078>
 d88:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7fe079>
 d8c:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <negVdd+0x1>
 d90:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <negVdd>
			measSwitch = true;
 d94:	81 e0       	ldi	r24, 0x01	; 1
 d96:	80 93 a7 01 	sts	0x01A7, r24	; 0x8001a7 <measSwitch>
			SH100HW_StartADConvertion(ADC_V_POSITIVE);
 d9a:	80 e0       	ldi	r24, 0x00	; 0
 d9c:	e5 d6       	rcall	.+3530   	; 0x1b68 <SH100HW_StartADConvertion>
		}
		
		if(fabs(negVdd-posVdd) > 100)
 d9e:	60 91 10 01 	lds	r22, 0x0110	; 0x800110 <negVdd>
 da2:	70 91 11 01 	lds	r23, 0x0111	; 0x800111 <negVdd+0x1>
 da6:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <posVdd>
 daa:	90 91 13 01 	lds	r25, 0x0113	; 0x800113 <posVdd+0x1>
 dae:	68 1b       	sub	r22, r24
 db0:	79 0b       	sbc	r23, r25
 db2:	07 2e       	mov	r0, r23
 db4:	00 0c       	add	r0, r0
 db6:	88 0b       	sbc	r24, r24
 db8:	99 0b       	sbc	r25, r25
 dba:	b9 d0       	rcall	.+370    	; 0xf2e <__floatsisf>
 dbc:	9f 77       	andi	r25, 0x7F	; 127
 dbe:	20 e0       	ldi	r18, 0x00	; 0
 dc0:	30 e0       	ldi	r19, 0x00	; 0
 dc2:	48 ec       	ldi	r20, 0xC8	; 200
 dc4:	52 e4       	ldi	r21, 0x42	; 66
 dc6:	26 d7       	rcall	.+3660   	; 0x1c14 <__gesf2>
 dc8:	18 16       	cp	r1, r24
 dca:	44 f4       	brge	.+16     	; 0xddc <__vector_21+0xa0>
		{
			// one of Vdd rail is out
			SH100HW_SetPAFailure(true);
 dcc:	81 e0       	ldi	r24, 0x01	; 1
 dce:	ed d6       	rcall	.+3546   	; 0x1baa <SH100HW_SetPAFailure>
			SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
 dd0:	60 e0       	ldi	r22, 0x00	; 0
 dd2:	87 e0       	ldi	r24, 0x07	; 7
 dd4:	8e d5       	rcall	.+2844   	; 0x18f2 <SH100HW_SetNewLedState>
			SH100HW_SetNewLedState(LED_PWR_RED, LED_FAST_BLINKING);
 dd6:	62 e0       	ldi	r22, 0x02	; 2
 dd8:	88 e0       	ldi	r24, 0x08	; 8
 dda:	8b d5       	rcall	.+2838   	; 0x18f2 <SH100HW_SetNewLedState>
		}
	}
}
 ddc:	ff 91       	pop	r31
 dde:	ef 91       	pop	r30
 de0:	bf 91       	pop	r27
 de2:	af 91       	pop	r26
 de4:	9f 91       	pop	r25
 de6:	8f 91       	pop	r24
 de8:	7f 91       	pop	r23
 dea:	6f 91       	pop	r22
 dec:	5f 91       	pop	r21
 dee:	4f 91       	pop	r20
 df0:	3f 91       	pop	r19
 df2:	2f 91       	pop	r18
 df4:	0f 90       	pop	r0
 df6:	0f be       	out	0x3f, r0	; 63
 df8:	0f 90       	pop	r0
 dfa:	1f 90       	pop	r1
 dfc:	18 95       	reti

Disassembly of section .text.__vector_4:

0000149c <__vector_4>:

//=========================PWR Turn off INT=================================
ISR(PCINT1_vect)
{
    149c:	1f 92       	push	r1
    149e:	0f 92       	push	r0
    14a0:	0f b6       	in	r0, 0x3f	; 63
    14a2:	0f 92       	push	r0
    14a4:	11 24       	eor	r1, r1
    14a6:	2f 93       	push	r18
    14a8:	3f 93       	push	r19
    14aa:	4f 93       	push	r20
    14ac:	5f 93       	push	r21
    14ae:	6f 93       	push	r22
    14b0:	7f 93       	push	r23
    14b2:	8f 93       	push	r24
    14b4:	9f 93       	push	r25
    14b6:	af 93       	push	r26
    14b8:	bf 93       	push	r27
    14ba:	ef 93       	push	r30
    14bc:	ff 93       	push	r31
	SH100CTRL_StoreAmpState();
    14be:	cd d2       	rcall	.+1434   	; 0x1a5a <SH100CTRL_StoreAmpState>
	SH100CTRL_MuteAmp();
    14c0:	bc d3       	rcall	.+1912   	; 0x1c3a <SH100CTRL_MuteAmp>
}
    14c2:	ff 91       	pop	r31
    14c4:	ef 91       	pop	r30
    14c6:	bf 91       	pop	r27
    14c8:	af 91       	pop	r26
    14ca:	9f 91       	pop	r25
    14cc:	8f 91       	pop	r24
    14ce:	7f 91       	pop	r23
    14d0:	6f 91       	pop	r22
    14d2:	5f 91       	pop	r21
    14d4:	4f 91       	pop	r20
    14d6:	3f 91       	pop	r19
    14d8:	2f 91       	pop	r18
    14da:	0f 90       	pop	r0
    14dc:	0f be       	out	0x3f, r0	; 63
    14de:	0f 90       	pop	r0
    14e0:	1f 90       	pop	r1
    14e2:	18 95       	reti

Disassembly of section .text.MIDI_IsStatusWord:

00001c0c <MIDI_IsStatusWord>:
#include "midi.h"

bool MIDI_IsStatusWord(uint8_t word)
{
	return (word & 0x80);
}
    1c0c:	88 1f       	adc	r24, r24
    1c0e:	88 27       	eor	r24, r24
    1c10:	88 1f       	adc	r24, r24
    1c12:	08 95       	ret

Disassembly of section .text.MIDI_IsSysRealTime:

00001bd4 <MIDI_IsSysRealTime>:

bool MIDI_IsSysRealTime(uint8_t word)
{
	return word > 0xF7;
    1bd4:	91 e0       	ldi	r25, 0x01	; 1
    1bd6:	88 3f       	cpi	r24, 0xF8	; 248
    1bd8:	08 f4       	brcc	.+2      	; 0x1bdc <MIDI_IsSysRealTime+0x8>
    1bda:	90 e0       	ldi	r25, 0x00	; 0
}
    1bdc:	89 2f       	mov	r24, r25
    1bde:	08 95       	ret

Disassembly of section .text.MIDI_GetStatusType:

0000110c <MIDI_GetStatusType>:

MIDI_StatusType_t MIDI_GetStatusType(MIDI_Status_t status)
{
	switch(status)
    110c:	82 3f       	cpi	r24, 0xF2	; 242
    110e:	01 f1       	breq	.+64     	; 0x1150 <MIDI_GetStatusType+0x44>
    1110:	68 f4       	brcc	.+26     	; 0x112c <MIDI_GetStatusType+0x20>
    1112:	8e 30       	cpi	r24, 0x0E	; 14
    1114:	28 f4       	brcc	.+10     	; 0x1120 <MIDI_GetStatusType+0x14>
    1116:	8c 30       	cpi	r24, 0x0C	; 12
    1118:	78 f5       	brcc	.+94     	; 0x1178 <MIDI_GetStatusType+0x6c>
    111a:	88 30       	cpi	r24, 0x08	; 8
    111c:	c8 f4       	brcc	.+50     	; 0x1150 <MIDI_GetStatusType+0x44>
    111e:	2a c0       	rjmp	.+84     	; 0x1174 <MIDI_GetStatusType+0x68>
    1120:	80 3f       	cpi	r24, 0xF0	; 240
    1122:	21 f1       	breq	.+72     	; 0x116c <MIDI_GetStatusType+0x60>
    1124:	48 f5       	brcc	.+82     	; 0x1178 <MIDI_GetStatusType+0x6c>
    1126:	8e 30       	cpi	r24, 0x0E	; 14
    1128:	99 f0       	breq	.+38     	; 0x1150 <MIDI_GetStatusType+0x44>
    112a:	24 c0       	rjmp	.+72     	; 0x1174 <MIDI_GetStatusType+0x68>
    112c:	8a 3f       	cpi	r24, 0xFA	; 250
    112e:	a1 f0       	breq	.+40     	; 0x1158 <MIDI_GetStatusType+0x4c>
    1130:	38 f4       	brcc	.+14     	; 0x1140 <MIDI_GetStatusType+0x34>
    1132:	87 3f       	cpi	r24, 0xF7	; 247
    1134:	e9 f0       	breq	.+58     	; 0x1170 <MIDI_GetStatusType+0x64>
    1136:	88 3f       	cpi	r24, 0xF8	; 248
    1138:	69 f0       	breq	.+26     	; 0x1154 <MIDI_GetStatusType+0x48>
    113a:	83 3f       	cpi	r24, 0xF3	; 243
    113c:	e9 f0       	breq	.+58     	; 0x1178 <MIDI_GetStatusType+0x6c>
    113e:	1a c0       	rjmp	.+52     	; 0x1174 <MIDI_GetStatusType+0x68>
    1140:	8c 3f       	cpi	r24, 0xFC	; 252
    1142:	71 f0       	breq	.+28     	; 0x1160 <MIDI_GetStatusType+0x54>
    1144:	58 f0       	brcs	.+22     	; 0x115c <MIDI_GetStatusType+0x50>
    1146:	8e 3f       	cpi	r24, 0xFE	; 254
    1148:	69 f0       	breq	.+26     	; 0x1164 <MIDI_GetStatusType+0x58>
    114a:	8f 3f       	cpi	r24, 0xFF	; 255
    114c:	69 f0       	breq	.+26     	; 0x1168 <MIDI_GetStatusType+0x5c>
    114e:	12 c0       	rjmp	.+36     	; 0x1174 <MIDI_GetStatusType+0x68>
	{
		// Status messages with 2 bytes
		case MIDI_COMM_NOTE_OFF: return MIDI_TYPE_TWO_BYTE;
    1150:	82 e0       	ldi	r24, 0x02	; 2
    1152:	08 95       	ret
		case MIDI_COMM_CHANNEL_PRESSURE: return MIDI_TYPE_ONE_BYTE;
		case MIDI_COMM_TIME_CODE: return MIDI_TYPE_ONE_BYTE;
		case MIDI_COMM_SONG_SELECT: return MIDI_TYPE_ONE_BYTE;

		// System real-time messages(no data bytes)
		case MIDI_COMM_TIMING_CLOCK: return MIDI_TYPE_REAL_TIME;
    1154:	83 e0       	ldi	r24, 0x03	; 3
    1156:	08 95       	ret
		case MIDI_COMM_START: return MIDI_TYPE_REAL_TIME;
    1158:	83 e0       	ldi	r24, 0x03	; 3
    115a:	08 95       	ret
		case MIDI_COMM_CONTINUE: return MIDI_TYPE_REAL_TIME;
    115c:	83 e0       	ldi	r24, 0x03	; 3
    115e:	08 95       	ret
		case MIDI_COMM_STO: return MIDI_TYPE_REAL_TIME;
    1160:	83 e0       	ldi	r24, 0x03	; 3
    1162:	08 95       	ret
		case MIDI_COMM_ACTIVE_SENSING: return MIDI_TYPE_REAL_TIME;
    1164:	83 e0       	ldi	r24, 0x03	; 3
    1166:	08 95       	ret
		case MIDI_COMM_SYSTEM_RESET: return MIDI_TYPE_REAL_TIME;
    1168:	83 e0       	ldi	r24, 0x03	; 3
    116a:	08 95       	ret

		// System exclusive
		case MIDI_COMM_START_SYS_EX: return MIDI_TYPE_START_SYS_EX;
    116c:	84 e0       	ldi	r24, 0x04	; 4
    116e:	08 95       	ret
		case MIDI_COMM_STOP_SYS_EX: return MIDI_TYPE_STOP_SYS_EX;
    1170:	85 e0       	ldi	r24, 0x05	; 5
    1172:	08 95       	ret
		
		default: return MIDI_TYPE_UNDEFINED;
    1174:	80 e0       	ldi	r24, 0x00	; 0
    1176:	08 95       	ret
		case MIDI_COMM_CONTROL_CHANGE: return MIDI_TYPE_TWO_BYTE;
		case MIDI_COMM_PITCH_BEND: return MIDI_TYPE_TWO_BYTE;
		case MIDI_COMM_SONG_POSITION: return MIDI_TYPE_TWO_BYTE;

		// Status messages with 1 byte
		case MIDI_COMM_PROGRAM_CHANGE: return MIDI_TYPE_ONE_BYTE;
    1178:	81 e0       	ldi	r24, 0x01	; 1
		case MIDI_COMM_START_SYS_EX: return MIDI_TYPE_START_SYS_EX;
		case MIDI_COMM_STOP_SYS_EX: return MIDI_TYPE_STOP_SYS_EX;
		
		default: return MIDI_TYPE_UNDEFINED;
	}
    117a:	08 95       	ret

Disassembly of section .text.isEqualCommands:

00001572 <isEqualCommands>:

void indicateMidiError();

bool isEqualCommands(const MIDI_Command_t* commandRecieved, const MIDI_Command_t* commandSaved)
{
	if(commandRecieved->status != commandSaved->status) return false;
    1572:	fb 01       	movw	r30, r22
    1574:	54 91       	lpm	r21, Z
    1576:	87 fd       	sbrc	r24, 7
    1578:	50 81       	ld	r21, Z
    157a:	f9 01       	movw	r30, r18
    157c:	94 91       	lpm	r25, Z
    157e:	47 fd       	sbrc	r20, 7
    1580:	90 81       	ld	r25, Z
    1582:	59 13       	cpse	r21, r25
    1584:	13 c0       	rjmp	.+38     	; 0x15ac <isEqualCommands+0x3a>
	if(commandRecieved->data1 != commandSaved->data1) return false;
    1586:	a8 2f       	mov	r26, r24
    1588:	cb 01       	movw	r24, r22
    158a:	02 96       	adiw	r24, 0x02	; 2
    158c:	a1 1d       	adc	r26, r1
    158e:	fc 01       	movw	r30, r24
    1590:	94 91       	lpm	r25, Z
    1592:	a7 fd       	sbrc	r26, 7
    1594:	90 81       	ld	r25, Z
    1596:	2e 5f       	subi	r18, 0xFE	; 254
    1598:	3f 4f       	sbci	r19, 0xFF	; 255
    159a:	4f 4f       	sbci	r20, 0xFF	; 255
    159c:	f9 01       	movw	r30, r18
    159e:	84 91       	lpm	r24, Z
    15a0:	47 fd       	sbrc	r20, 7
    15a2:	80 81       	ld	r24, Z
    15a4:	98 17       	cp	r25, r24
    15a6:	21 f0       	breq	.+8      	; 0x15b0 <isEqualCommands+0x3e>
    15a8:	80 e0       	ldi	r24, 0x00	; 0
    15aa:	08 95       	ret

void indicateMidiError();

bool isEqualCommands(const MIDI_Command_t* commandRecieved, const MIDI_Command_t* commandSaved)
{
	if(commandRecieved->status != commandSaved->status) return false;
    15ac:	80 e0       	ldi	r24, 0x00	; 0
    15ae:	08 95       	ret
	if(commandRecieved->data1 != commandSaved->data1) return false;
			
	return true;
    15b0:	81 e0       	ldi	r24, 0x01	; 1
}
    15b2:	08 95       	ret

Disassembly of section .text.loadCommSetFromMemory:

00000eb0 <loadCommSetFromMemory>:

void loadCommSetFromMemory()
{
 eb0:	cf 93       	push	r28
 eb2:	df 93       	push	r29
 eb4:	cd b7       	in	r28, 0x3d	; 61
 eb6:	de b7       	in	r29, 0x3e	; 62
 eb8:	68 97       	sbiw	r28, 0x18	; 24
 eba:	0f b6       	in	r0, 0x3f	; 63
 ebc:	f8 94       	cli
 ebe:	de bf       	out	0x3e, r29	; 62
 ec0:	0f be       	out	0x3f, r0	; 63
 ec2:	cd bf       	out	0x3d, r28	; 61
	uint16_t readedMagicWord = eeprom_read_word((uint16_t*)0x02);
 ec4:	62 e0       	ldi	r22, 0x02	; 2
 ec6:	70 e0       	ldi	r23, 0x00	; 0
 ec8:	80 e8       	ldi	r24, 0x80	; 128
 eca:	90 d6       	rcall	.+3360   	; 0x1bec <eeprom_read_word>
		
	if(readedMagicWord == MEMORY_MAGIC_WORD)
 ecc:	8b 3a       	cpi	r24, 0xAB	; 171
 ece:	9c 4a       	sbci	r25, 0xAC	; 172
 ed0:	c1 f4       	brne	.+48     	; 0xf02 <loadCommSetFromMemory+0x52>
	{
		// memory is not empty. Load EEPROM values
		uint8_t readedData[sizeof(MIDICTRL_CommandBlock_t)];
		eeprom_read_block(&readedData, (void*)MEMORY_USER_COMMANDS_OFFSET, sizeof(MIDICTRL_CommandBlock_t));
 ed2:	4f e0       	ldi	r20, 0x0F	; 15
 ed4:	50 e0       	ldi	r21, 0x00	; 0
 ed6:	60 e8       	ldi	r22, 0x80	; 128
 ed8:	28 e1       	ldi	r18, 0x18	; 24
 eda:	30 e0       	ldi	r19, 0x00	; 0
 edc:	ce 01       	movw	r24, r28
 ede:	01 96       	adiw	r24, 0x01	; 1
 ee0:	59 d5       	rcall	.+2738   	; 0x1994 <eeprom_read_block>
		MIDICTRL_CommandBlock_t* userCommands_ptr = (MIDICTRL_CommandBlock_t*)readedData;
		userCommands = *userCommands_ptr;
 ee2:	88 e1       	ldi	r24, 0x18	; 24
 ee4:	fe 01       	movw	r30, r28
 ee6:	31 96       	adiw	r30, 0x01	; 1
 ee8:	ac e1       	ldi	r26, 0x1C	; 28
 eea:	b1 e0       	ldi	r27, 0x01	; 1
 eec:	01 90       	ld	r0, Z+
 eee:	0d 92       	st	X+, r0
 ef0:	8a 95       	dec	r24
 ef2:	e1 f7       	brne	.-8      	; 0xeec <loadCommSetFromMemory+0x3c>
			
		commandSet = eeprom_read_byte((uint8_t*)MEMORY_COMMAND_BLOCK_TYPE_OFFSET);
 ef4:	6e e0       	ldi	r22, 0x0E	; 14
 ef6:	70 e0       	ldi	r23, 0x00	; 0
 ef8:	80 e8       	ldi	r24, 0x80	; 128
 efa:	40 d6       	rcall	.+3200   	; 0x1b7c <eeprom_read_byte>
 efc:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <commandSet>
 f00:	0b c0       	rjmp	.+22     	; 0xf18 <loadCommSetFromMemory+0x68>
	}
	else
	{
		// memory empty. Load default values
		userCommands = defaultCommands;
 f02:	88 e1       	ldi	r24, 0x18	; 24
 f04:	e5 e8       	ldi	r30, 0x85	; 133
 f06:	f1 e0       	ldi	r31, 0x01	; 1
 f08:	ac e1       	ldi	r26, 0x1C	; 28
 f0a:	b1 e0       	ldi	r27, 0x01	; 1
 f0c:	01 90       	ld	r0, Z+
 f0e:	0d 92       	st	X+, r0
 f10:	8a 95       	dec	r24
 f12:	e1 f7       	brne	.-8      	; 0xf0c <loadCommSetFromMemory+0x5c>
		commandSet = DEFAULT;
 f14:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <commandSet>
	}
}
 f18:	68 96       	adiw	r28, 0x18	; 24
 f1a:	0f b6       	in	r0, 0x3f	; 63
 f1c:	f8 94       	cli
 f1e:	de bf       	out	0x3e, r29	; 62
 f20:	0f be       	out	0x3f, r0	; 63
 f22:	cd bf       	out	0x3d, r28	; 61
 f24:	df 91       	pop	r29
 f26:	cf 91       	pop	r28
 f28:	08 95       	ret

Disassembly of section .text.setMidiLeds:

00001362 <setMidiLeds>:

void setMidiLeds()
{
    1362:	cf 93       	push	r28
	if(mode == PROGRAMMING)
    1364:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode>
    1368:	81 30       	cpi	r24, 0x01	; 1
    136a:	11 f5       	brne	.+68     	; 0x13b0 <setMidiLeds+0x4e>
    136c:	18 c0       	rjmp	.+48     	; 0x139e <setMidiLeds+0x3c>
	{
		for(uint8_t i=0; i<MIDI_PROG_BTN_COUNT; i++)
		{
			switch(midiProgBtnState[i])
    136e:	ec 2f       	mov	r30, r28
    1370:	f0 e0       	ldi	r31, 0x00	; 0
    1372:	eb 5e       	subi	r30, 0xEB	; 235
    1374:	fe 4f       	sbci	r31, 0xFE	; 254
    1376:	80 81       	ld	r24, Z
    1378:	81 30       	cpi	r24, 0x01	; 1
    137a:	41 f0       	breq	.+16     	; 0x138c <setMidiLeds+0x2a>
    137c:	18 f0       	brcs	.+6      	; 0x1384 <setMidiLeds+0x22>
    137e:	82 30       	cpi	r24, 0x02	; 2
    1380:	49 f0       	breq	.+18     	; 0x1394 <setMidiLeds+0x32>
    1382:	0b c0       	rjmp	.+22     	; 0x139a <setMidiLeds+0x38>
			{
				case PROG_CLEAR: SH100HW_SetNewLedState(i, LED_OFF); break;
    1384:	60 e0       	ldi	r22, 0x00	; 0
    1386:	8c 2f       	mov	r24, r28
    1388:	b4 d2       	rcall	.+1384   	; 0x18f2 <SH100HW_SetNewLedState>
    138a:	07 c0       	rjmp	.+14     	; 0x139a <setMidiLeds+0x38>
				case PROG_ACTING: SH100HW_SetNewLedState(i, LED_FAST_BLINKING); break;
    138c:	62 e0       	ldi	r22, 0x02	; 2
    138e:	8c 2f       	mov	r24, r28
    1390:	b0 d2       	rcall	.+1376   	; 0x18f2 <SH100HW_SetNewLedState>
    1392:	03 c0       	rjmp	.+6      	; 0x139a <setMidiLeds+0x38>
				case PROG_PROGRAMMED: SH100HW_SetNewLedState(i, LED_ON); break;
    1394:	61 e0       	ldi	r22, 0x01	; 1
    1396:	8c 2f       	mov	r24, r28
    1398:	ac d2       	rcall	.+1368   	; 0x18f2 <SH100HW_SetNewLedState>

void setMidiLeds()
{
	if(mode == PROGRAMMING)
	{
		for(uint8_t i=0; i<MIDI_PROG_BTN_COUNT; i++)
    139a:	cf 5f       	subi	r28, 0xFF	; 255
    139c:	01 c0       	rjmp	.+2      	; 0x13a0 <setMidiLeds+0x3e>
    139e:	c0 e0       	ldi	r28, 0x00	; 0
    13a0:	c6 30       	cpi	r28, 0x06	; 6
    13a2:	28 f3       	brcs	.-54     	; 0x136e <setMidiLeds+0xc>
				case PROG_ACTING: SH100HW_SetNewLedState(i, LED_FAST_BLINKING); break;
				case PROG_PROGRAMMED: SH100HW_SetNewLedState(i, LED_ON); break;
			}
		}
		
		if(currentErrBtnId != MIDI_PROG_BTN_UNDEFINED)
    13a4:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <currentErrBtnId>
    13a8:	8f 3f       	cpi	r24, 0xFF	; 255
    13aa:	11 f0       	breq	.+4      	; 0x13b0 <setMidiLeds+0x4e>
		{
			SH100HW_SetNewLedState(currentErrBtnId, LED_ON);
    13ac:	61 e0       	ldi	r22, 0x01	; 1
    13ae:	a1 d2       	rcall	.+1346   	; 0x18f2 <SH100HW_SetNewLedState>
		}
	}
}
    13b0:	cf 91       	pop	r28
    13b2:	08 95       	ret

Disassembly of section .text.MIDICTRL_Init:

00001b9c <MIDICTRL_Init>:

void MIDICTRL_Init()
{	
	currentErrBtnId = MIDI_PROG_BTN_UNDEFINED;
    1b9c:	8f ef       	ldi	r24, 0xFF	; 255
    1b9e:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <currentErrBtnId>
	
	loadCommSetFromMemory();
    1ba2:	86 d9       	rcall	.-3316   	; 0xeb0 <loadCommSetFromMemory>
	mode = RUNNING;
    1ba4:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <mode>
    1ba8:	08 95       	ret

Disassembly of section .text.MIDICTRL_MidiMode:

00001c1c <MIDICTRL_MidiMode>:
}

MIDICTRL_Mode_t MIDICTRL_MidiMode()
{
	return mode;
}
    1c1c:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode>
    1c20:	08 95       	ret

Disassembly of section .text.MIDICTRL_SetProgrammingButton:

00001896 <MIDICTRL_SetProgrammingButton>:

void MIDICTRL_SetProgrammingButton(uint8_t progBtnId)
{
	if(midiProgBtnState[currentProgBtn] == PROG_ACTING) 
    1896:	20 91 34 01 	lds	r18, 0x0134	; 0x800134 <currentProgBtn>
    189a:	30 e0       	ldi	r19, 0x00	; 0
    189c:	f9 01       	movw	r30, r18
    189e:	eb 5e       	subi	r30, 0xEB	; 235
    18a0:	fe 4f       	sbci	r31, 0xFE	; 254
    18a2:	90 81       	ld	r25, Z
    18a4:	91 30       	cpi	r25, 0x01	; 1
    18a6:	21 f4       	brne	.+8      	; 0x18b0 <MIDICTRL_SetProgrammingButton+0x1a>
	{
		midiProgBtnState[currentProgBtn] = PROG_CLEAR;
    18a8:	f9 01       	movw	r30, r18
    18aa:	eb 5e       	subi	r30, 0xEB	; 235
    18ac:	fe 4f       	sbci	r31, 0xFE	; 254
    18ae:	10 82       	st	Z, r1
	}
	
	currentProgBtn = progBtnId;
    18b0:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <currentProgBtn>
	midiProgBtnState[currentProgBtn] = PROG_ACTING;
    18b4:	e8 2f       	mov	r30, r24
    18b6:	f0 e0       	ldi	r31, 0x00	; 0
    18b8:	eb 5e       	subi	r30, 0xEB	; 235
    18ba:	fe 4f       	sbci	r31, 0xFE	; 254
    18bc:	81 e0       	ldi	r24, 0x01	; 1
    18be:	80 83       	st	Z, r24
	setMidiLeds();
    18c0:	50 dd       	rcall	.-1376   	; 0x1362 <setMidiLeds>
    18c2:	08 95       	ret

Disassembly of section .text.MIDICTRL_EnterProgrammingMode:

000016f2 <MIDICTRL_EnterProgrammingMode>:
	mode = RUNNING;
}

void MIDICTRL_EnterProgrammingMode()
{	
	mode = PROGRAMMING;
    16f2:	81 e0       	ldi	r24, 0x01	; 1
    16f4:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <mode>
	MIDI_SetRetranslateState(false);
    16f8:	80 e0       	ldi	r24, 0x00	; 0
    16fa:	9c d2       	rcall	.+1336   	; 0x1c34 <MIDI_SetRetranslateState>
	
	for(uint8_t i=0; i<MIDI_PROG_BTN_COUNT;i++)
    16fc:	80 e0       	ldi	r24, 0x00	; 0
    16fe:	06 c0       	rjmp	.+12     	; 0x170c <MIDICTRL_EnterProgrammingMode+0x1a>
		midiProgBtnState[i] = PROG_CLEAR;
    1700:	e8 2f       	mov	r30, r24
    1702:	f0 e0       	ldi	r31, 0x00	; 0
    1704:	eb 5e       	subi	r30, 0xEB	; 235
    1706:	fe 4f       	sbci	r31, 0xFE	; 254
    1708:	10 82       	st	Z, r1
void MIDICTRL_EnterProgrammingMode()
{	
	mode = PROGRAMMING;
	MIDI_SetRetranslateState(false);
	
	for(uint8_t i=0; i<MIDI_PROG_BTN_COUNT;i++)
    170a:	8f 5f       	subi	r24, 0xFF	; 255
    170c:	86 30       	cpi	r24, 0x06	; 6
    170e:	c0 f3       	brcs	.-16     	; 0x1700 <MIDICTRL_EnterProgrammingMode+0xe>
		midiProgBtnState[i] = PROG_CLEAR;
		
	SH100HW_SetNewLedState(LED_PWR_GRN, LED_SLOW_BLINKING);
    1710:	63 e0       	ldi	r22, 0x03	; 3
    1712:	87 e0       	ldi	r24, 0x07	; 7
    1714:	ee d0       	rcall	.+476    	; 0x18f2 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_PWR_RED, LED_SLOW_BLINKING);
    1716:	63 e0       	ldi	r22, 0x03	; 3
    1718:	88 e0       	ldi	r24, 0x08	; 8
    171a:	eb d0       	rcall	.+470    	; 0x18f2 <SH100HW_SetNewLedState>
	
	SH100HW_SetNewLedState(LED_B, LED_OFF);
    171c:	60 e0       	ldi	r22, 0x00	; 0
    171e:	86 e0       	ldi	r24, 0x06	; 6
    1720:	e8 d0       	rcall	.+464    	; 0x18f2 <SH100HW_SetNewLedState>
	
	MIDICTRL_SetProgrammingButton(MIDI_PROG_BTN_CH1);	
    1722:	80 e0       	ldi	r24, 0x00	; 0
    1724:	b8 d0       	rcall	.+368    	; 0x1896 <MIDICTRL_SetProgrammingButton>
	setMidiLeds();
    1726:	1d de       	rcall	.-966    	; 0x1362 <setMidiLeds>
    1728:	08 95       	ret

Disassembly of section .text.MIDICTRL_SetMidiChannel:

00001c22 <MIDICTRL_SetMidiChannel>:
	setMidiLeds();
}

void MIDICTRL_SetMidiChannel(uint8_t midiChNum)
{
	channelNum = midiChNum;
    1c22:	80 93 a9 01 	sts	0x01A9, r24	; 0x8001a9 <channelNum>
    1c26:	08 95       	ret

Disassembly of section .text.MIDICTRL_OmniModeEn:

00001c28 <MIDICTRL_OmniModeEn>:
}

void MIDICTRL_OmniModeEn(bool isEnabled)
{
	omniModeEnabled = isEnabled;
    1c28:	80 93 ab 01 	sts	0x01AB, r24	; 0x8001ab <omniModeEnabled>
    1c2c:	08 95       	ret

Disassembly of section .text.MIDICTRL_MuteCommEn:

00001c2e <MIDICTRL_MuteCommEn>:
}

void MIDICTRL_MuteCommEn(bool isEnabled)
{
	muteCommandEnabled = isEnabled;
    1c2e:	80 93 aa 01 	sts	0x01AA, r24	; 0x8001aa <muteCommandEnabled>
    1c32:	08 95       	ret

Disassembly of section .text.programmBtn:

00001450 <programmBtn>:
}

void programmBtn(MIDI_Command_t* targetComm, const MIDI_Command_t* srcComm, uint8_t targetBtnId)
{
    1450:	cf 92       	push	r12
    1452:	df 92       	push	r13
    1454:	ef 92       	push	r14
    1456:	dc 01       	movw	r26, r24
	if(midiProgBtnState[targetBtnId] == PROG_ACTING)
    1458:	30 e0       	ldi	r19, 0x00	; 0
    145a:	f9 01       	movw	r30, r18
    145c:	eb 5e       	subi	r30, 0xEB	; 235
    145e:	fe 4f       	sbci	r31, 0xFE	; 254
    1460:	90 81       	ld	r25, Z
    1462:	91 30       	cpi	r25, 0x01	; 1
    1464:	b9 f4       	brne	.+46     	; 0x1494 <programmBtn+0x44>
    1466:	6a 01       	movw	r12, r20
    1468:	e6 2e       	mov	r14, r22
	{
		targetComm->status = srcComm->status;
    146a:	fa 01       	movw	r30, r20
    146c:	84 91       	lpm	r24, Z
    146e:	e7 fc       	sbrc	r14, 7
    1470:	80 81       	ld	r24, Z
    1472:	8c 93       	st	X, r24
		targetComm->data1 = srcComm->data1;
    1474:	82 e0       	ldi	r24, 0x02	; 2
    1476:	c8 0e       	add	r12, r24
    1478:	d1 1c       	adc	r13, r1
    147a:	e1 1c       	adc	r14, r1
    147c:	f6 01       	movw	r30, r12
    147e:	84 91       	lpm	r24, Z
    1480:	e7 fc       	sbrc	r14, 7
    1482:	80 81       	ld	r24, Z
    1484:	12 96       	adiw	r26, 0x02	; 2
    1486:	8c 93       	st	X, r24
		midiProgBtnState[targetBtnId] = PROG_PROGRAMMED;
    1488:	f9 01       	movw	r30, r18
    148a:	eb 5e       	subi	r30, 0xEB	; 235
    148c:	fe 4f       	sbci	r31, 0xFE	; 254
    148e:	82 e0       	ldi	r24, 0x02	; 2
    1490:	80 83       	st	Z, r24
		setMidiLeds();
    1492:	67 df       	rcall	.-306    	; 0x1362 <setMidiLeds>
	}
}
    1494:	ef 90       	pop	r14
    1496:	df 90       	pop	r13
    1498:	cf 90       	pop	r12
    149a:	08 95       	ret

Disassembly of section .text.MIDICTRL_SendSwChComm:

0000117c <MIDICTRL_SendSwChComm>:

void MIDICTRL_SendSwChComm(uint8_t chNum)
{
	if(mode == RUNNING)
    117c:	90 91 1b 01 	lds	r25, 0x011B	; 0x80011b <mode>
    1180:	91 11       	cpse	r25, r1
    1182:	30 c0       	rjmp	.+96     	; 0x11e4 <MIDICTRL_SendSwChComm+0x68>
	{
		MIDICTRL_CommandBlock_t* currentCommandBlock;
		if(commandSet == USER) currentCommandBlock = &userCommands;
    1184:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <commandSet>
    1188:	91 30       	cpi	r25, 0x01	; 1
    118a:	19 f4       	brne	.+6      	; 0x1192 <MIDICTRL_SendSwChComm+0x16>
    118c:	ec e1       	ldi	r30, 0x1C	; 28
    118e:	f1 e0       	ldi	r31, 0x01	; 1
    1190:	02 c0       	rjmp	.+4      	; 0x1196 <MIDICTRL_SendSwChComm+0x1a>
		else currentCommandBlock = &defaultCommands;
    1192:	e5 e8       	ldi	r30, 0x85	; 133
    1194:	f1 e0       	ldi	r31, 0x01	; 1
		
		switch(chNum)
    1196:	81 30       	cpi	r24, 0x01	; 1
    1198:	71 f0       	breq	.+28     	; 0x11b6 <MIDICTRL_SendSwChComm+0x3a>
    119a:	28 f0       	brcs	.+10     	; 0x11a6 <MIDICTRL_SendSwChComm+0x2a>
    119c:	82 30       	cpi	r24, 0x02	; 2
    119e:	99 f0       	breq	.+38     	; 0x11c6 <MIDICTRL_SendSwChComm+0x4a>
    11a0:	83 30       	cpi	r24, 0x03	; 3
    11a2:	c9 f0       	breq	.+50     	; 0x11d6 <MIDICTRL_SendSwChComm+0x5a>
    11a4:	08 95       	ret
		{
			case SH100_CHANNEL1: MIDI_SendCommand(currentCommandBlock->channel1, channelNum); break;
    11a6:	60 81       	ld	r22, Z
    11a8:	71 81       	ldd	r23, Z+1	; 0x01
    11aa:	82 81       	ldd	r24, Z+2	; 0x02
    11ac:	93 81       	ldd	r25, Z+3	; 0x03
    11ae:	40 91 a9 01 	lds	r20, 0x01A9	; 0x8001a9 <channelNum>
    11b2:	f8 de       	rcall	.-528    	; 0xfa4 <MIDI_SendCommand>
    11b4:	08 95       	ret
			case SH100_CHANNEL2: MIDI_SendCommand(currentCommandBlock->channel2, channelNum); break;
    11b6:	64 81       	ldd	r22, Z+4	; 0x04
    11b8:	75 81       	ldd	r23, Z+5	; 0x05
    11ba:	86 81       	ldd	r24, Z+6	; 0x06
    11bc:	97 81       	ldd	r25, Z+7	; 0x07
    11be:	40 91 a9 01 	lds	r20, 0x01A9	; 0x8001a9 <channelNum>
    11c2:	f0 de       	rcall	.-544    	; 0xfa4 <MIDI_SendCommand>
    11c4:	08 95       	ret
			case SH100_CHANNEL3: MIDI_SendCommand(currentCommandBlock->channel3, channelNum); break;
    11c6:	60 85       	ldd	r22, Z+8	; 0x08
    11c8:	71 85       	ldd	r23, Z+9	; 0x09
    11ca:	82 85       	ldd	r24, Z+10	; 0x0a
    11cc:	93 85       	ldd	r25, Z+11	; 0x0b
    11ce:	40 91 a9 01 	lds	r20, 0x01A9	; 0x8001a9 <channelNum>
    11d2:	e8 de       	rcall	.-560    	; 0xfa4 <MIDI_SendCommand>
    11d4:	08 95       	ret
			case SH100_CHANNEL4: MIDI_SendCommand(currentCommandBlock->channel4, channelNum); break;
    11d6:	64 85       	ldd	r22, Z+12	; 0x0c
    11d8:	75 85       	ldd	r23, Z+13	; 0x0d
    11da:	86 85       	ldd	r24, Z+14	; 0x0e
    11dc:	97 85       	ldd	r25, Z+15	; 0x0f
    11de:	40 91 a9 01 	lds	r20, 0x01A9	; 0x8001a9 <channelNum>
    11e2:	e0 de       	rcall	.-576    	; 0xfa4 <MIDI_SendCommand>
    11e4:	08 95       	ret

Disassembly of section .text.MIDICTRL_SendLoopEnComm:

00001762 <MIDICTRL_SendLoopEnComm>:
	}
}

void MIDICTRL_SendLoopEnComm(bool isEn)
{
	if(mode == RUNNING)
    1762:	90 91 1b 01 	lds	r25, 0x011B	; 0x80011b <mode>
    1766:	91 11       	cpse	r25, r1
    1768:	15 c0       	rjmp	.+42     	; 0x1794 <MIDICTRL_SendLoopEnComm+0x32>
	{
		MIDICTRL_CommandBlock_t* currentCommandBlock;
		if(commandSet == USER) currentCommandBlock = &userCommands;
    176a:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <commandSet>
    176e:	91 30       	cpi	r25, 0x01	; 1
    1770:	19 f4       	brne	.+6      	; 0x1778 <MIDICTRL_SendLoopEnComm+0x16>
    1772:	ec e1       	ldi	r30, 0x1C	; 28
    1774:	f1 e0       	ldi	r31, 0x01	; 1
    1776:	02 c0       	rjmp	.+4      	; 0x177c <MIDICTRL_SendLoopEnComm+0x1a>
		else currentCommandBlock = &defaultCommands;
    1778:	e5 e8       	ldi	r30, 0x85	; 133
    177a:	f1 e0       	ldi	r31, 0x01	; 1
		
		MIDI_Command_t loopComm = currentCommandBlock->loopOn;
    177c:	60 89       	ldd	r22, Z+16	; 0x10
    177e:	71 89       	ldd	r23, Z+17	; 0x11
    1780:	22 89       	ldd	r18, Z+18	; 0x12
		loopComm.data2 = isEn ? 0x7F : 0x00;
    1782:	88 23       	and	r24, r24
    1784:	11 f0       	breq	.+4      	; 0x178a <MIDICTRL_SendLoopEnComm+0x28>
    1786:	9f e7       	ldi	r25, 0x7F	; 127
    1788:	01 c0       	rjmp	.+2      	; 0x178c <MIDICTRL_SendLoopEnComm+0x2a>
    178a:	90 e0       	ldi	r25, 0x00	; 0
		
		MIDI_SendCommand(loopComm, channelNum);
    178c:	40 91 a9 01 	lds	r20, 0x01A9	; 0x8001a9 <channelNum>
    1790:	82 2f       	mov	r24, r18
    1792:	08 dc       	rcall	.-2032   	; 0xfa4 <MIDI_SendCommand>
    1794:	08 95       	ret

Disassembly of section .text.MIDICTRL_SendSwABComm:

00001796 <MIDICTRL_SendSwABComm>:
	}
}

void MIDICTRL_SendSwABComm(bool isEn)
{
	if(mode == RUNNING)
    1796:	90 91 1b 01 	lds	r25, 0x011B	; 0x80011b <mode>
    179a:	91 11       	cpse	r25, r1
    179c:	15 c0       	rjmp	.+42     	; 0x17c8 <MIDICTRL_SendSwABComm+0x32>
	{
		MIDICTRL_CommandBlock_t* currentCommandBlock;
		if(commandSet == USER) currentCommandBlock = &userCommands;
    179e:	90 91 35 01 	lds	r25, 0x0135	; 0x800135 <commandSet>
    17a2:	91 30       	cpi	r25, 0x01	; 1
    17a4:	19 f4       	brne	.+6      	; 0x17ac <MIDICTRL_SendSwABComm+0x16>
    17a6:	ec e1       	ldi	r30, 0x1C	; 28
    17a8:	f1 e0       	ldi	r31, 0x01	; 1
    17aa:	02 c0       	rjmp	.+4      	; 0x17b0 <MIDICTRL_SendSwABComm+0x1a>
		else currentCommandBlock = &defaultCommands;
    17ac:	e5 e8       	ldi	r30, 0x85	; 133
    17ae:	f1 e0       	ldi	r31, 0x01	; 1
		
		MIDI_Command_t abComm = currentCommandBlock->outAB;
    17b0:	64 89       	ldd	r22, Z+20	; 0x14
    17b2:	75 89       	ldd	r23, Z+21	; 0x15
    17b4:	26 89       	ldd	r18, Z+22	; 0x16
		abComm.data2 = isEn ? 0x7F : 0x00;
    17b6:	88 23       	and	r24, r24
    17b8:	11 f0       	breq	.+4      	; 0x17be <MIDICTRL_SendSwABComm+0x28>
    17ba:	9f e7       	ldi	r25, 0x7F	; 127
    17bc:	01 c0       	rjmp	.+2      	; 0x17c0 <MIDICTRL_SendSwABComm+0x2a>
    17be:	90 e0       	ldi	r25, 0x00	; 0
		
		MIDI_SendCommand(abComm, channelNum);
    17c0:	40 91 a9 01 	lds	r20, 0x01A9	; 0x8001a9 <channelNum>
    17c4:	82 2f       	mov	r24, r18
    17c6:	ee db       	rcall	.-2084   	; 0xfa4 <MIDI_SendCommand>
    17c8:	08 95       	ret

Disassembly of section .text.MIDICTRL_StoreUserCommands:

00001678 <MIDICTRL_StoreUserCommands>:
	}	
}

void MIDICTRL_StoreUserCommands()
{
	if(mode == PROGRAMMING)
    1678:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode>
    167c:	81 30       	cpi	r24, 0x01	; 1
    167e:	d1 f4       	brne	.+52     	; 0x16b4 <MIDICTRL_StoreUserCommands+0x3c>
	{
		commandSet = USER;
    1680:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <commandSet>
		
		eeprom_write_word((uint16_t*)0x02, MEMORY_MAGIC_WORD);
    1684:	6b ea       	ldi	r22, 0xAB	; 171
    1686:	7c ea       	ldi	r23, 0xAC	; 172
    1688:	82 e0       	ldi	r24, 0x02	; 2
    168a:	90 e0       	ldi	r25, 0x00	; 0
    168c:	df d2       	rcall	.+1470   	; 0x1c4c <eeprom_write_word>
		eeprom_write_byte((void*)MEMORY_COMMAND_BLOCK_TYPE_OFFSET, commandSet);
    168e:	60 91 35 01 	lds	r22, 0x0135	; 0x800135 <commandSet>
    1692:	8e e0       	ldi	r24, 0x0E	; 14
    1694:	90 e0       	ldi	r25, 0x00	; 0
    1696:	fd d1       	rcall	.+1018   	; 0x1a92 <eeprom_write_byte>
		eeprom_write_block(&userCommands, (void*)MEMORY_USER_COMMANDS_OFFSET, sizeof(MIDICTRL_CommandBlock_t));
    1698:	6c e1       	ldi	r22, 0x1C	; 28
    169a:	71 e0       	ldi	r23, 0x01	; 1
    169c:	80 e8       	ldi	r24, 0x80	; 128
    169e:	28 e1       	ldi	r18, 0x18	; 24
    16a0:	30 e0       	ldi	r19, 0x00	; 0
    16a2:	4f e0       	ldi	r20, 0x0F	; 15
    16a4:	50 e0       	ldi	r21, 0x00	; 0
    16a6:	de d0       	rcall	.+444    	; 0x1864 <eeprom_write_block>
		
		SH100HW_SetPreviousLedState(LED_B);
    16a8:	86 e0       	ldi	r24, 0x06	; 6
    16aa:	1a d2       	rcall	.+1076   	; 0x1ae0 <SH100HW_SetPreviousLedState>
		MIDI_SetRetranslateState(true);
    16ac:	81 e0       	ldi	r24, 0x01	; 1
    16ae:	c2 d2       	rcall	.+1412   	; 0x1c34 <MIDI_SetRetranslateState>
		
		mode = RUNNING;
    16b0:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <mode>
    16b4:	08 95       	ret

Disassembly of section .text.MIDICTRL_DiscardCommands:

000019b8 <MIDICTRL_DiscardCommands>:
	}
}

void MIDICTRL_DiscardCommands()
{
	if(mode == PROGRAMMING)
    19b8:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode>
    19bc:	81 30       	cpi	r24, 0x01	; 1
    19be:	61 f4       	brne	.+24     	; 0x19d8 <MIDICTRL_DiscardCommands+0x20>
	{
		commandSet = DEFAULT;
    19c0:	10 92 35 01 	sts	0x0135, r1	; 0x800135 <commandSet>
		eeprom_write_byte((void*)MEMORY_COMMAND_BLOCK_TYPE_OFFSET, commandSet);		
    19c4:	60 e0       	ldi	r22, 0x00	; 0
    19c6:	8e e0       	ldi	r24, 0x0E	; 14
    19c8:	90 e0       	ldi	r25, 0x00	; 0
    19ca:	63 d0       	rcall	.+198    	; 0x1a92 <eeprom_write_byte>
		
		SH100HW_SetPreviousLedState(LED_B);
    19cc:	86 e0       	ldi	r24, 0x06	; 6
    19ce:	88 d0       	rcall	.+272    	; 0x1ae0 <SH100HW_SetPreviousLedState>
		MIDI_SetRetranslateState(true);
    19d0:	81 e0       	ldi	r24, 0x01	; 1
    19d2:	30 d1       	rcall	.+608    	; 0x1c34 <MIDI_SetRetranslateState>
		
		mode = RUNNING;
    19d4:	10 92 1b 01 	sts	0x011B, r1	; 0x80011b <mode>
    19d8:	08 95       	ret

Disassembly of section .text.indicateMidiError:

0000172a <indicateMidiError>:

//===================ERROR indication=================
#define MIDI_ERR_TIMER_PERIOD 9765
void indicateMidiError()
{
	TCNT1 = 0xFFFF - MIDI_ERR_TIMER_PERIOD;
    172a:	8a ed       	ldi	r24, 0xDA	; 218
    172c:	99 ed       	ldi	r25, 0xD9	; 217
    172e:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <__TEXT_REGION_LENGTH__+0x7fe085>
    1732:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <__TEXT_REGION_LENGTH__+0x7fe084>
	TIMSK1 |= 0x01; // OVF INT enable, count pulse = 100us
    1736:	ef e6       	ldi	r30, 0x6F	; 111
    1738:	f0 e0       	ldi	r31, 0x00	; 0
    173a:	80 81       	ld	r24, Z
    173c:	81 60       	ori	r24, 0x01	; 1
    173e:	80 83       	st	Z, r24
	TCCR1B |= 0x05; // psc = 1024, timer on
    1740:	e1 e8       	ldi	r30, 0x81	; 129
    1742:	f0 e0       	ldi	r31, 0x00	; 0
    1744:	80 81       	ld	r24, Z
    1746:	85 60       	ori	r24, 0x05	; 5
    1748:	80 83       	st	Z, r24
	currentErrBtnId = currentProgBtn;
    174a:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <currentProgBtn>
    174e:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <currentErrBtnId>
	setMidiLeds();
    1752:	07 de       	rcall	.-1010   	; 0x1362 <setMidiLeds>
	
	SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
    1754:	60 e0       	ldi	r22, 0x00	; 0
    1756:	87 e0       	ldi	r24, 0x07	; 7
    1758:	cc d0       	rcall	.+408    	; 0x18f2 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_PWR_RED, LED_ON);
    175a:	61 e0       	ldi	r22, 0x01	; 1
    175c:	88 e0       	ldi	r24, 0x08	; 8
    175e:	c9 d0       	rcall	.+402    	; 0x18f2 <SH100HW_SetNewLedState>
    1760:	08 95       	ret

Disassembly of section .text.MIDICTRL_HandleCommand:

00000770 <MIDICTRL_HandleCommand>:
		MIDI_SendCommand(abComm, channelNum);
	}
}

void MIDICTRL_HandleCommand(const MIDI_Command_t* command)
{
 770:	cf 92       	push	r12
 772:	df 92       	push	r13
 774:	ef 92       	push	r14
 776:	cf 93       	push	r28
 778:	df 93       	push	r29
 77a:	6b 01       	movw	r12, r22
 77c:	e8 2e       	mov	r14, r24
	if(FSW_BlockFrontControls()) return;
 77e:	5f d9       	rcall	.-3394   	; 0xfffffa3e <__eeprom_end+0xff7efa3e>
 780:	81 11       	cpse	r24, r1
 782:	e9 c0       	rjmp	.+466    	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
	
	switch(mode)
 784:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <mode>
 788:	88 23       	and	r24, r24
 78a:	21 f0       	breq	.+8      	; 0x794 <MIDICTRL_HandleCommand+0x24>
 78c:	81 30       	cpi	r24, 0x01	; 1
 78e:	09 f4       	brne	.+2      	; 0x792 <MIDICTRL_HandleCommand+0x22>
 790:	8f c0       	rjmp	.+286    	; 0x8b0 <MIDICTRL_HandleCommand+0x140>
 792:	e1 c0       	rjmp	.+450    	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
	{
		case RUNNING:
		{
			if(!omniModeEnabled)
 794:	80 91 ab 01 	lds	r24, 0x01AB	; 0x8001ab <omniModeEnabled>
 798:	81 11       	cpse	r24, r1
 79a:	0c c0       	rjmp	.+24     	; 0x7b4 <MIDICTRL_HandleCommand+0x44>
			{
				if(channelNum != command->channel_type) return;
 79c:	ae 2d       	mov	r26, r14
 79e:	c6 01       	movw	r24, r12
 7a0:	01 96       	adiw	r24, 0x01	; 1
 7a2:	a1 1d       	adc	r26, r1
 7a4:	fc 01       	movw	r30, r24
 7a6:	94 91       	lpm	r25, Z
 7a8:	a7 fd       	sbrc	r26, 7
 7aa:	90 81       	ld	r25, Z
 7ac:	80 91 a9 01 	lds	r24, 0x01A9	; 0x8001a9 <channelNum>
 7b0:	98 13       	cpse	r25, r24
 7b2:	d1 c0       	rjmp	.+418    	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
			}
			
			if(muteCommandEnabled)
 7b4:	80 91 aa 01 	lds	r24, 0x01AA	; 0x8001aa <muteCommandEnabled>
 7b8:	88 23       	and	r24, r24
 7ba:	a9 f0       	breq	.+42     	; 0x7e6 <MIDICTRL_HandleCommand+0x76>
			{
				if(isEqualCommands(command, &muteCommand)) 
 7bc:	2c ec       	ldi	r18, 0xCC	; 204
 7be:	30 e0       	ldi	r19, 0x00	; 0
 7c0:	40 e0       	ldi	r20, 0x00	; 0
 7c2:	8e 2d       	mov	r24, r14
 7c4:	b6 01       	movw	r22, r12
 7c6:	d5 d6       	rcall	.+3498   	; 0x1572 <isEqualCommands>
 7c8:	88 23       	and	r24, r24
 7ca:	69 f0       	breq	.+26     	; 0x7e6 <MIDICTRL_HandleCommand+0x76>
				{
					if((command->data2>63) ? 1 : 0) SH100CTRL_MuteAmp();
 7cc:	ae 2d       	mov	r26, r14
 7ce:	c6 01       	movw	r24, r12
 7d0:	03 96       	adiw	r24, 0x03	; 3
 7d2:	a1 1d       	adc	r26, r1
 7d4:	fc 01       	movw	r30, r24
 7d6:	84 91       	lpm	r24, Z
 7d8:	a7 fd       	sbrc	r26, 7
 7da:	80 81       	ld	r24, Z
 7dc:	80 34       	cpi	r24, 0x40	; 64
 7de:	10 f0       	brcs	.+4      	; 0x7e4 <MIDICTRL_HandleCommand+0x74>
 7e0:	2c da       	rcall	.-2984   	; 0xfffffc3a <__eeprom_end+0xff7efc3a>
 7e2:	01 c0       	rjmp	.+2      	; 0x7e6 <MIDICTRL_HandleCommand+0x76>
					else SH100CTRL_UnmuteAmp();
 7e4:	fd d9       	rcall	.-3078   	; 0xfffffbe0 <__eeprom_end+0xff7efbe0>
				}
			}
			
			MIDICTRL_CommandBlock_t* currentCommandBlock;
			if(commandSet == USER) currentCommandBlock = &userCommands;
 7e6:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <commandSet>
 7ea:	81 30       	cpi	r24, 0x01	; 1
 7ec:	19 f4       	brne	.+6      	; 0x7f4 <MIDICTRL_HandleCommand+0x84>
 7ee:	cc e1       	ldi	r28, 0x1C	; 28
 7f0:	d1 e0       	ldi	r29, 0x01	; 1
 7f2:	02 c0       	rjmp	.+4      	; 0x7f8 <MIDICTRL_HandleCommand+0x88>
			else currentCommandBlock = &defaultCommands;
 7f4:	c5 e8       	ldi	r28, 0x85	; 133
 7f6:	d1 e0       	ldi	r29, 0x01	; 1
			
			// priority ch1, ch2, ch3, ch4, loop, AB. After handling, return. Only one switch by one command
			if(isEqualCommands(command, &(currentCommandBlock->channel1))) 
 7f8:	9e 01       	movw	r18, r28
 7fa:	40 e8       	ldi	r20, 0x80	; 128
 7fc:	8e 2d       	mov	r24, r14
 7fe:	b6 01       	movw	r22, r12
 800:	b8 d6       	rcall	.+3440   	; 0x1572 <isEqualCommands>
 802:	88 23       	and	r24, r24
 804:	19 f0       	breq	.+6      	; 0x80c <MIDICTRL_HandleCommand+0x9c>
			{
				SH100CTRL_SetChannel(0); 
 806:	80 e0       	ldi	r24, 0x00	; 0
 808:	0a d9       	rcall	.-3564   	; 0xfffffa1e <__eeprom_end+0xff7efa1e>
				return;
 80a:	a5 c0       	rjmp	.+330    	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
			}
			if(isEqualCommands(command, &(currentCommandBlock->channel2))) 
 80c:	9e 01       	movw	r18, r28
 80e:	2c 5f       	subi	r18, 0xFC	; 252
 810:	3f 4f       	sbci	r19, 0xFF	; 255
 812:	40 e8       	ldi	r20, 0x80	; 128
 814:	8e 2d       	mov	r24, r14
 816:	b6 01       	movw	r22, r12
 818:	ac d6       	rcall	.+3416   	; 0x1572 <isEqualCommands>
 81a:	88 23       	and	r24, r24
 81c:	19 f0       	breq	.+6      	; 0x824 <MIDICTRL_HandleCommand+0xb4>
			{
				SH100CTRL_SetChannel(1); 
 81e:	81 e0       	ldi	r24, 0x01	; 1
 820:	fe d8       	rcall	.-3588   	; 0xfffffa1e <__eeprom_end+0xff7efa1e>
				return;
 822:	99 c0       	rjmp	.+306    	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
			}
			if(isEqualCommands(command, &(currentCommandBlock->channel3))) 
 824:	9e 01       	movw	r18, r28
 826:	28 5f       	subi	r18, 0xF8	; 248
 828:	3f 4f       	sbci	r19, 0xFF	; 255
 82a:	40 e8       	ldi	r20, 0x80	; 128
 82c:	8e 2d       	mov	r24, r14
 82e:	b6 01       	movw	r22, r12
 830:	a0 d6       	rcall	.+3392   	; 0x1572 <isEqualCommands>
 832:	88 23       	and	r24, r24
 834:	19 f0       	breq	.+6      	; 0x83c <MIDICTRL_HandleCommand+0xcc>
			{
				SH100CTRL_SetChannel(2); 
 836:	82 e0       	ldi	r24, 0x02	; 2
 838:	f2 d8       	rcall	.-3612   	; 0xfffffa1e <__eeprom_end+0xff7efa1e>
				return;
 83a:	8d c0       	rjmp	.+282    	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
			}
			if(isEqualCommands(command, &(currentCommandBlock->channel4))) 
 83c:	9e 01       	movw	r18, r28
 83e:	24 5f       	subi	r18, 0xF4	; 244
 840:	3f 4f       	sbci	r19, 0xFF	; 255
 842:	40 e8       	ldi	r20, 0x80	; 128
 844:	8e 2d       	mov	r24, r14
 846:	b6 01       	movw	r22, r12
 848:	94 d6       	rcall	.+3368   	; 0x1572 <isEqualCommands>
 84a:	88 23       	and	r24, r24
 84c:	19 f0       	breq	.+6      	; 0x854 <MIDICTRL_HandleCommand+0xe4>
			{
				SH100CTRL_SetChannel(3); 
 84e:	83 e0       	ldi	r24, 0x03	; 3
 850:	e6 d8       	rcall	.-3636   	; 0xfffffa1e <__eeprom_end+0xff7efa1e>
				return;
 852:	81 c0       	rjmp	.+258    	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
			}		
			if(isEqualCommands(command, &(currentCommandBlock->loopOn))) 
 854:	9e 01       	movw	r18, r28
 856:	20 5f       	subi	r18, 0xF0	; 240
 858:	3f 4f       	sbci	r19, 0xFF	; 255
 85a:	40 e8       	ldi	r20, 0x80	; 128
 85c:	8e 2d       	mov	r24, r14
 85e:	b6 01       	movw	r22, r12
 860:	88 d6       	rcall	.+3344   	; 0x1572 <isEqualCommands>
 862:	88 23       	and	r24, r24
 864:	71 f0       	breq	.+28     	; 0x882 <MIDICTRL_HandleCommand+0x112>
			{
				SH100CTRL_SetLoop((command->data2>63) ? 1 : 0); 
 866:	83 e0       	ldi	r24, 0x03	; 3
 868:	c8 0e       	add	r12, r24
 86a:	d1 1c       	adc	r13, r1
 86c:	e1 1c       	adc	r14, r1
 86e:	f6 01       	movw	r30, r12
 870:	94 91       	lpm	r25, Z
 872:	e7 fc       	sbrc	r14, 7
 874:	90 81       	ld	r25, Z
 876:	81 e0       	ldi	r24, 0x01	; 1
 878:	90 34       	cpi	r25, 0x40	; 64
 87a:	08 f4       	brcc	.+2      	; 0x87e <MIDICTRL_HandleCommand+0x10e>
 87c:	80 e0       	ldi	r24, 0x00	; 0
 87e:	64 d8       	rcall	.-3896   	; 0xfffff948 <__eeprom_end+0xff7ef948>
				return;
 880:	6a c0       	rjmp	.+212    	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
			}
			if(isEqualCommands(command, &(currentCommandBlock->outAB))) 
 882:	64 96       	adiw	r28, 0x14	; 20
 884:	9e 01       	movw	r18, r28
 886:	40 e8       	ldi	r20, 0x80	; 128
 888:	8e 2d       	mov	r24, r14
 88a:	b6 01       	movw	r22, r12
 88c:	72 d6       	rcall	.+3300   	; 0x1572 <isEqualCommands>
 88e:	88 23       	and	r24, r24
 890:	09 f4       	brne	.+2      	; 0x894 <MIDICTRL_HandleCommand+0x124>
 892:	61 c0       	rjmp	.+194    	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
			{
				SH100CTRL_SetAB((command->data2>63) ? 1 : 0); 
 894:	83 e0       	ldi	r24, 0x03	; 3
 896:	c8 0e       	add	r12, r24
 898:	d1 1c       	adc	r13, r1
 89a:	e1 1c       	adc	r14, r1
 89c:	f6 01       	movw	r30, r12
 89e:	94 91       	lpm	r25, Z
 8a0:	e7 fc       	sbrc	r14, 7
 8a2:	90 81       	ld	r25, Z
 8a4:	81 e0       	ldi	r24, 0x01	; 1
 8a6:	90 34       	cpi	r25, 0x40	; 64
 8a8:	08 f4       	brcc	.+2      	; 0x8ac <MIDICTRL_HandleCommand+0x13c>
 8aa:	80 e0       	ldi	r24, 0x00	; 0
 8ac:	a7 d8       	rcall	.-3762   	; 0xfffff9fc <__eeprom_end+0xff7ef9fc>
				return;
 8ae:	53 c0       	rjmp	.+166    	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
			break;
		}
		
		case PROGRAMMING:
		{
			if(command->status == MIDI_COMM_PROGRAM_CHANGE)
 8b0:	f6 01       	movw	r30, r12
 8b2:	84 91       	lpm	r24, Z
 8b4:	e7 fc       	sbrc	r14, 7
 8b6:	80 81       	ld	r24, Z
 8b8:	8c 30       	cpi	r24, 0x0C	; 12
 8ba:	41 f5       	brne	.+80     	; 0x90c <MIDICTRL_HandleCommand+0x19c>
			{
				switch(currentProgBtn)
 8bc:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <currentProgBtn>
 8c0:	81 30       	cpi	r24, 0x01	; 1
 8c2:	69 f0       	breq	.+26     	; 0x8de <MIDICTRL_HandleCommand+0x16e>
 8c4:	28 f0       	brcs	.+10     	; 0x8d0 <MIDICTRL_HandleCommand+0x160>
 8c6:	82 30       	cpi	r24, 0x02	; 2
 8c8:	89 f0       	breq	.+34     	; 0x8ec <MIDICTRL_HandleCommand+0x17c>
 8ca:	83 30       	cpi	r24, 0x03	; 3
 8cc:	b1 f0       	breq	.+44     	; 0x8fa <MIDICTRL_HandleCommand+0x18a>
 8ce:	1c c0       	rjmp	.+56     	; 0x908 <MIDICTRL_HandleCommand+0x198>
				{
					case MIDI_PROG_BTN_CH1: programmBtn(&(userCommands.channel1), command, MIDI_PROG_BTN_CH1); break;
 8d0:	20 e0       	ldi	r18, 0x00	; 0
 8d2:	6e 2d       	mov	r22, r14
 8d4:	a6 01       	movw	r20, r12
 8d6:	8c e1       	ldi	r24, 0x1C	; 28
 8d8:	91 e0       	ldi	r25, 0x01	; 1
 8da:	ba d5       	rcall	.+2932   	; 0x1450 <programmBtn>
 8dc:	3c c0       	rjmp	.+120    	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
					case MIDI_PROG_BTN_CH2: programmBtn(&(userCommands.channel2), command, MIDI_PROG_BTN_CH2); break;
 8de:	21 e0       	ldi	r18, 0x01	; 1
 8e0:	6e 2d       	mov	r22, r14
 8e2:	a6 01       	movw	r20, r12
 8e4:	80 e2       	ldi	r24, 0x20	; 32
 8e6:	91 e0       	ldi	r25, 0x01	; 1
 8e8:	b3 d5       	rcall	.+2918   	; 0x1450 <programmBtn>
 8ea:	35 c0       	rjmp	.+106    	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
					case MIDI_PROG_BTN_CH3: programmBtn(&(userCommands.channel3), command, MIDI_PROG_BTN_CH3); break;
 8ec:	22 e0       	ldi	r18, 0x02	; 2
 8ee:	6e 2d       	mov	r22, r14
 8f0:	a6 01       	movw	r20, r12
 8f2:	84 e2       	ldi	r24, 0x24	; 36
 8f4:	91 e0       	ldi	r25, 0x01	; 1
 8f6:	ac d5       	rcall	.+2904   	; 0x1450 <programmBtn>
 8f8:	2e c0       	rjmp	.+92     	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
					case MIDI_PROG_BTN_CH4: programmBtn(&(userCommands.channel4), command, MIDI_PROG_BTN_CH4); break;
 8fa:	23 e0       	ldi	r18, 0x03	; 3
 8fc:	6e 2d       	mov	r22, r14
 8fe:	a6 01       	movw	r20, r12
 900:	88 e2       	ldi	r24, 0x28	; 40
 902:	91 e0       	ldi	r25, 0x01	; 1
 904:	a5 d5       	rcall	.+2890   	; 0x1450 <programmBtn>
 906:	27 c0       	rjmp	.+78     	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
					default: indicateMidiError(); break; 
 908:	10 d7       	rcall	.+3616   	; 0x172a <indicateMidiError>
 90a:	25 c0       	rjmp	.+74     	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
				}
			}
			else if(command->status == MIDI_COMM_CONTROL_CHANGE)
 90c:	8b 30       	cpi	r24, 0x0B	; 11
 90e:	11 f5       	brne	.+68     	; 0x954 <MIDICTRL_HandleCommand+0x1e4>
			{
				if(command->data1 == muteCommand.data1)
 910:	ae 2d       	mov	r26, r14
 912:	c6 01       	movw	r24, r12
 914:	02 96       	adiw	r24, 0x02	; 2
 916:	a1 1d       	adc	r26, r1
 918:	fc 01       	movw	r30, r24
 91a:	84 91       	lpm	r24, Z
 91c:	a7 fd       	sbrc	r26, 7
 91e:	80 81       	ld	r24, Z
 920:	87 30       	cpi	r24, 0x07	; 7
 922:	11 f4       	brne	.+4      	; 0x928 <MIDICTRL_HandleCommand+0x1b8>
				{
					indicateMidiError();
 924:	02 d7       	rcall	.+3588   	; 0x172a <indicateMidiError>
 926:	17 c0       	rjmp	.+46     	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
				}
				else
				{
					switch(currentProgBtn)
 928:	80 91 34 01 	lds	r24, 0x0134	; 0x800134 <currentProgBtn>
 92c:	84 30       	cpi	r24, 0x04	; 4
 92e:	49 f0       	breq	.+18     	; 0x942 <MIDICTRL_HandleCommand+0x1d2>
 930:	85 30       	cpi	r24, 0x05	; 5
 932:	71 f4       	brne	.+28     	; 0x950 <MIDICTRL_HandleCommand+0x1e0>
					{
						case MIDI_PROG_BTN_AB: programmBtn(&(userCommands.outAB), command, MIDI_PROG_BTN_AB); break;
 934:	25 e0       	ldi	r18, 0x05	; 5
 936:	6e 2d       	mov	r22, r14
 938:	a6 01       	movw	r20, r12
 93a:	80 e3       	ldi	r24, 0x30	; 48
 93c:	91 e0       	ldi	r25, 0x01	; 1
 93e:	88 d5       	rcall	.+2832   	; 0x1450 <programmBtn>
 940:	0a c0       	rjmp	.+20     	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
						case MIDI_PROG_BTN_LOOP: programmBtn(&(userCommands.loopOn), command, MIDI_PROG_BTN_LOOP); break;
 942:	24 e0       	ldi	r18, 0x04	; 4
 944:	6e 2d       	mov	r22, r14
 946:	a6 01       	movw	r20, r12
 948:	8c e2       	ldi	r24, 0x2C	; 44
 94a:	91 e0       	ldi	r25, 0x01	; 1
 94c:	81 d5       	rcall	.+2818   	; 0x1450 <programmBtn>
 94e:	03 c0       	rjmp	.+6      	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
						default: indicateMidiError(); break;
 950:	ec d6       	rcall	.+3544   	; 0x172a <indicateMidiError>
 952:	01 c0       	rjmp	.+2      	; 0x956 <MIDICTRL_HandleCommand+0x1e6>
					}
				}
			}
			else
			{
				indicateMidiError();
 954:	ea d6       	rcall	.+3540   	; 0x172a <indicateMidiError>
			}			
			break;
		}
	}	
}
 956:	df 91       	pop	r29
 958:	cf 91       	pop	r28
 95a:	ef 90       	pop	r14
 95c:	df 90       	pop	r13
 95e:	cf 90       	pop	r12
 960:	08 95       	ret

Disassembly of section .text.__vector_13:

000011e6 <__vector_13>:
	SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
	SH100HW_SetNewLedState(LED_PWR_RED, LED_ON);
}

ISR(TIMER1_OVF_vect)
{
    11e6:	1f 92       	push	r1
    11e8:	0f 92       	push	r0
    11ea:	0f b6       	in	r0, 0x3f	; 63
    11ec:	0f 92       	push	r0
    11ee:	11 24       	eor	r1, r1
    11f0:	2f 93       	push	r18
    11f2:	3f 93       	push	r19
    11f4:	4f 93       	push	r20
    11f6:	5f 93       	push	r21
    11f8:	6f 93       	push	r22
    11fa:	7f 93       	push	r23
    11fc:	8f 93       	push	r24
    11fe:	9f 93       	push	r25
    1200:	af 93       	push	r26
    1202:	bf 93       	push	r27
    1204:	ef 93       	push	r30
    1206:	ff 93       	push	r31
	TIMSK1 |= 0x00; // OVF INT disable
    1208:	ef e6       	ldi	r30, 0x6F	; 111
    120a:	f0 e0       	ldi	r31, 0x00	; 0
    120c:	80 81       	ld	r24, Z
    120e:	80 83       	st	Z, r24
	TCCR1B |= 0x00; // psc = 0, timer off
    1210:	e1 e8       	ldi	r30, 0x81	; 129
    1212:	f0 e0       	ldi	r31, 0x00	; 0
    1214:	80 81       	ld	r24, Z
    1216:	80 83       	st	Z, r24
	currentErrBtnId = MIDI_PROG_BTN_UNDEFINED;
    1218:	8f ef       	ldi	r24, 0xFF	; 255
    121a:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <currentErrBtnId>
	setMidiLeds();
    121e:	a1 d0       	rcall	.+322    	; 0x1362 <setMidiLeds>
	
	SH100HW_SetPreviousLedState(LED_PWR_GRN);
    1220:	87 e0       	ldi	r24, 0x07	; 7
    1222:	5e d4       	rcall	.+2236   	; 0x1ae0 <SH100HW_SetPreviousLedState>
	SH100HW_SetPreviousLedState(LED_PWR_RED);
    1224:	88 e0       	ldi	r24, 0x08	; 8
    1226:	5c d4       	rcall	.+2232   	; 0x1ae0 <SH100HW_SetPreviousLedState>
    1228:	ff 91       	pop	r31
    122a:	ef 91       	pop	r30
    122c:	bf 91       	pop	r27
    122e:	af 91       	pop	r26
    1230:	9f 91       	pop	r25
    1232:	8f 91       	pop	r24
    1234:	7f 91       	pop	r23
    1236:	6f 91       	pop	r22
    1238:	5f 91       	pop	r21
    123a:	4f 91       	pop	r20
    123c:	3f 91       	pop	r19
    123e:	2f 91       	pop	r18
    1240:	0f 90       	pop	r0
    1242:	0f be       	out	0x3f, r0	; 63
    1244:	0f 90       	pop	r0
    1246:	1f 90       	pop	r1
    1248:	18 95       	reti

Disassembly of section .text.handleRealTimeStatus:

00001c52 <handleRealTimeStatus>:
	HADLE_SYS_EX
}state = RESET;

void handleRealTimeStatus(MIDI_Status_t status)
{
	UART_PushWord(status);
    1c52:	6c dc       	rcall	.-1832   	; 0x152c <UART_PushWord>
    1c54:	08 95       	ret

Disassembly of section .text.MIDI_ParserTask:

00000b22 <MIDI_ParserTask>:
};

uint8_t recievedWord;
void MIDI_ParserTask()
{
	switch(state)
 b22:	e0 91 ac 01 	lds	r30, 0x01AC	; 0x8001ac <state>
 b26:	8e 2f       	mov	r24, r30
 b28:	90 e0       	ldi	r25, 0x00	; 0
 b2a:	87 30       	cpi	r24, 0x07	; 7
 b2c:	91 05       	cpc	r25, r1
 b2e:	08 f0       	brcs	.+2      	; 0xb32 <MIDI_ParserTask+0x10>
 b30:	98 c0       	rjmp	.+304    	; 0xc62 <MIDI_ParserTask+0x140>
 b32:	fc 01       	movw	r30, r24
 b34:	e6 5e       	subi	r30, 0xE6	; 230
 b36:	ff 4f       	sbci	r31, 0xFF	; 255
 b38:	09 94       	ijmp
	{
		case RESET:
		{
			currentCommand.status = MIDI_COMM_UNDEFINED;
 b3a:	e8 e3       	ldi	r30, 0x38	; 56
 b3c:	f1 e0       	ldi	r31, 0x01	; 1
 b3e:	10 82       	st	Z, r1
			currentCommand.data1 = 0;
 b40:	12 82       	std	Z+2, r1	; 0x02
			currentCommand.data2 = 0;
 b42:	13 82       	std	Z+3, r1	; 0x03
			currentStatusType = MIDI_TYPE_UNDEFINED;
 b44:	10 92 3c 01 	sts	0x013C, r1	; 0x80013c <currentStatusType>
			isSecondDataWord = false;
 b48:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <isSecondDataWord>
			state = WAIT_WORD;
 b4c:	81 e0       	ldi	r24, 0x01	; 1
 b4e:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
			break;
 b52:	08 95       	ret
		}
		
		case WAIT_WORD:
		{
			if(UART_RxBufferNotEmpty())
 b54:	31 d8       	rcall	.-3998   	; 0xfffffbb8 <__eeprom_end+0xff7efbb8>
 b56:	88 23       	and	r24, r24
 b58:	09 f4       	brne	.+2      	; 0xb5c <MIDI_ParserTask+0x3a>
 b5a:	83 c0       	rjmp	.+262    	; 0xc62 <MIDI_ParserTask+0x140>
			{
				recievedWord = UART_PopWord();
 b5c:	50 d6       	rcall	.+3232   	; 0x17fe <UART_PopWord>
 b5e:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <recievedWord>
				if(MIDI_IsSysRealTime(recievedWord))
 b62:	38 d8       	rcall	.-3984   	; 0xfffffbd4 <__eeprom_end+0xff7efbd4>
 b64:	88 23       	and	r24, r24
 b66:	21 f0       	breq	.+8      	; 0xb70 <MIDI_ParserTask+0x4e>
				{ 
					handleRealTimeStatus((MIDI_Status_t)recievedWord);
 b68:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <recievedWord>
 b6c:	72 d8       	rcall	.-3868   	; 0xfffffc52 <__eeprom_end+0xff7efc52>
					return;
 b6e:	08 95       	ret
				}
				
				if(MIDI_IsStatusWord(recievedWord))
 b70:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <recievedWord>
 b74:	4b d8       	rcall	.-3946   	; 0xfffffc0c <__eeprom_end+0xff7efc0c>
 b76:	88 23       	and	r24, r24
 b78:	21 f0       	breq	.+8      	; 0xb82 <MIDI_ParserTask+0x60>
				{					
					state = DISPATCH_STATUS;
 b7a:	82 e0       	ldi	r24, 0x02	; 2
 b7c:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
 b80:	20 c0       	rjmp	.+64     	; 0xbc2 <MIDI_ParserTask+0xa0>
				}
				else
				{
					switch(currentStatusType)
 b82:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <currentStatusType>
 b86:	82 30       	cpi	r24, 0x02	; 2
 b88:	49 f0       	breq	.+18     	; 0xb9c <MIDI_ParserTask+0x7a>
 b8a:	18 f4       	brcc	.+6      	; 0xb92 <MIDI_ParserTask+0x70>
 b8c:	81 30       	cpi	r24, 0x01	; 1
 b8e:	51 f0       	breq	.+20     	; 0xba4 <MIDI_ParserTask+0x82>
 b90:	15 c0       	rjmp	.+42     	; 0xbbc <MIDI_ParserTask+0x9a>
 b92:	84 30       	cpi	r24, 0x04	; 4
 b94:	59 f0       	breq	.+22     	; 0xbac <MIDI_ParserTask+0x8a>
 b96:	85 30       	cpi	r24, 0x05	; 5
 b98:	69 f0       	breq	.+26     	; 0xbb4 <MIDI_ParserTask+0x92>
 b9a:	10 c0       	rjmp	.+32     	; 0xbbc <MIDI_ParserTask+0x9a>
					{
						case MIDI_TYPE_TWO_BYTE: state = REC_TWO_BYTE; break;
 b9c:	84 e0       	ldi	r24, 0x04	; 4
 b9e:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
 ba2:	0f c0       	rjmp	.+30     	; 0xbc2 <MIDI_ParserTask+0xa0>
						case MIDI_TYPE_ONE_BYTE: state = REC_ONE_BYTE; break;
 ba4:	83 e0       	ldi	r24, 0x03	; 3
 ba6:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
 baa:	0b c0       	rjmp	.+22     	; 0xbc2 <MIDI_ParserTask+0xa0>
						case MIDI_TYPE_START_SYS_EX: state = REC_SYS_EX; break;
 bac:	85 e0       	ldi	r24, 0x05	; 5
 bae:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
 bb2:	07 c0       	rjmp	.+14     	; 0xbc2 <MIDI_ParserTask+0xa0>
						case MIDI_TYPE_STOP_SYS_EX: state = HADLE_SYS_EX; break;
 bb4:	86 e0       	ldi	r24, 0x06	; 6
 bb6:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
 bba:	03 c0       	rjmp	.+6      	; 0xbc2 <MIDI_ParserTask+0xa0>
						default: state = WAIT_WORD;
 bbc:	81 e0       	ldi	r24, 0x01	; 1
 bbe:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
					}
				}
				
				if(retranslate)
 bc2:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <retranslate>
 bc6:	88 23       	and	r24, r24
 bc8:	09 f4       	brne	.+2      	; 0xbcc <MIDI_ParserTask+0xaa>
 bca:	4b c0       	rjmp	.+150    	; 0xc62 <MIDI_ParserTask+0x140>
				{
					UART_PushWord(recievedWord);
 bcc:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <recievedWord>
 bd0:	ad d4       	rcall	.+2394   	; 0x152c <UART_PushWord>
 bd2:	08 95       	ret
			break;
		}
		
		case DISPATCH_STATUS:
		{
			currentCommand.status = (MIDI_Status_t)((recievedWord & 0xF0) >> 4);
 bd4:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <recievedWord>
 bd8:	89 2f       	mov	r24, r25
 bda:	82 95       	swap	r24
 bdc:	8f 70       	andi	r24, 0x0F	; 15
 bde:	e8 e3       	ldi	r30, 0x38	; 56
 be0:	f1 e0       	ldi	r31, 0x01	; 1
 be2:	80 83       	st	Z, r24
			currentCommand.channel_type = recievedWord & 0x0F;
 be4:	9f 70       	andi	r25, 0x0F	; 15
 be6:	91 83       	std	Z+1, r25	; 0x01
			currentCommand.data1 = 0;
 be8:	12 82       	std	Z+2, r1	; 0x02
			currentCommand.data2 = 0;
 bea:	13 82       	std	Z+3, r1	; 0x03
			currentStatusType = MIDI_GetStatusType(currentCommand.status);
 bec:	8f d2       	rcall	.+1310   	; 0x110c <MIDI_GetStatusType>
 bee:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <currentStatusType>
			isSecondDataWord = false;
 bf2:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <isSecondDataWord>
			state = WAIT_WORD;
 bf6:	81 e0       	ldi	r24, 0x01	; 1
 bf8:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
			break;
 bfc:	08 95       	ret
		}				
		
		case REC_TWO_BYTE:
		{
			if(isSecondDataWord)
 bfe:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <isSecondDataWord>
 c02:	88 23       	and	r24, r24
 c04:	59 f0       	breq	.+22     	; 0xc1c <MIDI_ParserTask+0xfa>
			{
				currentCommand.data2 = recievedWord;
 c06:	e8 e3       	ldi	r30, 0x38	; 56
 c08:	f1 e0       	ldi	r31, 0x01	; 1
 c0a:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <recievedWord>
 c0e:	83 83       	std	Z+3, r24	; 0x03
				isSecondDataWord = false;			
 c10:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <isSecondDataWord>
				MIDICTRL_HandleCommand(&currentCommand);
 c14:	bf 01       	movw	r22, r30
 c16:	80 e8       	ldi	r24, 0x80	; 128
 c18:	ab dd       	rcall	.-1194   	; 0x770 <MIDICTRL_HandleCommand>
 c1a:	07 c0       	rjmp	.+14     	; 0xc2a <MIDI_ParserTask+0x108>
			}
			else
			{
				currentCommand.data1 = recievedWord;
 c1c:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <recievedWord>
 c20:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <currentCommand+0x2>
				isSecondDataWord = true;
 c24:	81 e0       	ldi	r24, 0x01	; 1
 c26:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <isSecondDataWord>
			}
			state = WAIT_WORD;
 c2a:	81 e0       	ldi	r24, 0x01	; 1
 c2c:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
			break;
 c30:	08 95       	ret
		}
		
		case REC_ONE_BYTE:
		{
			currentCommand.data1 = recievedWord;
 c32:	e8 e3       	ldi	r30, 0x38	; 56
 c34:	f1 e0       	ldi	r31, 0x01	; 1
 c36:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <recievedWord>
 c3a:	82 83       	std	Z+2, r24	; 0x02
			MIDICTRL_HandleCommand(&currentCommand);
 c3c:	bf 01       	movw	r22, r30
 c3e:	80 e8       	ldi	r24, 0x80	; 128
 c40:	97 dd       	rcall	.-1234   	; 0x770 <MIDICTRL_HandleCommand>
			state = WAIT_WORD;
 c42:	81 e0       	ldi	r24, 0x01	; 1
 c44:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
			break;
 c48:	08 95       	ret
		}
		
		case REC_SYS_EX:
		{
			state = WAIT_WORD;
 c4a:	81 e0       	ldi	r24, 0x01	; 1
 c4c:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
			break;
 c50:	08 95       	ret
		}
		
		case HADLE_SYS_EX:
		{
			currentCommand.status = MIDI_COMM_UNDEFINED;
 c52:	e8 e3       	ldi	r30, 0x38	; 56
 c54:	f1 e0       	ldi	r31, 0x01	; 1
 c56:	10 82       	st	Z, r1
			currentCommand.data1 = 0;
 c58:	12 82       	std	Z+2, r1	; 0x02
			currentCommand.data2 = 0;
 c5a:	13 82       	std	Z+3, r1	; 0x03
			state = WAIT_WORD;
 c5c:	81 e0       	ldi	r24, 0x01	; 1
 c5e:	80 93 ac 01 	sts	0x01AC, r24	; 0x8001ac <state>
 c62:	08 95       	ret

Disassembly of section .text.MIDI_SetRetranslateState:

00001c34 <MIDI_SetRetranslateState>:
	}
}

void MIDI_SetRetranslateState(bool enabled)
{
	retranslate = enabled;
    1c34:	80 93 ad 01 	sts	0x01AD, r24	; 0x8001ad <retranslate>
    1c38:	08 95       	ret

Disassembly of section .text.MIDI_SendCommand:

00000fa4 <MIDI_SendCommand>:
}

void MIDI_SendCommand(MIDI_Command_t command, uint8_t channel)
{
     fa4:	0f 93       	push	r16
     fa6:	1f 93       	push	r17
     fa8:	cf 93       	push	r28
     faa:	df 93       	push	r29
     fac:	c6 2f       	mov	r28, r22
     fae:	18 2f       	mov	r17, r24
     fb0:	09 2f       	mov	r16, r25
     fb2:	d4 2f       	mov	r29, r20
	switch(MIDI_GetStatusType(command.status))
     fb4:	86 2f       	mov	r24, r22
     fb6:	aa d0       	rcall	.+340    	; 0x110c <MIDI_GetStatusType>
     fb8:	83 30       	cpi	r24, 0x03	; 3
     fba:	59 f0       	breq	.+22     	; 0xfd2 <MIDI_SendCommand+0x2e>
     fbc:	28 f4       	brcc	.+10     	; 0xfc8 <MIDI_SendCommand+0x24>
     fbe:	81 30       	cpi	r24, 0x01	; 1
     fc0:	59 f0       	breq	.+22     	; 0xfd8 <MIDI_SendCommand+0x34>
     fc2:	82 30       	cpi	r24, 0x02	; 2
     fc4:	a1 f0       	breq	.+40     	; 0xfee <MIDI_SendCommand+0x4a>
     fc6:	25 c0       	rjmp	.+74     	; 0x1012 <MIDI_SendCommand+0x6e>
     fc8:	84 30       	cpi	r24, 0x04	; 4
     fca:	f1 f0       	breq	.+60     	; 0x1008 <MIDI_SendCommand+0x64>
     fcc:	85 30       	cpi	r24, 0x05	; 5
     fce:	f9 f0       	breq	.+62     	; 0x100e <MIDI_SendCommand+0x6a>
     fd0:	20 c0       	rjmp	.+64     	; 0x1012 <MIDI_SendCommand+0x6e>
	{
		case MIDI_TYPE_REAL_TIME:
		{
			// second nymble!
			UART_PushWord(command.status);
     fd2:	8c 2f       	mov	r24, r28
     fd4:	ab d2       	rcall	.+1366   	; 0x152c <UART_PushWord>
			break;
     fd6:	1d c0       	rjmp	.+58     	; 0x1012 <MIDI_SendCommand+0x6e>
		}
		case MIDI_TYPE_ONE_BYTE:
		{
			UART_PushWord((command.status << 4) | (channel & 0xF));
     fd8:	80 e1       	ldi	r24, 0x10	; 16
     fda:	c8 9f       	mul	r28, r24
     fdc:	b0 01       	movw	r22, r0
     fde:	11 24       	eor	r1, r1
     fe0:	8d 2f       	mov	r24, r29
     fe2:	8f 70       	andi	r24, 0x0F	; 15
     fe4:	86 2b       	or	r24, r22
     fe6:	a2 d2       	rcall	.+1348   	; 0x152c <UART_PushWord>
			UART_PushWord(command.data1);
     fe8:	81 2f       	mov	r24, r17
     fea:	a0 d2       	rcall	.+1344   	; 0x152c <UART_PushWord>
			break;
     fec:	12 c0       	rjmp	.+36     	; 0x1012 <MIDI_SendCommand+0x6e>
		}
		case MIDI_TYPE_TWO_BYTE:
		{
			UART_PushWord((command.status << 4) | (channel & 0xF));
     fee:	80 e1       	ldi	r24, 0x10	; 16
     ff0:	c8 9f       	mul	r28, r24
     ff2:	b0 01       	movw	r22, r0
     ff4:	11 24       	eor	r1, r1
     ff6:	8d 2f       	mov	r24, r29
     ff8:	8f 70       	andi	r24, 0x0F	; 15
     ffa:	86 2b       	or	r24, r22
     ffc:	97 d2       	rcall	.+1326   	; 0x152c <UART_PushWord>
			UART_PushWord(command.data1);
     ffe:	81 2f       	mov	r24, r17
    1000:	95 d2       	rcall	.+1322   	; 0x152c <UART_PushWord>
			UART_PushWord(command.data2);
    1002:	80 2f       	mov	r24, r16
    1004:	93 d2       	rcall	.+1318   	; 0x152c <UART_PushWord>
			break;
    1006:	05 c0       	rjmp	.+10     	; 0x1012 <MIDI_SendCommand+0x6e>
		}
		case MIDI_TYPE_START_SYS_EX:
		{
			// second nymble!
			UART_PushWord(command.status);
    1008:	8c 2f       	mov	r24, r28
    100a:	90 d2       	rcall	.+1312   	; 0x152c <UART_PushWord>
			break;
    100c:	02 c0       	rjmp	.+4      	; 0x1012 <MIDI_SendCommand+0x6e>
		}
		case MIDI_TYPE_STOP_SYS_EX:
		{
			// second nymble!!!
			UART_PushWord(command.status);
    100e:	8c 2f       	mov	r24, r28
    1010:	8d d2       	rcall	.+1306   	; 0x152c <UART_PushWord>
			break;
		}
		case MIDI_TYPE_UNDEFINED: break;
	}
    1012:	df 91       	pop	r29
    1014:	cf 91       	pop	r28
    1016:	1f 91       	pop	r17
    1018:	0f 91       	pop	r16
    101a:	08 95       	ret

Disassembly of section .text.SH100CTRL_GetAmpState:

000015b4 <SH100CTRL_GetAmpState>:
	SH100CTRL_SetLoop(ampState.loopOn[ampState.channelNum]);
	SH100CTRL_SetAB(ampState.swAB);
}

SH100_State_t SH100CTRL_GetAmpState()
{
    15b4:	cf 93       	push	r28
    15b6:	df 93       	push	r29
    15b8:	00 d0       	rcall	.+0      	; 0x15ba <SH100CTRL_GetAmpState+0x6>
    15ba:	00 d0       	rcall	.+0      	; 0x15bc <SH100CTRL_GetAmpState+0x8>
    15bc:	00 d0       	rcall	.+0      	; 0x15be <SH100CTRL_GetAmpState+0xa>
    15be:	cd b7       	in	r28, 0x3d	; 61
    15c0:	de b7       	in	r29, 0x3e	; 62
	return ampState;
    15c2:	86 e0       	ldi	r24, 0x06	; 6
    15c4:	ed e3       	ldi	r30, 0x3D	; 61
    15c6:	f1 e0       	ldi	r31, 0x01	; 1
    15c8:	de 01       	movw	r26, r28
    15ca:	11 96       	adiw	r26, 0x01	; 1
    15cc:	01 90       	ld	r0, Z+
    15ce:	0d 92       	st	X+, r0
    15d0:	8a 95       	dec	r24
    15d2:	e1 f7       	brne	.-8      	; 0x15cc <SH100CTRL_GetAmpState+0x18>
    15d4:	29 81       	ldd	r18, Y+1	; 0x01
    15d6:	3a 81       	ldd	r19, Y+2	; 0x02
    15d8:	4b 81       	ldd	r20, Y+3	; 0x03
    15da:	5c 81       	ldd	r21, Y+4	; 0x04
    15dc:	6d 81       	ldd	r22, Y+5	; 0x05
    15de:	7e 81       	ldd	r23, Y+6	; 0x06
}
    15e0:	80 e0       	ldi	r24, 0x00	; 0
    15e2:	90 e0       	ldi	r25, 0x00	; 0
    15e4:	26 96       	adiw	r28, 0x06	; 6
    15e6:	0f b6       	in	r0, 0x3f	; 63
    15e8:	f8 94       	cli
    15ea:	de bf       	out	0x3e, r29	; 62
    15ec:	0f be       	out	0x3f, r0	; 63
    15ee:	cd bf       	out	0x3d, r28	; 61
    15f0:	df 91       	pop	r29
    15f2:	cf 91       	pop	r28
    15f4:	08 95       	ret

Disassembly of section .text.setChannelLeds:

000019da <setChannelLeds>:

void setChannelLeds()
{
	SH100HW_SetNewLedState(LED_CH1, LED_OFF);
    19da:	60 e0       	ldi	r22, 0x00	; 0
    19dc:	80 e0       	ldi	r24, 0x00	; 0
    19de:	89 df       	rcall	.-238    	; 0x18f2 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_CH2, LED_OFF);
    19e0:	60 e0       	ldi	r22, 0x00	; 0
    19e2:	81 e0       	ldi	r24, 0x01	; 1
    19e4:	86 df       	rcall	.-244    	; 0x18f2 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_CH3, LED_OFF);
    19e6:	60 e0       	ldi	r22, 0x00	; 0
    19e8:	82 e0       	ldi	r24, 0x02	; 2
    19ea:	83 df       	rcall	.-250    	; 0x18f2 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_CH4, LED_OFF);
    19ec:	60 e0       	ldi	r22, 0x00	; 0
    19ee:	83 e0       	ldi	r24, 0x03	; 3
    19f0:	80 df       	rcall	.-256    	; 0x18f2 <SH100HW_SetNewLedState>
	
	SH100HW_SetNewLedState(ampState.channelNum, LED_ON);
    19f2:	61 e0       	ldi	r22, 0x01	; 1
    19f4:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <ampState>
    19f8:	7c df       	rcall	.-264    	; 0x18f2 <SH100HW_SetNewLedState>
    19fa:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetAmpLeds:

000018c4 <SH100CTRL_SetAmpLeds>:
}

void SH100CTRL_SetAmpLeds()
{
    18c4:	cf 93       	push	r28
    18c6:	df 93       	push	r29
	setChannelLeds();
    18c8:	88 d0       	rcall	.+272    	; 0x19da <setChannelLeds>
	SH100HW_SetNewLedState(LED_LOOP, ampState.loopOn[ampState.channelNum]);
    18ca:	cd e3       	ldi	r28, 0x3D	; 61
    18cc:	d1 e0       	ldi	r29, 0x01	; 1
    18ce:	e8 81       	ld	r30, Y
    18d0:	f0 e0       	ldi	r31, 0x00	; 0
    18d2:	e3 5c       	subi	r30, 0xC3	; 195
    18d4:	fe 4f       	sbci	r31, 0xFE	; 254
    18d6:	61 81       	ldd	r22, Z+1	; 0x01
    18d8:	84 e0       	ldi	r24, 0x04	; 4
    18da:	0b d0       	rcall	.+22     	; 0x18f2 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_A, !ampState.swAB);
    18dc:	6d 81       	ldd	r22, Y+5	; 0x05
    18de:	81 e0       	ldi	r24, 0x01	; 1
    18e0:	68 27       	eor	r22, r24
    18e2:	85 e0       	ldi	r24, 0x05	; 5
    18e4:	06 d0       	rcall	.+12     	; 0x18f2 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_B, ampState.swAB);
    18e6:	6d 81       	ldd	r22, Y+5	; 0x05
    18e8:	86 e0       	ldi	r24, 0x06	; 6
    18ea:	03 d0       	rcall	.+6      	; 0x18f2 <SH100HW_SetNewLedState>
}
    18ec:	df 91       	pop	r29
    18ee:	cf 91       	pop	r28
    18f0:	08 95       	ret

Disassembly of section .text.SH100CTRL_StoreAmpState:

00001a5a <SH100CTRL_StoreAmpState>:

void SH100CTRL_StoreAmpState()
{
	eeprom_write_word(0x00, MEMORY_MAGIC_WORD);
    1a5a:	6b ea       	ldi	r22, 0xAB	; 171
    1a5c:	7c ea       	ldi	r23, 0xAC	; 172
    1a5e:	80 e0       	ldi	r24, 0x00	; 0
    1a60:	90 e0       	ldi	r25, 0x00	; 0
    1a62:	f4 d0       	rcall	.+488    	; 0x1c4c <eeprom_write_word>
	eeprom_write_block(&ampState, (void*)MEMORY_AMP_STATE_OFFSET, sizeof(SH100_State_t));
    1a64:	6d e3       	ldi	r22, 0x3D	; 61
    1a66:	71 e0       	ldi	r23, 0x01	; 1
    1a68:	80 e8       	ldi	r24, 0x80	; 128
    1a6a:	26 e0       	ldi	r18, 0x06	; 6
    1a6c:	30 e0       	ldi	r19, 0x00	; 0
    1a6e:	48 e0       	ldi	r20, 0x08	; 8
    1a70:	50 e0       	ldi	r21, 0x00	; 0
    1a72:	f8 de       	rcall	.-528    	; 0x1864 <eeprom_write_block>
    1a74:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetLoop:

00001948 <SH100CTRL_SetLoop>:
	SH100CTRL_SetLoop(!ampState.loopOn[ampState.channelNum]);
	MIDICTRL_SendLoopEnComm(!ampState.loopOn[ampState.channelNum]);
}

void SH100CTRL_SetLoop(bool en)
{
    1948:	cf 93       	push	r28
    194a:	df 93       	push	r29
	ampState.loopOn[ampState.channelNum] = en;
    194c:	cd e3       	ldi	r28, 0x3D	; 61
    194e:	d1 e0       	ldi	r29, 0x01	; 1
    1950:	e8 81       	ld	r30, Y
    1952:	f0 e0       	ldi	r31, 0x00	; 0
    1954:	e3 5c       	subi	r30, 0xC3	; 195
    1956:	fe 4f       	sbci	r31, 0xFE	; 254
    1958:	81 83       	std	Z+1, r24	; 0x01
	SH100HW_LoopEn(ampState.loopOn[ampState.channelNum]);
    195a:	b6 d0       	rcall	.+364    	; 0x1ac8 <SH100HW_LoopEn>
	SH100HW_SetNewLedState(LED_LOOP, ampState.loopOn[ampState.channelNum]);
    195c:	e8 81       	ld	r30, Y
    195e:	f0 e0       	ldi	r31, 0x00	; 0
    1960:	e3 5c       	subi	r30, 0xC3	; 195
    1962:	fe 4f       	sbci	r31, 0xFE	; 254
    1964:	61 81       	ldd	r22, Z+1	; 0x01
    1966:	84 e0       	ldi	r24, 0x04	; 4
    1968:	c4 df       	rcall	.-120    	; 0x18f2 <SH100HW_SetNewLedState>
}
    196a:	df 91       	pop	r29
    196c:	cf 91       	pop	r28
    196e:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetChannel:

00001a1e <SH100CTRL_SetChannel>:
		SH100CTRL_SwLoop();
	}
}

void SH100CTRL_SetChannel(uint8_t chNum)
{
    1a1e:	cf 93       	push	r28
    1a20:	df 93       	push	r29
	ampState.channelNum = chNum;
    1a22:	cd e3       	ldi	r28, 0x3D	; 61
    1a24:	d1 e0       	ldi	r29, 0x01	; 1
    1a26:	88 83       	st	Y, r24
	
	SH100HW_SetCh(chNum);
    1a28:	c5 dc       	rcall	.-1654   	; 0x13b4 <SH100HW_SetCh>
	SH100CTRL_SetLoop(ampState.loopOn[ampState.channelNum]);
    1a2a:	e8 81       	ld	r30, Y
    1a2c:	f0 e0       	ldi	r31, 0x00	; 0
    1a2e:	e3 5c       	subi	r30, 0xC3	; 195
    1a30:	fe 4f       	sbci	r31, 0xFE	; 254
    1a32:	81 81       	ldd	r24, Z+1	; 0x01
    1a34:	89 df       	rcall	.-238    	; 0x1948 <SH100CTRL_SetLoop>
	setChannelLeds();
    1a36:	d1 df       	rcall	.-94     	; 0x19da <setChannelLeds>
}
    1a38:	df 91       	pop	r29
    1a3a:	cf 91       	pop	r28
    1a3c:	08 95       	ret

Disassembly of section .text.SH100CTRL_FsSetChannel:

00001b3e <SH100CTRL_FsSetChannel>:
	eeprom_write_word(0x00, MEMORY_MAGIC_WORD);
	eeprom_write_block(&ampState, (void*)MEMORY_AMP_STATE_OFFSET, sizeof(SH100_State_t));
}

void SH100CTRL_FsSetChannel(uint8_t chNum)
{
    1b3e:	cf 93       	push	r28
	if(ampState.channelNum != chNum)
    1b40:	90 91 3d 01 	lds	r25, 0x013D	; 0x80013d <ampState>
    1b44:	98 17       	cp	r25, r24
    1b46:	21 f0       	breq	.+8      	; 0x1b50 <SH100CTRL_FsSetChannel+0x12>
    1b48:	c8 2f       	mov	r28, r24
	{
		SH100CTRL_SetChannel(chNum);
    1b4a:	69 df       	rcall	.-302    	; 0x1a1e <SH100CTRL_SetChannel>
		MIDICTRL_SendSwChComm(chNum);
    1b4c:	8c 2f       	mov	r24, r28
    1b4e:	16 db       	rcall	.-2516   	; 0x117c <MIDICTRL_SendSwChComm>
	}
}
    1b50:	cf 91       	pop	r28
    1b52:	08 95       	ret

Disassembly of section .text.SH100CTRL_SwLoop:

000017ca <SH100CTRL_SwLoop>:
	SH100CTRL_SetLoop(ampState.loopOn[ampState.channelNum]);
	setChannelLeds();
}

void SH100CTRL_SwLoop()
{
    17ca:	0f 93       	push	r16
    17cc:	1f 93       	push	r17
    17ce:	cf 93       	push	r28
	SH100CTRL_SetLoop(!ampState.loopOn[ampState.channelNum]);
    17d0:	0d e3       	ldi	r16, 0x3D	; 61
    17d2:	11 e0       	ldi	r17, 0x01	; 1
    17d4:	d8 01       	movw	r26, r16
    17d6:	ec 91       	ld	r30, X
    17d8:	f0 e0       	ldi	r31, 0x00	; 0
    17da:	e3 5c       	subi	r30, 0xC3	; 195
    17dc:	fe 4f       	sbci	r31, 0xFE	; 254
    17de:	81 81       	ldd	r24, Z+1	; 0x01
    17e0:	c1 e0       	ldi	r28, 0x01	; 1
    17e2:	8c 27       	eor	r24, r28
    17e4:	b1 d0       	rcall	.+354    	; 0x1948 <SH100CTRL_SetLoop>
	MIDICTRL_SendLoopEnComm(!ampState.loopOn[ampState.channelNum]);
    17e6:	d8 01       	movw	r26, r16
    17e8:	ec 91       	ld	r30, X
    17ea:	f0 e0       	ldi	r31, 0x00	; 0
    17ec:	e3 5c       	subi	r30, 0xC3	; 195
    17ee:	fe 4f       	sbci	r31, 0xFE	; 254
    17f0:	81 81       	ldd	r24, Z+1	; 0x01
    17f2:	8c 27       	eor	r24, r28
    17f4:	b6 df       	rcall	.-148    	; 0x1762 <MIDICTRL_SendLoopEnComm>
}
    17f6:	cf 91       	pop	r28
    17f8:	1f 91       	pop	r17
    17fa:	0f 91       	pop	r16
    17fc:	08 95       	ret

Disassembly of section .text.SH100CTRL_BtnSetChannel:

00001a76 <SH100CTRL_BtnSetChannel>:
		MIDICTRL_SendSwChComm(chNum);
	}
}

void SH100CTRL_BtnSetChannel(uint8_t chNum)
{
    1a76:	cf 93       	push	r28
    1a78:	c8 2f       	mov	r28, r24
	if(ampState.channelNum != chNum)
    1a7a:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <ampState>
    1a7e:	8c 17       	cp	r24, r28
    1a80:	29 f0       	breq	.+10     	; 0x1a8c <SH100CTRL_BtnSetChannel+0x16>
	{
		SH100CTRL_SetChannel(chNum);
    1a82:	8c 2f       	mov	r24, r28
    1a84:	cc df       	rcall	.-104    	; 0x1a1e <SH100CTRL_SetChannel>
		MIDICTRL_SendSwChComm(chNum);
    1a86:	8c 2f       	mov	r24, r28
    1a88:	79 db       	rcall	.-2318   	; 0x117c <MIDICTRL_SendSwChComm>
    1a8a:	01 c0       	rjmp	.+2      	; 0x1a8e <SH100CTRL_BtnSetChannel+0x18>
	}
	else
	{
		SH100CTRL_SwLoop();
    1a8c:	9e de       	rcall	.-708    	; 0x17ca <SH100CTRL_SwLoop>
	}
}
    1a8e:	cf 91       	pop	r28
    1a90:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetAB:

000019fc <SH100CTRL_SetAB>:
	SH100CTRL_SetAB(!ampState.swAB);
	MIDICTRL_SendSwABComm(!ampState.swAB);
}

void SH100CTRL_SetAB(bool isB)
{
    19fc:	cf 93       	push	r28
    19fe:	df 93       	push	r29
	ampState.swAB = isB;
    1a00:	cd e3       	ldi	r28, 0x3D	; 61
    1a02:	d1 e0       	ldi	r29, 0x01	; 1
    1a04:	8d 83       	std	Y+5, r24	; 0x05
	SH100HW_SetAB(ampState.swAB);
    1a06:	1c d1       	rcall	.+568    	; 0x1c40 <SH100HW_SetAB>
	SH100HW_SetNewLedState(LED_A, !ampState.swAB);
    1a08:	6d 81       	ldd	r22, Y+5	; 0x05
    1a0a:	81 e0       	ldi	r24, 0x01	; 1
    1a0c:	68 27       	eor	r22, r24
    1a0e:	85 e0       	ldi	r24, 0x05	; 5
    1a10:	70 df       	rcall	.-288    	; 0x18f2 <SH100HW_SetNewLedState>
	SH100HW_SetNewLedState(LED_B, ampState.swAB);
    1a12:	6d 81       	ldd	r22, Y+5	; 0x05
    1a14:	86 e0       	ldi	r24, 0x06	; 6
    1a16:	6d df       	rcall	.-294    	; 0x18f2 <SH100HW_SetNewLedState>
}
    1a18:	df 91       	pop	r29
    1a1a:	cf 91       	pop	r28
    1a1c:	08 95       	ret

Disassembly of section .text.SH100CTRL_SetAmpState:

00001832 <SH100CTRL_SetAmpState>:
	}
	SH100CTRL_SetAmpState(&ampState);
}

void SH100CTRL_SetAmpState(const SH100_State_t* state)
{
    1832:	cf 93       	push	r28
    1834:	df 93       	push	r29
    1836:	98 2f       	mov	r25, r24
	ampState = *state;
    1838:	86 e0       	ldi	r24, 0x06	; 6
    183a:	e6 2f       	mov	r30, r22
    183c:	f7 2f       	mov	r31, r23
    183e:	ad e3       	ldi	r26, 0x3D	; 61
    1840:	b1 e0       	ldi	r27, 0x01	; 1
    1842:	79 2f       	mov	r23, r25
    1844:	34 d1       	rcall	.+616    	; 0x1aae <__movmemx_qi>
	
	SH100CTRL_SetChannel(ampState.channelNum);
    1846:	cd e3       	ldi	r28, 0x3D	; 61
    1848:	d1 e0       	ldi	r29, 0x01	; 1
    184a:	88 81       	ld	r24, Y
    184c:	e8 d0       	rcall	.+464    	; 0x1a1e <SH100CTRL_SetChannel>
	SH100CTRL_SetLoop(ampState.loopOn[ampState.channelNum]);
    184e:	e8 81       	ld	r30, Y
    1850:	f0 e0       	ldi	r31, 0x00	; 0
    1852:	e3 5c       	subi	r30, 0xC3	; 195
    1854:	fe 4f       	sbci	r31, 0xFE	; 254
    1856:	81 81       	ldd	r24, Z+1	; 0x01
    1858:	77 d0       	rcall	.+238    	; 0x1948 <SH100CTRL_SetLoop>
	SH100CTRL_SetAB(ampState.swAB);
    185a:	8d 81       	ldd	r24, Y+5	; 0x05
    185c:	cf d0       	rcall	.+414    	; 0x19fc <SH100CTRL_SetAB>
}
    185e:	df 91       	pop	r29
    1860:	cf 91       	pop	r28
    1862:	08 95       	ret

Disassembly of section .text.SH100CTRL_Init:

0000101c <SH100CTRL_Init>:
SH100_State_t ampState;

void setChannelLeds();

void SH100CTRL_Init()
{
    101c:	cf 93       	push	r28
    101e:	df 93       	push	r29
    1020:	00 d0       	rcall	.+0      	; 0x1022 <SH100CTRL_Init+0x6>
    1022:	00 d0       	rcall	.+0      	; 0x1024 <SH100CTRL_Init+0x8>
    1024:	00 d0       	rcall	.+0      	; 0x1026 <SH100CTRL_Init+0xa>
    1026:	cd b7       	in	r28, 0x3d	; 61
    1028:	de b7       	in	r29, 0x3e	; 62
	uint16_t readedMagicWord = eeprom_read_word(0x00);
    102a:	60 e0       	ldi	r22, 0x00	; 0
    102c:	70 e0       	ldi	r23, 0x00	; 0
    102e:	80 e0       	ldi	r24, 0x00	; 0
    1030:	dd d5       	rcall	.+3002   	; 0x1bec <eeprom_read_word>
	
	if(readedMagicWord == MEMORY_MAGIC_WORD)
    1032:	8b 3a       	cpi	r24, 0xAB	; 171
    1034:	9c 4a       	sbci	r25, 0xAC	; 172
    1036:	91 f4       	brne	.+36     	; 0x105c <SH100CTRL_Init+0x40>
	{
		uint8_t readedData[sizeof(SH100_State_t)];
		eeprom_read_block(&readedData, (uint16_t*)MEMORY_AMP_STATE_OFFSET, sizeof(SH100_State_t));
    1038:	48 e0       	ldi	r20, 0x08	; 8
    103a:	50 e0       	ldi	r21, 0x00	; 0
    103c:	60 e8       	ldi	r22, 0x80	; 128
    103e:	26 e0       	ldi	r18, 0x06	; 6
    1040:	30 e0       	ldi	r19, 0x00	; 0
    1042:	ce 01       	movw	r24, r28
    1044:	01 96       	adiw	r24, 0x01	; 1
    1046:	a6 d4       	rcall	.+2380   	; 0x1994 <eeprom_read_block>
		SH100_State_t* ampState_ptr = (SH100_State_t*)readedData;
		ampState = *ampState_ptr;
    1048:	86 e0       	ldi	r24, 0x06	; 6
    104a:	fe 01       	movw	r30, r28
    104c:	31 96       	adiw	r30, 0x01	; 1
    104e:	ad e3       	ldi	r26, 0x3D	; 61
    1050:	b1 e0       	ldi	r27, 0x01	; 1
    1052:	01 90       	ld	r0, Z+
    1054:	0d 92       	st	X+, r0
    1056:	8a 95       	dec	r24
    1058:	e1 f7       	brne	.-8      	; 0x1052 <SH100CTRL_Init+0x36>
    105a:	0f c0       	rjmp	.+30     	; 0x107a <SH100CTRL_Init+0x5e>
	}
	else
	{
		ampState.channelNum = 0;
    105c:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <ampState>
		for(int i=0; i<4; i++)
    1060:	80 e0       	ldi	r24, 0x00	; 0
    1062:	90 e0       	ldi	r25, 0x00	; 0
    1064:	05 c0       	rjmp	.+10     	; 0x1070 <SH100CTRL_Init+0x54>
		{
			ampState.loopOn[i] = false;
    1066:	fc 01       	movw	r30, r24
    1068:	e3 5c       	subi	r30, 0xC3	; 195
    106a:	fe 4f       	sbci	r31, 0xFE	; 254
    106c:	11 82       	std	Z+1, r1	; 0x01
		ampState = *ampState_ptr;
	}
	else
	{
		ampState.channelNum = 0;
		for(int i=0; i<4; i++)
    106e:	01 96       	adiw	r24, 0x01	; 1
    1070:	84 30       	cpi	r24, 0x04	; 4
    1072:	91 05       	cpc	r25, r1
    1074:	c4 f3       	brlt	.-16     	; 0x1066 <SH100CTRL_Init+0x4a>
		{
			ampState.loopOn[i] = false;
		}		
		ampState.swAB = false;		
    1076:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <ampState+0x5>
	}
	SH100CTRL_SetAmpState(&ampState);
    107a:	6d e3       	ldi	r22, 0x3D	; 61
    107c:	71 e0       	ldi	r23, 0x01	; 1
    107e:	80 e8       	ldi	r24, 0x80	; 128
    1080:	d8 d3       	rcall	.+1968   	; 0x1832 <SH100CTRL_SetAmpState>
}
    1082:	26 96       	adiw	r28, 0x06	; 6
    1084:	0f b6       	in	r0, 0x3f	; 63
    1086:	f8 94       	cli
    1088:	de bf       	out	0x3e, r29	; 62
    108a:	0f be       	out	0x3f, r0	; 63
    108c:	cd bf       	out	0x3d, r28	; 61
    108e:	df 91       	pop	r29
    1090:	cf 91       	pop	r28
    1092:	08 95       	ret

Disassembly of section .text.SH100CTRL_SwAB:

00001970 <SH100CTRL_SwAB>:
	SH100HW_LoopEn(ampState.loopOn[ampState.channelNum]);
	SH100HW_SetNewLedState(LED_LOOP, ampState.loopOn[ampState.channelNum]);
}

void SH100CTRL_SwAB()
{
    1970:	0f 93       	push	r16
    1972:	1f 93       	push	r17
    1974:	cf 93       	push	r28
	SH100CTRL_SetAB(!ampState.swAB);
    1976:	0d e3       	ldi	r16, 0x3D	; 61
    1978:	11 e0       	ldi	r17, 0x01	; 1
    197a:	f8 01       	movw	r30, r16
    197c:	85 81       	ldd	r24, Z+5	; 0x05
    197e:	c1 e0       	ldi	r28, 0x01	; 1
    1980:	8c 27       	eor	r24, r28
    1982:	3c d0       	rcall	.+120    	; 0x19fc <SH100CTRL_SetAB>
	MIDICTRL_SendSwABComm(!ampState.swAB);
    1984:	f8 01       	movw	r30, r16
    1986:	85 81       	ldd	r24, Z+5	; 0x05
    1988:	8c 27       	eor	r24, r28
    198a:	05 df       	rcall	.-502    	; 0x1796 <MIDICTRL_SendSwABComm>
}
    198c:	cf 91       	pop	r28
    198e:	1f 91       	pop	r17
    1990:	0f 91       	pop	r16
    1992:	08 95       	ret

Disassembly of section .text.SH100CTRL_MuteAmp:

00001c3a <SH100CTRL_MuteAmp>:
	SH100HW_SetNewLedState(LED_B, ampState.swAB);
}

void SH100CTRL_MuteAmp()
{
	SH100HW_SetPAState(OUTPUT_MUTE);
    1c3a:	80 e0       	ldi	r24, 0x00	; 0
    1c3c:	3c dd       	rcall	.-1416   	; 0x16b6 <SH100HW_SetPAState>
    1c3e:	08 95       	ret

Disassembly of section .text.SH100CTRL_UnmuteAmp:

00001be0 <SH100CTRL_UnmuteAmp>:
}

void SH100CTRL_UnmuteAmp()
{
	if(SH100HW_GetOutputJacks() != OUT_NONE)
    1be0:	8b df       	rcall	.-234    	; 0x1af8 <SH100HW_GetOutputJacks>
    1be2:	88 23       	and	r24, r24
    1be4:	11 f0       	breq	.+4      	; 0x1bea <SH100CTRL_UnmuteAmp+0xa>
	{
		SH100HW_SetPAState(OUTPUT_ENABLED);	
    1be6:	81 e0       	ldi	r24, 0x01	; 1
    1be8:	66 dd       	rcall	.-1332   	; 0x16b6 <SH100HW_SetPAState>
    1bea:	08 95       	ret

Disassembly of section .text.SH100CTRL_CheckOutputJacks:

00001094 <SH100CTRL_CheckOutputJacks>:
	}		
}

void SH100CTRL_CheckOutputJacks()
{
	if(SH100HW_GetPAFailure()) return;
    1094:	b1 d5       	rcall	.+2914   	; 0x1bf8 <SH100HW_GetPAFailure>
    1096:	81 11       	cpse	r24, r1
    1098:	38 c0       	rjmp	.+112    	; 0x110a <SH100CTRL_CheckOutputJacks+0x76>
	
	SH100HW_OutputJacks_t outJacksState = SH100HW_GetOutputJacks();
    109a:	2e d5       	rcall	.+2652   	; 0x1af8 <SH100HW_GetOutputJacks>
	
	switch(outJacksState)
    109c:	81 30       	cpi	r24, 0x01	; 1
    109e:	89 f0       	breq	.+34     	; 0x10c2 <SH100CTRL_CheckOutputJacks+0x2e>
    10a0:	28 f0       	brcs	.+10     	; 0x10ac <SH100CTRL_CheckOutputJacks+0x18>
    10a2:	82 30       	cpi	r24, 0x02	; 2
    10a4:	d9 f0       	breq	.+54     	; 0x10dc <SH100CTRL_CheckOutputJacks+0x48>
    10a6:	83 30       	cpi	r24, 0x03	; 3
    10a8:	31 f1       	breq	.+76     	; 0x10f6 <SH100CTRL_CheckOutputJacks+0x62>
    10aa:	08 95       	ret
	{
		case OUT_NONE:
		{
			if(MIDICTRL_MidiMode() == RUNNING)
    10ac:	b7 d5       	rcall	.+2926   	; 0x1c1c <MIDICTRL_MidiMode>
    10ae:	81 11       	cpse	r24, r1
    10b0:	06 c0       	rjmp	.+12     	; 0x10be <SH100CTRL_CheckOutputJacks+0x2a>
			{
				SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
    10b2:	60 e0       	ldi	r22, 0x00	; 0
    10b4:	87 e0       	ldi	r24, 0x07	; 7
    10b6:	1d d4       	rcall	.+2106   	; 0x18f2 <SH100HW_SetNewLedState>
				SH100HW_SetNewLedState(LED_PWR_RED, LED_ON);
    10b8:	61 e0       	ldi	r22, 0x01	; 1
    10ba:	88 e0       	ldi	r24, 0x08	; 8
    10bc:	1a d4       	rcall	.+2100   	; 0x18f2 <SH100HW_SetNewLedState>
			}
			SH100CTRL_MuteAmp();
    10be:	bd d5       	rcall	.+2938   	; 0x1c3a <SH100CTRL_MuteAmp>
			break;
    10c0:	08 95       	ret
		}
		case OUT_16OHM:
		{
			if(MIDICTRL_MidiMode() == RUNNING)
    10c2:	ac d5       	rcall	.+2904   	; 0x1c1c <MIDICTRL_MidiMode>
    10c4:	81 11       	cpse	r24, r1
    10c6:	21 c0       	rjmp	.+66     	; 0x110a <SH100CTRL_CheckOutputJacks+0x76>
			{
				SH100CTRL_UnmuteAmp();
    10c8:	8b d5       	rcall	.+2838   	; 0x1be0 <SH100CTRL_UnmuteAmp>
				SH100HW_SetOutputMode(OUTPUT_16OHM);
    10ca:	81 e0       	ldi	r24, 0x01	; 1
    10cc:	bc d5       	rcall	.+2936   	; 0x1c46 <SH100HW_SetOutputMode>
				SH100HW_SetNewLedState(LED_PWR_GRN, LED_ON);
    10ce:	61 e0       	ldi	r22, 0x01	; 1
    10d0:	87 e0       	ldi	r24, 0x07	; 7
    10d2:	0f d4       	rcall	.+2078   	; 0x18f2 <SH100HW_SetNewLedState>
				SH100HW_SetNewLedState(LED_PWR_RED, LED_OFF);
    10d4:	60 e0       	ldi	r22, 0x00	; 0
    10d6:	88 e0       	ldi	r24, 0x08	; 8
    10d8:	0c d4       	rcall	.+2072   	; 0x18f2 <SH100HW_SetNewLedState>
    10da:	08 95       	ret
			}			
			break;
		}
		case OUT_8OHM:
		{
			if(MIDICTRL_MidiMode() == RUNNING)
    10dc:	9f d5       	rcall	.+2878   	; 0x1c1c <MIDICTRL_MidiMode>
    10de:	81 11       	cpse	r24, r1
    10e0:	14 c0       	rjmp	.+40     	; 0x110a <SH100CTRL_CheckOutputJacks+0x76>
			{
				SH100CTRL_UnmuteAmp();
    10e2:	7e d5       	rcall	.+2812   	; 0x1be0 <SH100CTRL_UnmuteAmp>
				SH100HW_SetOutputMode(OUTPUT_8OHM);
    10e4:	80 e0       	ldi	r24, 0x00	; 0
    10e6:	af d5       	rcall	.+2910   	; 0x1c46 <SH100HW_SetOutputMode>
				SH100HW_SetNewLedState(LED_PWR_GRN, LED_ON);
    10e8:	61 e0       	ldi	r22, 0x01	; 1
    10ea:	87 e0       	ldi	r24, 0x07	; 7
    10ec:	02 d4       	rcall	.+2052   	; 0x18f2 <SH100HW_SetNewLedState>
				SH100HW_SetNewLedState(LED_PWR_RED, LED_OFF);
    10ee:	60 e0       	ldi	r22, 0x00	; 0
    10f0:	88 e0       	ldi	r24, 0x08	; 8
    10f2:	ff d3       	rcall	.+2046   	; 0x18f2 <SH100HW_SetNewLedState>
    10f4:	08 95       	ret

			break;
		}
		case OUT_BOTH:
		{
			if(MIDICTRL_MidiMode() == RUNNING)
    10f6:	92 d5       	rcall	.+2852   	; 0x1c1c <MIDICTRL_MidiMode>
    10f8:	81 11       	cpse	r24, r1
    10fa:	06 c0       	rjmp	.+12     	; 0x1108 <SH100CTRL_CheckOutputJacks+0x74>
			{
				SH100HW_SetNewLedState(LED_PWR_GRN, LED_OFF);
    10fc:	60 e0       	ldi	r22, 0x00	; 0
    10fe:	87 e0       	ldi	r24, 0x07	; 7
    1100:	f8 d3       	rcall	.+2032   	; 0x18f2 <SH100HW_SetNewLedState>
				SH100HW_SetNewLedState(LED_PWR_RED, LED_ON);
    1102:	61 e0       	ldi	r22, 0x01	; 1
    1104:	88 e0       	ldi	r24, 0x08	; 8
    1106:	f5 d3       	rcall	.+2026   	; 0x18f2 <SH100HW_SetNewLedState>
			}
			SH100CTRL_MuteAmp();
    1108:	98 d5       	rcall	.+2864   	; 0x1c3a <SH100CTRL_MuteAmp>
    110a:	08 95       	ret

Disassembly of section .text.SH100HW_Init:

0000124a <SH100HW_Init>:

bool isPAOk;

void SH100HW_Init()
{
	isPAOk = false;
    124a:	10 92 65 01 	sts	0x0165, r1	; 0x800165 <isPAOk>
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
    124e:	55 b1       	in	r21, 0x05	; 5
		}

		*((uint8_t *)port + 1) |= pin_mask;
    1250:	94 b1       	in	r25, 0x04	; 4
    1252:	98 62       	ori	r25, 0x28	; 40
		port_pin_flags_t flags)
{
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
    1254:	88 b1       	in	r24, 0x08	; 8
    1256:	80 61       	ori	r24, 0x10	; 16
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
		}

		*((uint8_t *)port + 1) |= pin_mask;
    1258:	27 b1       	in	r18, 0x07	; 7
    125a:	20 61       	ori	r18, 0x10	; 16
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
    125c:	3b b1       	in	r19, 0x0b	; 11
		}

		*((uint8_t *)port + 1) |= pin_mask;
    125e:	4a b1       	in	r20, 0x0a	; 10
    1260:	40 6e       	ori	r20, 0xE0	; 224
	} else {
		*((uint8_t *)port + 1) &= ~pin_mask;
		if (flags & IOPORT_PULL_UP) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
    1262:	3b 71       	andi	r19, 0x1B	; 27
			*((uint8_t *)port + 2) &= ~pin_mask;
		}

		*((uint8_t *)port + 1) |= pin_mask;
	} else {
		*((uint8_t *)port + 1) &= ~pin_mask;
    1264:	4b 7e       	andi	r20, 0xEB	; 235
    1266:	4a b9       	out	0x0a, r20	; 10
		if (flags & IOPORT_PULL_UP) {
			*((uint8_t *)port + 2) |= pin_mask;
    1268:	30 61       	ori	r19, 0x10	; 16
    126a:	3b b9       	out	0x0b, r19	; 11
			*((uint8_t *)port + 2) &= ~pin_mask;
		}

		*((uint8_t *)port + 1) |= pin_mask;
	} else {
		*((uint8_t *)port + 1) &= ~pin_mask;
    126c:	2b 7d       	andi	r18, 0xDB	; 219
		if (flags & IOPORT_PULL_UP) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
    126e:	8b 7d       	andi	r24, 0xDB	; 219
			*((uint8_t *)port + 2) &= ~pin_mask;
		}

		*((uint8_t *)port + 1) |= pin_mask;
	} else {
		*((uint8_t *)port + 1) &= ~pin_mask;
    1270:	9c 7f       	andi	r25, 0xFC	; 252
		port_pin_flags_t flags)
{
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
    1272:	82 60       	ori	r24, 0x02	; 2
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
    1274:	87 7f       	andi	r24, 0xF7	; 247
    1276:	88 b9       	out	0x08, r24	; 8
		}

		*((uint8_t *)port + 1) |= pin_mask;
    1278:	82 2f       	mov	r24, r18
    127a:	8a 60       	ori	r24, 0x0A	; 10
    127c:	87 b9       	out	0x07, r24	; 7
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
		if (flags & IOPORT_INIT_HIGH) {
			*((uint8_t *)port + 2) |= pin_mask;
		} else {
			*((uint8_t *)port + 2) &= ~pin_mask;
    127e:	85 2f       	mov	r24, r21
    1280:	80 7d       	andi	r24, 0xD0	; 208
    1282:	85 b9       	out	0x05, r24	; 5
		}

		*((uint8_t *)port + 1) |= pin_mask;
    1284:	89 2f       	mov	r24, r25
    1286:	84 60       	ori	r24, 0x04	; 4
    1288:	84 b9       	out	0x04, r24	; 4
	//gpio_configure_pin(PIN_SW, IOPORT_INIT_LOW | IOPORT_DIR_OUTPUT);
	gpio_configure_pin(PIN_MUTE, IOPORT_INIT_HIGH | IOPORT_DIR_OUTPUT); // MUTE on start
	gpio_configure_pin(PIN_RELE_W, IOPORT_INIT_LOW | IOPORT_DIR_OUTPUT);
	gpio_configure_pin(PIN_RELAY_LOOP, IOPORT_INIT_LOW | IOPORT_DIR_OUTPUT);
	
	for(int i=0; i< LED_COUNT; i++)
    128a:	80 e0       	ldi	r24, 0x00	; 0
    128c:	90 e0       	ldi	r25, 0x00	; 0
    128e:	0a c0       	rjmp	.+20     	; 0x12a4 <SH100HW_Init+0x5a>
	{
		led[i].blinkCount = 255; // set default blink count to infinite
    1290:	fc 01       	movw	r30, r24
    1292:	ee 0f       	add	r30, r30
    1294:	ff 1f       	adc	r31, r31
    1296:	e8 0f       	add	r30, r24
    1298:	f9 1f       	adc	r31, r25
    129a:	e9 5b       	subi	r30, 0xB9	; 185
    129c:	fe 4f       	sbci	r31, 0xFE	; 254
    129e:	2f ef       	ldi	r18, 0xFF	; 255
    12a0:	22 83       	std	Z+2, r18	; 0x02
	//gpio_configure_pin(PIN_SW, IOPORT_INIT_LOW | IOPORT_DIR_OUTPUT);
	gpio_configure_pin(PIN_MUTE, IOPORT_INIT_HIGH | IOPORT_DIR_OUTPUT); // MUTE on start
	gpio_configure_pin(PIN_RELE_W, IOPORT_INIT_LOW | IOPORT_DIR_OUTPUT);
	gpio_configure_pin(PIN_RELAY_LOOP, IOPORT_INIT_LOW | IOPORT_DIR_OUTPUT);
	
	for(int i=0; i< LED_COUNT; i++)
    12a2:	01 96       	adiw	r24, 0x01	; 1
    12a4:	89 30       	cpi	r24, 0x09	; 9
    12a6:	91 05       	cpc	r25, r1
    12a8:	9c f3       	brlt	.-26     	; 0x1290 <SH100HW_Init+0x46>
	{
		led[i].blinkCount = 255; // set default blink count to infinite
	}
}
    12aa:	08 95       	ret

Disassembly of section .text.SH100HW_SetPAFailure:

00001baa <SH100HW_SetPAFailure>:

void SH100HW_SetPAFailure(bool isFail)
{
	isPAOk = !isFail;
    1baa:	91 e0       	ldi	r25, 0x01	; 1
    1bac:	98 27       	eor	r25, r24
    1bae:	90 93 65 01 	sts	0x0165, r25	; 0x800165 <isPAOk>
	if(isFail)
    1bb2:	81 11       	cpse	r24, r1
	{
		SH100CTRL_MuteAmp();
    1bb4:	42 d0       	rcall	.+132    	; 0x1c3a <SH100CTRL_MuteAmp>
    1bb6:	08 95       	ret

Disassembly of section .text.SH100HW_GetPAFailure:

00001bf8 <SH100HW_GetPAFailure>:
	}
}

bool SH100HW_GetPAFailure()
{
	return !isPAOk;
    1bf8:	90 91 65 01 	lds	r25, 0x0165	; 0x800165 <isPAOk>
}
    1bfc:	81 e0       	ldi	r24, 0x01	; 1
    1bfe:	89 27       	eor	r24, r25
    1c00:	08 95       	ret

Disassembly of section .text.SH100HW_SetCh:

000013b4 <SH100HW_SetCh>:

void SH100HW_SetCh(uint8_t chNum)
{
	switch(chNum)
    13b4:	81 30       	cpi	r24, 0x01	; 1
    13b6:	69 f0       	breq	.+26     	; 0x13d2 <SH100HW_SetCh+0x1e>
    13b8:	28 f0       	brcs	.+10     	; 0x13c4 <SH100HW_SetCh+0x10>
    13ba:	82 30       	cpi	r24, 0x02	; 2
    13bc:	91 f0       	breq	.+36     	; 0x13e2 <SH100HW_SetCh+0x2e>
    13be:	83 30       	cpi	r24, 0x03	; 3
    13c0:	c1 f0       	breq	.+48     	; 0x13f2 <SH100HW_SetCh+0x3e>
    13c2:	08 95       	ret
	{
		case 0:
		{
			RELAY_13_24 = REL_OFF;
    13c4:	10 92 64 01 	sts	0x0164, r1	; 0x800164 <RELAY_13_24>
			RELAY_1_3 = REL_OFF;
    13c8:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <RELAY_1_3>
			RELAY_2_4 = REL_OFF;
    13cc:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <RELAY_2_4>
			break;
    13d0:	08 95       	ret
		}
		case 1:
		{
			RELAY_13_24 = REL_ON;
    13d2:	81 e0       	ldi	r24, 0x01	; 1
    13d4:	80 93 64 01 	sts	0x0164, r24	; 0x800164 <RELAY_13_24>
			RELAY_1_3 = REL_OFF;
    13d8:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <RELAY_1_3>
			RELAY_2_4 = REL_OFF;
    13dc:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <RELAY_2_4>
			break;
    13e0:	08 95       	ret
		}
		case 2:
		{
			RELAY_13_24 = REL_OFF;
    13e2:	10 92 64 01 	sts	0x0164, r1	; 0x800164 <RELAY_13_24>
			RELAY_1_3 = REL_ON;
    13e6:	81 e0       	ldi	r24, 0x01	; 1
    13e8:	80 93 46 01 	sts	0x0146, r24	; 0x800146 <RELAY_1_3>
			RELAY_2_4 = REL_OFF;
    13ec:	10 92 45 01 	sts	0x0145, r1	; 0x800145 <RELAY_2_4>
			break;
    13f0:	08 95       	ret
		}
		case 3:
		{
			RELAY_13_24 = REL_ON;
    13f2:	81 e0       	ldi	r24, 0x01	; 1
    13f4:	80 93 64 01 	sts	0x0164, r24	; 0x800164 <RELAY_13_24>
			RELAY_1_3 = REL_OFF;
    13f8:	10 92 46 01 	sts	0x0146, r1	; 0x800146 <RELAY_1_3>
			RELAY_2_4 = REL_ON;
    13fc:	80 93 45 01 	sts	0x0145, r24	; 0x800145 <RELAY_2_4>
    1400:	08 95       	ret

Disassembly of section .text.SH100HW_LoopEn:

00001ac8 <SH100HW_LoopEn>:
	}
}

void SH100HW_LoopEn(bool isEnabled)
{
	RELAY_LOOP = isEnabled;
    1ac8:	80 93 63 01 	sts	0x0163, r24	; 0x800163 <RELAY_LOOP>
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
    1acc:	88 23       	and	r24, r24
    1ace:	21 f0       	breq	.+8      	; 0x1ad8 <SH100HW_LoopEn+0x10>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    1ad0:	85 b1       	in	r24, 0x05	; 5
    1ad2:	84 60       	ori	r24, 0x04	; 4
    1ad4:	85 b9       	out	0x05, r24	; 5
    1ad6:	08 95       	ret
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    1ad8:	85 b1       	in	r24, 0x05	; 5
    1ada:	8b 7f       	andi	r24, 0xFB	; 251
    1adc:	85 b9       	out	0x05, r24	; 5
    1ade:	08 95       	ret

Disassembly of section .text.SH100HW_SetAB:

00001c40 <SH100HW_SetAB>:
	ioport_set_pin_level(PIN_RELAY_LOOP, RELAY_LOOP);
}

void SH100HW_SetAB(bool isBEn)
{
	RELAY_AB = isBEn;
    1c40:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <RELAY_AB>
    1c44:	08 95       	ret

Disassembly of section .text.SH100HW_SetNewLedState:

000018f2 <SH100HW_SetNewLedState>:
}

void SH100HW_SetNewLedState(uint8_t ledId, SH100HW_LedState_t newState)
{
	if(led[ledId].curState != newState)
    18f2:	90 e0       	ldi	r25, 0x00	; 0
    18f4:	fc 01       	movw	r30, r24
    18f6:	ee 0f       	add	r30, r30
    18f8:	ff 1f       	adc	r31, r31
    18fa:	e8 0f       	add	r30, r24
    18fc:	f9 1f       	adc	r31, r25
    18fe:	e9 5b       	subi	r30, 0xB9	; 185
    1900:	fe 4f       	sbci	r31, 0xFE	; 254
    1902:	20 81       	ld	r18, Z
    1904:	26 17       	cp	r18, r22
    1906:	51 f0       	breq	.+20     	; 0x191c <SH100HW_SetNewLedState+0x2a>
	{
		led[ledId].prevState = led[ledId].curState;
    1908:	fc 01       	movw	r30, r24
    190a:	ee 0f       	add	r30, r30
    190c:	ff 1f       	adc	r31, r31
    190e:	8e 0f       	add	r24, r30
    1910:	9f 1f       	adc	r25, r31
    1912:	fc 01       	movw	r30, r24
    1914:	e9 5b       	subi	r30, 0xB9	; 185
    1916:	fe 4f       	sbci	r31, 0xFE	; 254
    1918:	21 83       	std	Z+1, r18	; 0x01
		led[ledId].curState = newState;
    191a:	60 83       	st	Z, r22
    191c:	08 95       	ret

Disassembly of section .text.SH100HW_SetPreviousLedState:

00001ae0 <SH100HW_SetPreviousLedState>:
	}
}

void SH100HW_SetPreviousLedState(uint8_t ledId)
{
	led[ledId].curState = led[ledId].prevState;
    1ae0:	90 e0       	ldi	r25, 0x00	; 0
    1ae2:	fc 01       	movw	r30, r24
    1ae4:	ee 0f       	add	r30, r30
    1ae6:	ff 1f       	adc	r31, r31
    1ae8:	8e 0f       	add	r24, r30
    1aea:	9f 1f       	adc	r25, r31
    1aec:	fc 01       	movw	r30, r24
    1aee:	e9 5b       	subi	r30, 0xB9	; 185
    1af0:	fe 4f       	sbci	r31, 0xFE	; 254
    1af2:	81 81       	ldd	r24, Z+1	; 0x01
    1af4:	80 83       	st	Z, r24
    1af6:	08 95       	ret

Disassembly of section .text.SH100HW_SetLedBlinkCount:

00001638 <SH100HW_SetLedBlinkCount>:
}

void SH100HW_SetLedBlinkCount(uint8_t ledId, uint8_t blinkCount)
{
	if(led[ledId].curState != LED_FAST_BLINKING)
    1638:	90 e0       	ldi	r25, 0x00	; 0
    163a:	fc 01       	movw	r30, r24
    163c:	ee 0f       	add	r30, r30
    163e:	ff 1f       	adc	r31, r31
    1640:	e8 0f       	add	r30, r24
    1642:	f9 1f       	adc	r31, r25
    1644:	e9 5b       	subi	r30, 0xB9	; 185
    1646:	fe 4f       	sbci	r31, 0xFE	; 254
    1648:	20 81       	ld	r18, Z
    164a:	22 30       	cpi	r18, 0x02	; 2
    164c:	41 f0       	breq	.+16     	; 0x165e <SH100HW_SetLedBlinkCount+0x26>
	{
		led[ledId].prevState = led[ledId].curState;
    164e:	fc 01       	movw	r30, r24
    1650:	ee 0f       	add	r30, r30
    1652:	ff 1f       	adc	r31, r31
    1654:	e8 0f       	add	r30, r24
    1656:	f9 1f       	adc	r31, r25
    1658:	e9 5b       	subi	r30, 0xB9	; 185
    165a:	fe 4f       	sbci	r31, 0xFE	; 254
    165c:	21 83       	std	Z+1, r18	; 0x01
	}
	led[ledId].curState = LED_FAST_BLINKING;
    165e:	fc 01       	movw	r30, r24
    1660:	ee 0f       	add	r30, r30
    1662:	ff 1f       	adc	r31, r31
    1664:	8e 0f       	add	r24, r30
    1666:	9f 1f       	adc	r25, r31
    1668:	fc 01       	movw	r30, r24
    166a:	e9 5b       	subi	r30, 0xB9	; 185
    166c:	fe 4f       	sbci	r31, 0xFE	; 254
    166e:	82 e0       	ldi	r24, 0x02	; 2
    1670:	80 83       	st	Z, r24
	led[ledId].blinkCount = blinkCount*2;
    1672:	66 0f       	add	r22, r22
    1674:	62 83       	std	Z+2, r22	; 0x02
    1676:	08 95       	ret

Disassembly of section .text.SH100HW_GetOutputJacks:

00001af8 <SH100HW_GetOutputJacks>:
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
    1af8:	21 e0       	ldi	r18, 0x01	; 1
    1afa:	18 9b       	sbis	0x03, 0	; 3
    1afc:	20 e0       	ldi	r18, 0x00	; 0
    1afe:	91 e0       	ldi	r25, 0x01	; 1
    1b00:	19 9b       	sbis	0x03, 1	; 3
    1b02:	90 e0       	ldi	r25, 0x00	; 0

SH100HW_OutputJacks_t SH100HW_GetOutputJacks()
{
	bool is16Ohm = ioport_get_pin_level(PIN_M16_DETECT);
	bool is8Ohm = ioport_get_pin_level(PIN_M8_DETECT);
	return ((is16Ohm) | (is8Ohm<<1));
    1b04:	89 2f       	mov	r24, r25
    1b06:	90 e0       	ldi	r25, 0x00	; 0
    1b08:	88 0f       	add	r24, r24
    1b0a:	99 1f       	adc	r25, r25
}
    1b0c:	82 2b       	or	r24, r18
    1b0e:	08 95       	ret

Disassembly of section .text.SH100HW_SetPAState:

000016b6 <SH100HW_SetPAState>:

void SH100HW_SetPAState(SH100HW_OutputState_t state)
{
	if(isPAOk)
    16b6:	90 91 65 01 	lds	r25, 0x0165	; 0x800165 <isPAOk>
    16ba:	99 23       	and	r25, r25
    16bc:	99 f0       	breq	.+38     	; 0x16e4 <SH100HW_SetPAState+0x2e>
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
    16be:	81 11       	cpse	r24, r1
    16c0:	04 c0       	rjmp	.+8      	; 0x16ca <SH100HW_SetPAState+0x14>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    16c2:	98 b1       	in	r25, 0x08	; 8
    16c4:	92 60       	ori	r25, 0x02	; 2
    16c6:	98 b9       	out	0x08, r25	; 8
    16c8:	03 c0       	rjmp	.+6      	; 0x16d0 <SH100HW_SetPAState+0x1a>
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    16ca:	98 b1       	in	r25, 0x08	; 8
    16cc:	9d 7f       	andi	r25, 0xFD	; 253
    16ce:	98 b9       	out	0x08, r25	; 8
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
    16d0:	88 23       	and	r24, r24
    16d2:	21 f0       	breq	.+8      	; 0x16dc <SH100HW_SetPAState+0x26>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    16d4:	88 b1       	in	r24, 0x08	; 8
    16d6:	88 60       	ori	r24, 0x08	; 8
    16d8:	88 b9       	out	0x08, r24	; 8
    16da:	08 95       	ret
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    16dc:	88 b1       	in	r24, 0x08	; 8
    16de:	87 7f       	andi	r24, 0xF7	; 247
    16e0:	88 b9       	out	0x08, r24	; 8
    16e2:	08 95       	ret
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    16e4:	88 b1       	in	r24, 0x08	; 8
    16e6:	82 60       	ori	r24, 0x02	; 2
    16e8:	88 b9       	out	0x08, r24	; 8
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    16ea:	88 b1       	in	r24, 0x08	; 8
    16ec:	87 7f       	andi	r24, 0xF7	; 247
    16ee:	88 b9       	out	0x08, r24	; 8
    16f0:	08 95       	ret

Disassembly of section .text.SH100HW_SetOutputMode:

00001c46 <SH100HW_SetOutputMode>:
	}
}

void SH100HW_SetOutputMode(SH100HW_PAMode_t mode)
{
	RELAY_8_16 = mode;
    1c46:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <RELAY_8_16>
    1c4a:	08 95       	ret

Disassembly of section .text.SH100HW_StartADConvertion:

00001b68 <SH100HW_StartADConvertion>:
}

void SH100HW_StartADConvertion(ADC_Channels_t channel)
{
	ADMUX = (1<<REFS0) | channel; // AREF ext pin, Left-adjustment result
    1b68:	80 64       	ori	r24, 0x40	; 64
    1b6a:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7fe07c>
	DIDR0 = 0x01; // Disable digital io on PC0
    1b6e:	81 e0       	ldi	r24, 0x01	; 1
    1b70:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7fe07e>
	ADCSRA = (1<<ADEN) | (1<<ADSC) | (1<<ADIE) | (1<<ADPS2) | (1<<ADPS1); // ADC enable, INT enable, prescaler = 64
    1b74:	8e ec       	ldi	r24, 0xCE	; 206
    1b76:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7fe07a>
    1b7a:	08 95       	ret

Disassembly of section .text.SH100HW_GetControlsState:

00000962 <SH100HW_GetControlsState>:
}

SH100HW_Controls_t SH100HW_GetControlsState()
{
 962:	cf 93       	push	r28
 964:	df 93       	push	r29
 966:	dc 01       	movw	r26, r24
	SH100HW_Controls_t buttonsState;
	uint8_t midiChBit[4];
	for(uint8_t cnt = 0; cnt<8; cnt++)
 968:	90 e0       	ldi	r25, 0x00	; 0
 96a:	be c0       	rjmp	.+380    	; 0xae8 <SH100HW_GetControlsState+0x186>
	{
		
		switch(cnt)
 96c:	49 2f       	mov	r20, r25
 96e:	50 e0       	ldi	r21, 0x00	; 0
 970:	48 30       	cpi	r20, 0x08	; 8
 972:	51 05       	cpc	r21, r1
 974:	08 f0       	brcs	.+2      	; 0x978 <SH100HW_GetControlsState+0x16>
 976:	b7 c0       	rjmp	.+366    	; 0xae6 <SH100HW_GetControlsState+0x184>
 978:	fa 01       	movw	r30, r20
 97a:	ef 5d       	subi	r30, 0xDF	; 223
 97c:	ff 4f       	sbci	r31, 0xFF	; 255
 97e:	09 94       	ijmp
 980:	8b b1       	in	r24, 0x0b	; 11
 982:	8f 7d       	andi	r24, 0xDF	; 223
 984:	8b b9       	out	0x0b, r24	; 11
 986:	8b b1       	in	r24, 0x0b	; 11
 988:	8f 7b       	andi	r24, 0xBF	; 191
 98a:	8b b9       	out	0x0b, r24	; 11
 98c:	8b b1       	in	r24, 0x0b	; 11
 98e:	8f 77       	andi	r24, 0x7F	; 127
 990:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 992:	81 e0       	ldi	r24, 0x01	; 1
 994:	4c 9b       	sbis	0x09, 4	; 9
 996:	80 e0       	ldi	r24, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 0);
				ioport_set_pin_level(PIN_B, 0);
				ioport_set_pin_level(PIN_C, 0);
				
				buttonsState.midiOmni = ioport_get_pin_level(PIN_MIDI_SWITCH);
 998:	11 96       	adiw	r26, 0x01	; 1
 99a:	8c 93       	st	X, r24
 99c:	11 97       	sbiw	r26, 0x01	; 1
 99e:	81 e0       	ldi	r24, 0x01	; 1
 9a0:	35 9b       	sbis	0x06, 5	; 6
 9a2:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.FS2_sleeve = ioport_get_pin_level(PIN_FOOTSWITCH);
 9a4:	1c 96       	adiw	r26, 0x0c	; 12
 9a6:	8c 93       	st	X, r24
 9a8:	1c 97       	sbiw	r26, 0x0c	; 12
				break;
 9aa:	9d c0       	rjmp	.+314    	; 0xae6 <SH100HW_GetControlsState+0x184>
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 9ac:	8b b1       	in	r24, 0x0b	; 11
 9ae:	80 62       	ori	r24, 0x20	; 32
 9b0:	8b b9       	out	0x0b, r24	; 11
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 9b2:	8b b1       	in	r24, 0x0b	; 11
 9b4:	8f 7b       	andi	r24, 0xBF	; 191
 9b6:	8b b9       	out	0x0b, r24	; 11
 9b8:	8b b1       	in	r24, 0x0b	; 11
 9ba:	8f 77       	andi	r24, 0x7F	; 127
 9bc:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 9be:	81 e0       	ldi	r24, 0x01	; 1
 9c0:	4c 9b       	sbis	0x09, 4	; 9
 9c2:	80 e0       	ldi	r24, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 1);
				ioport_set_pin_level(PIN_B, 0);
				ioport_set_pin_level(PIN_C, 0);
				
				midiChBit[3] = ioport_get_pin_level(PIN_MIDI_SWITCH);
 9c4:	28 2f       	mov	r18, r24
 9c6:	81 e0       	ldi	r24, 0x01	; 1
 9c8:	4a 9b       	sbis	0x09, 2	; 9
 9ca:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.btnAB = ioport_get_pin_level(PIN_BUTTONS);
 9cc:	17 96       	adiw	r26, 0x07	; 7
 9ce:	8c 93       	st	X, r24
 9d0:	17 97       	sbiw	r26, 0x07	; 7
 9d2:	81 e0       	ldi	r24, 0x01	; 1
 9d4:	35 9b       	sbis	0x06, 5	; 6
 9d6:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.FS2_presence = ioport_get_pin_level(PIN_FOOTSWITCH);
 9d8:	1e 96       	adiw	r26, 0x0e	; 14
 9da:	8c 93       	st	X, r24
 9dc:	1e 97       	sbiw	r26, 0x0e	; 14
				break;
 9de:	83 c0       	rjmp	.+262    	; 0xae6 <SH100HW_GetControlsState+0x184>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 9e0:	8b b1       	in	r24, 0x0b	; 11
 9e2:	8f 7d       	andi	r24, 0xDF	; 223
 9e4:	8b b9       	out	0x0b, r24	; 11
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 9e6:	8b b1       	in	r24, 0x0b	; 11
 9e8:	80 64       	ori	r24, 0x40	; 64
 9ea:	8b b9       	out	0x0b, r24	; 11
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 9ec:	8b b1       	in	r24, 0x0b	; 11
 9ee:	8f 77       	andi	r24, 0x7F	; 127
 9f0:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 9f2:	41 e0       	ldi	r20, 0x01	; 1
 9f4:	4c 9b       	sbis	0x09, 4	; 9
 9f6:	40 e0       	ldi	r20, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 0);
				ioport_set_pin_level(PIN_B, 1);
				ioport_set_pin_level(PIN_C, 0);
				
				midiChBit[2] = ioport_get_pin_level(PIN_MIDI_SWITCH);
 9f8:	34 2f       	mov	r19, r20
 9fa:	81 e0       	ldi	r24, 0x01	; 1
 9fc:	4a 9b       	sbis	0x09, 2	; 9
 9fe:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.btnLoop = ioport_get_pin_level(PIN_BUTTONS);
 a00:	18 96       	adiw	r26, 0x08	; 8
 a02:	8c 93       	st	X, r24
 a04:	18 97       	sbiw	r26, 0x08	; 8
 a06:	81 e0       	ldi	r24, 0x01	; 1
 a08:	35 9b       	sbis	0x06, 5	; 6
 a0a:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.FS1_presence = ioport_get_pin_level(PIN_FOOTSWITCH);
 a0c:	1b 96       	adiw	r26, 0x0b	; 11
 a0e:	8c 93       	st	X, r24
 a10:	1b 97       	sbiw	r26, 0x0b	; 11
				break;
 a12:	69 c0       	rjmp	.+210    	; 0xae6 <SH100HW_GetControlsState+0x184>
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 a14:	8b b1       	in	r24, 0x0b	; 11
 a16:	80 62       	ori	r24, 0x20	; 32
 a18:	8b b9       	out	0x0b, r24	; 11
 a1a:	8b b1       	in	r24, 0x0b	; 11
 a1c:	80 64       	ori	r24, 0x40	; 64
 a1e:	8b b9       	out	0x0b, r24	; 11
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 a20:	8b b1       	in	r24, 0x0b	; 11
 a22:	8f 77       	andi	r24, 0x7F	; 127
 a24:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 a26:	81 e0       	ldi	r24, 0x01	; 1
 a28:	4c 9b       	sbis	0x09, 4	; 9
 a2a:	80 e0       	ldi	r24, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 1);
				ioport_set_pin_level(PIN_B, 1);
				ioport_set_pin_level(PIN_C, 0);
				
				buttonsState.midiMuteComm = ioport_get_pin_level(PIN_MIDI_SWITCH);
 a2c:	12 96       	adiw	r26, 0x02	; 2
 a2e:	8c 93       	st	X, r24
 a30:	12 97       	sbiw	r26, 0x02	; 2
 a32:	81 e0       	ldi	r24, 0x01	; 1
 a34:	35 9b       	sbis	0x06, 5	; 6
 a36:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.FS1_sleeve = ioport_get_pin_level(PIN_FOOTSWITCH);
 a38:	19 96       	adiw	r26, 0x09	; 9
 a3a:	8c 93       	st	X, r24
 a3c:	19 97       	sbiw	r26, 0x09	; 9
				break;
 a3e:	53 c0       	rjmp	.+166    	; 0xae6 <SH100HW_GetControlsState+0x184>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 a40:	8b b1       	in	r24, 0x0b	; 11
 a42:	8f 7d       	andi	r24, 0xDF	; 223
 a44:	8b b9       	out	0x0b, r24	; 11
 a46:	8b b1       	in	r24, 0x0b	; 11
 a48:	8f 7b       	andi	r24, 0xBF	; 191
 a4a:	8b b9       	out	0x0b, r24	; 11
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 a4c:	8b b1       	in	r24, 0x0b	; 11
 a4e:	80 68       	ori	r24, 0x80	; 128
 a50:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 a52:	61 e0       	ldi	r22, 0x01	; 1
 a54:	4c 9b       	sbis	0x09, 4	; 9
 a56:	60 e0       	ldi	r22, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 0);
				ioport_set_pin_level(PIN_B, 0);
				ioport_set_pin_level(PIN_C, 1);
				
				midiChBit[0] = ioport_get_pin_level(PIN_MIDI_SWITCH);
 a58:	d6 2f       	mov	r29, r22
 a5a:	81 e0       	ldi	r24, 0x01	; 1
 a5c:	4a 9b       	sbis	0x09, 2	; 9
 a5e:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.btnCh2 = ioport_get_pin_level(PIN_BUTTONS);
 a60:	14 96       	adiw	r26, 0x04	; 4
 a62:	8c 93       	st	X, r24
 a64:	14 97       	sbiw	r26, 0x04	; 4
 a66:	81 e0       	ldi	r24, 0x01	; 1
 a68:	35 9b       	sbis	0x06, 5	; 6
 a6a:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.FS1_tip = ioport_get_pin_level(PIN_FOOTSWITCH);
 a6c:	1a 96       	adiw	r26, 0x0a	; 10
 a6e:	8c 93       	st	X, r24
 a70:	1a 97       	sbiw	r26, 0x0a	; 10
				break;
 a72:	39 c0       	rjmp	.+114    	; 0xae6 <SH100HW_GetControlsState+0x184>
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 a74:	8b b1       	in	r24, 0x0b	; 11
 a76:	80 62       	ori	r24, 0x20	; 32
 a78:	8b b9       	out	0x0b, r24	; 11
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 a7a:	8b b1       	in	r24, 0x0b	; 11
 a7c:	8f 7b       	andi	r24, 0xBF	; 191
 a7e:	8b b9       	out	0x0b, r24	; 11
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 a80:	8b b1       	in	r24, 0x0b	; 11
 a82:	80 68       	ori	r24, 0x80	; 128
 a84:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 a86:	81 e0       	ldi	r24, 0x01	; 1
 a88:	4a 9b       	sbis	0x09, 2	; 9
 a8a:	80 e0       	ldi	r24, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 1);
				ioport_set_pin_level(PIN_B, 0);
				ioport_set_pin_level(PIN_C, 1);
				
				buttonsState.btnCh3 = ioport_get_pin_level(PIN_BUTTONS);
 a8c:	15 96       	adiw	r26, 0x05	; 5
 a8e:	8c 93       	st	X, r24
 a90:	15 97       	sbiw	r26, 0x05	; 5
				break;
 a92:	29 c0       	rjmp	.+82     	; 0xae6 <SH100HW_GetControlsState+0x184>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
 a94:	8b b1       	in	r24, 0x0b	; 11
 a96:	8f 7d       	andi	r24, 0xDF	; 223
 a98:	8b b9       	out	0x0b, r24	; 11
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 a9a:	8b b1       	in	r24, 0x0b	; 11
 a9c:	80 64       	ori	r24, 0x40	; 64
 a9e:	8b b9       	out	0x0b, r24	; 11
 aa0:	8b b1       	in	r24, 0x0b	; 11
 aa2:	80 68       	ori	r24, 0x80	; 128
 aa4:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 aa6:	61 e0       	ldi	r22, 0x01	; 1
 aa8:	4c 9b       	sbis	0x09, 4	; 9
 aaa:	60 e0       	ldi	r22, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 0);
				ioport_set_pin_level(PIN_B, 1);
				ioport_set_pin_level(PIN_C, 1);
				
				midiChBit[1] = ioport_get_pin_level(PIN_MIDI_SWITCH);
 aac:	c6 2f       	mov	r28, r22
 aae:	81 e0       	ldi	r24, 0x01	; 1
 ab0:	4a 9b       	sbis	0x09, 2	; 9
 ab2:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.btnCh4 = ioport_get_pin_level(PIN_BUTTONS);
 ab4:	16 96       	adiw	r26, 0x06	; 6
 ab6:	8c 93       	st	X, r24
 ab8:	16 97       	sbiw	r26, 0x06	; 6
 aba:	81 e0       	ldi	r24, 0x01	; 1
 abc:	35 9b       	sbis	0x06, 5	; 6
 abe:	80 e0       	ldi	r24, 0x00	; 0
				buttonsState.FS2_tip = ioport_get_pin_level(PIN_FOOTSWITCH);
 ac0:	1d 96       	adiw	r26, 0x0d	; 13
 ac2:	8c 93       	st	X, r24
 ac4:	1d 97       	sbiw	r26, 0x0d	; 13
				break;
 ac6:	0f c0       	rjmp	.+30     	; 0xae6 <SH100HW_GetControlsState+0x184>
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
 ac8:	8b b1       	in	r24, 0x0b	; 11
 aca:	80 62       	ori	r24, 0x20	; 32
 acc:	8b b9       	out	0x0b, r24	; 11
 ace:	8b b1       	in	r24, 0x0b	; 11
 ad0:	80 64       	ori	r24, 0x40	; 64
 ad2:	8b b9       	out	0x0b, r24	; 11
 ad4:	8b b1       	in	r24, 0x0b	; 11
 ad6:	80 68       	ori	r24, 0x80	; 128
 ad8:	8b b9       	out	0x0b, r24	; 11
 * \return: level high/low
 */
__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	return base->PINCRL & arch_ioport_pin_to_mask(pin);
 ada:	81 e0       	ldi	r24, 0x01	; 1
 adc:	4a 9b       	sbis	0x09, 2	; 9
 ade:	80 e0       	ldi	r24, 0x00	; 0
			{
				ioport_set_pin_level(PIN_A, 1);
				ioport_set_pin_level(PIN_B, 1);
				ioport_set_pin_level(PIN_C, 1);
				
				buttonsState.btnCh1 = ioport_get_pin_level(PIN_BUTTONS);
 ae0:	13 96       	adiw	r26, 0x03	; 3
 ae2:	8c 93       	st	X, r24
 ae4:	13 97       	sbiw	r26, 0x03	; 3

SH100HW_Controls_t SH100HW_GetControlsState()
{
	SH100HW_Controls_t buttonsState;
	uint8_t midiChBit[4];
	for(uint8_t cnt = 0; cnt<8; cnt++)
 ae6:	9f 5f       	subi	r25, 0xFF	; 255
 ae8:	98 30       	cpi	r25, 0x08	; 8
 aea:	08 f4       	brcc	.+2      	; 0xaee <SH100HW_GetControlsState+0x18c>
 aec:	3f cf       	rjmp	.-386    	; 0x96c <SH100HW_GetControlsState+0xa>
			}
			default: break;
		}
	}
	
	buttonsState.midiChNum = midiChBit[0] | (midiChBit[1]<<1) | (midiChBit[2]<<2) | (midiChBit[3]<<3);
 aee:	6c 2f       	mov	r22, r28
 af0:	70 e0       	ldi	r23, 0x00	; 0
 af2:	66 0f       	add	r22, r22
 af4:	77 1f       	adc	r23, r23
 af6:	43 2f       	mov	r20, r19
 af8:	50 e0       	ldi	r21, 0x00	; 0
 afa:	44 0f       	add	r20, r20
 afc:	55 1f       	adc	r21, r21
 afe:	44 0f       	add	r20, r20
 b00:	55 1f       	adc	r21, r21
 b02:	82 2f       	mov	r24, r18
 b04:	90 e0       	ldi	r25, 0x00	; 0
 b06:	88 0f       	add	r24, r24
 b08:	99 1f       	adc	r25, r25
 b0a:	88 0f       	add	r24, r24
 b0c:	99 1f       	adc	r25, r25
 b0e:	88 0f       	add	r24, r24
 b10:	99 1f       	adc	r25, r25
 b12:	6d 2b       	or	r22, r29
 b14:	46 2b       	or	r20, r22
 b16:	84 2b       	or	r24, r20
 b18:	8c 93       	st	X, r24
	
	return buttonsState;
}
 b1a:	cd 01       	movw	r24, r26
 b1c:	df 91       	pop	r29
 b1e:	cf 91       	pop	r28
 b20:	08 95       	ret

Disassembly of section .text.writeShiftRegs:

000015f6 <writeShiftRegs>:

void writeShiftRegs(uint16_t data)
{
    15f6:	ac 01       	movw	r20, r24
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    15f8:	88 b1       	in	r24, 0x08	; 8
    15fa:	8f 7e       	andi	r24, 0xEF	; 239
    15fc:	88 b9       	out	0x08, r24	; 8
	ioport_set_pin_level(PIN_ST, 0);
	for(uint8_t i=0; i<16; i++)
    15fe:	20 e0       	ldi	r18, 0x00	; 0
    1600:	12 c0       	rjmp	.+36     	; 0x1626 <writeShiftRegs+0x30>
    1602:	95 b1       	in	r25, 0x05	; 5
    1604:	9f 7d       	andi	r25, 0xDF	; 223
    1606:	95 b9       	out	0x05, r25	; 5
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
    1608:	55 23       	and	r21, r21
    160a:	24 f4       	brge	.+8      	; 0x1614 <writeShiftRegs+0x1e>
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    160c:	85 b1       	in	r24, 0x05	; 5
    160e:	88 60       	ori	r24, 0x08	; 8
    1610:	85 b9       	out	0x05, r24	; 5
    1612:	03 c0       	rjmp	.+6      	; 0x161a <writeShiftRegs+0x24>
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    1614:	85 b1       	in	r24, 0x05	; 5
    1616:	87 7f       	andi	r24, 0xF7	; 247
    1618:	85 b9       	out	0x05, r24	; 5
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    161a:	95 b1       	in	r25, 0x05	; 5
    161c:	90 62       	ori	r25, 0x20	; 32
    161e:	95 b9       	out	0x05, r25	; 5
	{
		ioport_set_pin_level(PIN_SCK, 0);
		ioport_set_pin_level(PIN_MOSI, (data & 0x8000));
		ioport_set_pin_level(PIN_SCK, 1);
		data = data << 1;
    1620:	44 0f       	add	r20, r20
    1622:	55 1f       	adc	r21, r21
}

void writeShiftRegs(uint16_t data)
{
	ioport_set_pin_level(PIN_ST, 0);
	for(uint8_t i=0; i<16; i++)
    1624:	2f 5f       	subi	r18, 0xFF	; 255
    1626:	20 31       	cpi	r18, 0x10	; 16
    1628:	60 f3       	brcs	.-40     	; 0x1602 <writeShiftRegs+0xc>
					(pin));
	} else {
		base_add->PORTDATA
			= (base_add->PORTDATA  & (~arch_ioport_pin_to_mask
    162a:	85 b1       	in	r24, 0x05	; 5
    162c:	8f 7d       	andi	r24, 0xDF	; 223
    162e:	85 b9       	out	0x05, r24	; 5
{
	PORT_t *base_add = arch_ioport_port_to_base(pin >> 3);

	if (level) {
		base_add->PORTDATA
			= (base_add->PORTDATA  | arch_ioport_pin_to_mask
    1630:	88 b1       	in	r24, 0x08	; 8
    1632:	80 61       	ori	r24, 0x10	; 16
    1634:	88 b9       	out	0x08, r24	; 8
    1636:	08 95       	ret

Disassembly of section .text.SH100HW_MainTask:

0000031e <SH100HW_MainTask>:
uint8_t blinkDecrement;
bool slowBlink = false;
bool fastBlink = false;
uint8_t indErrorCnt = 0;
void SH100HW_MainTask()
{
 31e:	cf 93       	push	r28
 320:	df 93       	push	r29
 322:	cd b7       	in	r28, 0x3d	; 61
 324:	de b7       	in	r29, 0x3e	; 62
 326:	29 97       	sbiw	r28, 0x09	; 9
 328:	0f b6       	in	r0, 0x3f	; 63
 32a:	f8 94       	cli
 32c:	de bf       	out	0x3e, r29	; 62
 32e:	0f be       	out	0x3f, r0	; 63
 330:	cd bf       	out	0x3d, r28	; 61
	if(!isPAOk) SH100CTRL_MuteAmp();
 332:	80 91 65 01 	lds	r24, 0x0165	; 0x800165 <isPAOk>
 336:	81 11       	cpse	r24, r1
 338:	01 c0       	rjmp	.+2      	; 0x33c <SH100HW_MainTask+0x1e>
 33a:	7f dc       	rcall	.-1794   	; 0xfffffc3a <__eeprom_end+0xff7efc3a>
	
	//SH100HW_ReadControlsState();
	
	// blink work----------------------------------------------
	bool isLedOn[LED_COUNT];	
	if((blinkCounter % 25) == 0 && blinkCounter != 0)
 33c:	90 91 b0 01 	lds	r25, 0x01B0	; 0x8001b0 <blinkCounter>
 340:	89 e2       	ldi	r24, 0x29	; 41
 342:	98 9f       	mul	r25, r24
 344:	81 2d       	mov	r24, r1
 346:	11 24       	eor	r1, r1
 348:	86 95       	lsr	r24
 34a:	86 95       	lsr	r24
 34c:	39 2f       	mov	r19, r25
 34e:	29 e1       	ldi	r18, 0x19	; 25
 350:	82 9f       	mul	r24, r18
 352:	30 19       	sub	r19, r0
 354:	11 24       	eor	r1, r1
 356:	31 11       	cpse	r19, r1
 358:	0b c0       	rjmp	.+22     	; 0x370 <SH100HW_MainTask+0x52>
 35a:	99 23       	and	r25, r25
 35c:	49 f0       	breq	.+18     	; 0x370 <SH100HW_MainTask+0x52>
	{
		fastBlink = !fastBlink;
 35e:	80 91 ae 01 	lds	r24, 0x01AE	; 0x8001ae <fastBlink>
 362:	91 e0       	ldi	r25, 0x01	; 1
 364:	89 27       	eor	r24, r25
 366:	80 93 ae 01 	sts	0x01AE, r24	; 0x8001ae <fastBlink>
		blinkDecrement = 1;
 36a:	90 93 44 01 	sts	0x0144, r25	; 0x800144 <blinkDecrement>
 36e:	02 c0       	rjmp	.+4      	; 0x374 <SH100HW_MainTask+0x56>
	}
	else
	{
		blinkDecrement = 0;
 370:	10 92 44 01 	sts	0x0144, r1	; 0x800144 <blinkDecrement>
	}
	
	if(blinkCounter == 50)
 374:	80 91 b0 01 	lds	r24, 0x01B0	; 0x8001b0 <blinkCounter>
 378:	82 33       	cpi	r24, 0x32	; 50
 37a:	51 f4       	brne	.+20     	; 0x390 <SH100HW_MainTask+0x72>
	{
		blinkCounter = 0;
 37c:	10 92 b0 01 	sts	0x01B0, r1	; 0x8001b0 <blinkCounter>
		slowBlink = !slowBlink;
 380:	90 91 af 01 	lds	r25, 0x01AF	; 0x8001af <slowBlink>
 384:	81 e0       	ldi	r24, 0x01	; 1
 386:	89 27       	eor	r24, r25
 388:	80 93 af 01 	sts	0x01AF, r24	; 0x8001af <slowBlink>
uint8_t blinkDecrement;
bool slowBlink = false;
bool fastBlink = false;
uint8_t indErrorCnt = 0;
void SH100HW_MainTask()
{
 38c:	20 e0       	ldi	r18, 0x00	; 0
 38e:	6f c0       	rjmp	.+222    	; 0x46e <__DATA_REGION_LENGTH__+0x6e>
		blinkCounter = 0;
		slowBlink = !slowBlink;
	}
	else
	{
		blinkCounter++;
 390:	8f 5f       	subi	r24, 0xFF	; 255
 392:	80 93 b0 01 	sts	0x01B0, r24	; 0x8001b0 <blinkCounter>
 396:	fa cf       	rjmp	.-12     	; 0x38c <SH100HW_MainTask+0x6e>
	}
	
	for(uint8_t i=0; i<LED_COUNT; i++)
	{
		switch(led[i].curState)
 398:	82 2f       	mov	r24, r18
 39a:	90 e0       	ldi	r25, 0x00	; 0
 39c:	fc 01       	movw	r30, r24
 39e:	ee 0f       	add	r30, r30
 3a0:	ff 1f       	adc	r31, r31
 3a2:	e8 0f       	add	r30, r24
 3a4:	f9 1f       	adc	r31, r25
 3a6:	e9 5b       	subi	r30, 0xB9	; 185
 3a8:	fe 4f       	sbci	r31, 0xFE	; 254
 3aa:	30 81       	ld	r19, Z
 3ac:	31 30       	cpi	r19, 0x01	; 1
 3ae:	79 f0       	breq	.+30     	; 0x3ce <SH100HW_MainTask+0xb0>
 3b0:	30 f0       	brcs	.+12     	; 0x3be <SH100HW_MainTask+0xa0>
 3b2:	32 30       	cpi	r19, 0x02	; 2
 3b4:	a9 f0       	breq	.+42     	; 0x3e0 <SH100HW_MainTask+0xc2>
 3b6:	33 30       	cpi	r19, 0x03	; 3
 3b8:	09 f4       	brne	.+2      	; 0x3bc <SH100HW_MainTask+0x9e>
 3ba:	44 c0       	rjmp	.+136    	; 0x444 <__DATA_REGION_LENGTH__+0x44>
 3bc:	50 c0       	rjmp	.+160    	; 0x45e <__DATA_REGION_LENGTH__+0x5e>
		{
			case LED_OFF: isLedOn[i] = false; break;
 3be:	e1 e0       	ldi	r30, 0x01	; 1
 3c0:	f0 e0       	ldi	r31, 0x00	; 0
 3c2:	ec 0f       	add	r30, r28
 3c4:	fd 1f       	adc	r31, r29
 3c6:	e8 0f       	add	r30, r24
 3c8:	f9 1f       	adc	r31, r25
 3ca:	10 82       	st	Z, r1
 3cc:	4f c0       	rjmp	.+158    	; 0x46c <__DATA_REGION_LENGTH__+0x6c>
			case LED_ON: isLedOn[i] = true; break;
 3ce:	e1 e0       	ldi	r30, 0x01	; 1
 3d0:	f0 e0       	ldi	r31, 0x00	; 0
 3d2:	ec 0f       	add	r30, r28
 3d4:	fd 1f       	adc	r31, r29
 3d6:	e8 0f       	add	r30, r24
 3d8:	f9 1f       	adc	r31, r25
 3da:	31 e0       	ldi	r19, 0x01	; 1
 3dc:	30 83       	st	Z, r19
 3de:	46 c0       	rjmp	.+140    	; 0x46c <__DATA_REGION_LENGTH__+0x6c>
			case LED_FAST_BLINKING: 
			{
				isLedOn[i] = fastBlink; 
 3e0:	40 91 ae 01 	lds	r20, 0x01AE	; 0x8001ae <fastBlink>
 3e4:	e1 e0       	ldi	r30, 0x01	; 1
 3e6:	f0 e0       	ldi	r31, 0x00	; 0
 3e8:	ec 0f       	add	r30, r28
 3ea:	fd 1f       	adc	r31, r29
 3ec:	e8 0f       	add	r30, r24
 3ee:	f9 1f       	adc	r31, r25
 3f0:	40 83       	st	Z, r20
				isLedOn[LED_PWR_GRN] = !fastBlink; // Green led blink 180deg phase of red led
 3f2:	31 e0       	ldi	r19, 0x01	; 1
 3f4:	34 27       	eor	r19, r20
 3f6:	38 87       	std	Y+8, r19	; 0x08
				
				if(led[i].blinkCount != 255)
 3f8:	fc 01       	movw	r30, r24
 3fa:	ee 0f       	add	r30, r30
 3fc:	ff 1f       	adc	r31, r31
 3fe:	e8 0f       	add	r30, r24
 400:	f9 1f       	adc	r31, r25
 402:	e9 5b       	subi	r30, 0xB9	; 185
 404:	fe 4f       	sbci	r31, 0xFE	; 254
 406:	32 81       	ldd	r19, Z+2	; 0x02
 408:	3f 3f       	cpi	r19, 0xFF	; 255
 40a:	81 f1       	breq	.+96     	; 0x46c <__DATA_REGION_LENGTH__+0x6c>
				{
					if(led[i].blinkCount == 0)
 40c:	31 11       	cpse	r19, r1
 40e:	0d c0       	rjmp	.+26     	; 0x42a <__DATA_REGION_LENGTH__+0x2a>
					{
						led[i].curState = led[i].prevState;
 410:	fc 01       	movw	r30, r24
 412:	ee 0f       	add	r30, r30
 414:	ff 1f       	adc	r31, r31
 416:	8e 0f       	add	r24, r30
 418:	9f 1f       	adc	r25, r31
 41a:	fc 01       	movw	r30, r24
 41c:	e9 5b       	subi	r30, 0xB9	; 185
 41e:	fe 4f       	sbci	r31, 0xFE	; 254
 420:	81 81       	ldd	r24, Z+1	; 0x01
 422:	80 83       	st	Z, r24
						led[i].blinkCount = 255;
 424:	8f ef       	ldi	r24, 0xFF	; 255
 426:	82 83       	std	Z+2, r24	; 0x02
 428:	21 c0       	rjmp	.+66     	; 0x46c <__DATA_REGION_LENGTH__+0x6c>
					}
					else
					{
						led[i].blinkCount -= blinkDecrement;
 42a:	fc 01       	movw	r30, r24
 42c:	ee 0f       	add	r30, r30
 42e:	ff 1f       	adc	r31, r31
 430:	8e 0f       	add	r24, r30
 432:	9f 1f       	adc	r25, r31
 434:	fc 01       	movw	r30, r24
 436:	e9 5b       	subi	r30, 0xB9	; 185
 438:	fe 4f       	sbci	r31, 0xFE	; 254
 43a:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <blinkDecrement>
 43e:	38 1b       	sub	r19, r24
 440:	32 83       	std	Z+2, r19	; 0x02
 442:	14 c0       	rjmp	.+40     	; 0x46c <__DATA_REGION_LENGTH__+0x6c>
				}
				break;
			}
			case LED_SLOW_BLINKING: 
			{
				isLedOn[i] = slowBlink;
 444:	30 91 af 01 	lds	r19, 0x01AF	; 0x8001af <slowBlink>
 448:	e1 e0       	ldi	r30, 0x01	; 1
 44a:	f0 e0       	ldi	r31, 0x00	; 0
 44c:	ec 0f       	add	r30, r28
 44e:	fd 1f       	adc	r31, r29
 450:	e8 0f       	add	r30, r24
 452:	f9 1f       	adc	r31, r25
 454:	30 83       	st	Z, r19
				isLedOn[LED_PWR_GRN] = !slowBlink; // Green led slow blink 180deg phase of red led
 456:	81 e0       	ldi	r24, 0x01	; 1
 458:	83 27       	eor	r24, r19
 45a:	88 87       	std	Y+8, r24	; 0x08
				break;
 45c:	07 c0       	rjmp	.+14     	; 0x46c <__DATA_REGION_LENGTH__+0x6c>
			}	
			default: isLedOn[i] = LED_OFF;
 45e:	e1 e0       	ldi	r30, 0x01	; 1
 460:	f0 e0       	ldi	r31, 0x00	; 0
 462:	ec 0f       	add	r30, r28
 464:	fd 1f       	adc	r31, r29
 466:	e8 0f       	add	r30, r24
 468:	f9 1f       	adc	r31, r25
 46a:	10 82       	st	Z, r1
	else
	{
		blinkCounter++;
	}
	
	for(uint8_t i=0; i<LED_COUNT; i++)
 46c:	2f 5f       	subi	r18, 0xFF	; 255
 46e:	29 30       	cpi	r18, 0x09	; 9
 470:	08 f4       	brcc	.+2      	; 0x474 <__DATA_REGION_LENGTH__+0x74>
 472:	92 cf       	rjmp	.-220    	; 0x398 <SH100HW_MainTask+0x7a>
			default: isLedOn[i] = LED_OFF;
		}
	}
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
 474:	20 91 64 01 	lds	r18, 0x0164	; 0x800164 <RELAY_13_24>
								((uint16_t)RELAY_1_3 << 1)			|
 478:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <RELAY_1_3>
 47c:	90 e0       	ldi	r25, 0x00	; 0
 47e:	88 0f       	add	r24, r24
 480:	99 1f       	adc	r25, r25
			default: isLedOn[i] = LED_OFF;
		}
	}
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
 482:	ac 01       	movw	r20, r24
 484:	42 2b       	or	r20, r18
 486:	9a 01       	movw	r18, r20
								((uint16_t)RELAY_1_3 << 1)			|
								((uint16_t)isLedOn[LED_CH3] << 2)	|
 488:	9b 81       	ldd	r25, Y+3	; 0x03
 48a:	89 2f       	mov	r24, r25
 48c:	90 e0       	ldi	r25, 0x00	; 0
 48e:	88 0f       	add	r24, r24
 490:	99 1f       	adc	r25, r25
 492:	88 0f       	add	r24, r24
 494:	99 1f       	adc	r25, r25
		}
	}
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
								((uint16_t)RELAY_1_3 << 1)			|
 496:	82 2b       	or	r24, r18
 498:	93 2b       	or	r25, r19
								((uint16_t)isLedOn[LED_CH3] << 2)	|
								((uint16_t)isLedOn[LED_CH1] << 3)	|
 49a:	29 81       	ldd	r18, Y+1	; 0x01
 49c:	30 e0       	ldi	r19, 0x00	; 0
 49e:	22 0f       	add	r18, r18
 4a0:	33 1f       	adc	r19, r19
 4a2:	22 0f       	add	r18, r18
 4a4:	33 1f       	adc	r19, r19
 4a6:	22 0f       	add	r18, r18
 4a8:	33 1f       	adc	r19, r19
	}
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
								((uint16_t)RELAY_1_3 << 1)			|
								((uint16_t)isLedOn[LED_CH3] << 2)	|
 4aa:	82 2b       	or	r24, r18
 4ac:	93 2b       	or	r25, r19
								((uint16_t)isLedOn[LED_CH1] << 3)	|
								((uint16_t)isLedOn[LED_CH2] << 4)	|
 4ae:	2a 81       	ldd	r18, Y+2	; 0x02
 4b0:	50 e1       	ldi	r21, 0x10	; 16
 4b2:	25 9f       	mul	r18, r21
 4b4:	90 01       	movw	r18, r0
 4b6:	11 24       	eor	r1, r1
	
	// form result--------------------------------------------------------------
	uint16_t resultSendWord =	((uint16_t)RELAY_13_24)				|
								((uint16_t)RELAY_1_3 << 1)			|
								((uint16_t)isLedOn[LED_CH3] << 2)	|
								((uint16_t)isLedOn[LED_CH1] << 3)	|
 4b8:	28 2b       	or	r18, r24
 4ba:	39 2b       	or	r19, r25
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
 4bc:	4c 81       	ldd	r20, Y+4	; 0x04
 4be:	80 e2       	ldi	r24, 0x20	; 32
 4c0:	48 9f       	mul	r20, r24
 4c2:	a0 01       	movw	r20, r0
 4c4:	11 24       	eor	r1, r1
 4c6:	24 2b       	or	r18, r20
 4c8:	35 2b       	or	r19, r21
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
 4ca:	40 91 62 01 	lds	r20, 0x0162	; 0x800162 <RELAY_8_16>
 4ce:	80 e8       	ldi	r24, 0x80	; 128
 4d0:	48 9f       	mul	r20, r24
 4d2:	a0 01       	movw	r20, r0
 4d4:	11 24       	eor	r1, r1
								((uint16_t)RELAY_1_3 << 1)			|
								((uint16_t)isLedOn[LED_CH3] << 2)	|
								((uint16_t)isLedOn[LED_CH1] << 3)	|
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
 4d6:	24 2b       	or	r18, r20
 4d8:	35 2b       	or	r19, r21
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << (8+0))			|
 4da:	80 91 45 01 	lds	r24, 0x0145	; 0x800145 <RELAY_2_4>
 4de:	90 e0       	ldi	r25, 0x00	; 0
 4e0:	98 2f       	mov	r25, r24
 4e2:	88 27       	eor	r24, r24
								((uint16_t)isLedOn[LED_CH3] << 2)	|
								((uint16_t)isLedOn[LED_CH1] << 3)	|
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
 4e4:	28 2b       	or	r18, r24
 4e6:	39 2b       	or	r19, r25
								((uint16_t)RELAY_2_4 << (8+0))			|
								((uint16_t)isLedOn[LED_A] << (8+1))	|
 4e8:	8e 81       	ldd	r24, Y+6	; 0x06
 4ea:	90 e0       	ldi	r25, 0x00	; 0
 4ec:	98 2f       	mov	r25, r24
 4ee:	88 27       	eor	r24, r24
 4f0:	99 0f       	add	r25, r25
								((uint16_t)isLedOn[LED_CH1] << 3)	|
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << (8+0))			|
 4f2:	28 2b       	or	r18, r24
 4f4:	39 2b       	or	r19, r25
								((uint16_t)isLedOn[LED_A] << (8+1))	|
								((uint16_t)isLedOn[LED_B] << (8+2))	|
 4f6:	8f 81       	ldd	r24, Y+7	; 0x07
 4f8:	90 e0       	ldi	r25, 0x00	; 0
 4fa:	98 2f       	mov	r25, r24
 4fc:	88 27       	eor	r24, r24
 4fe:	99 0f       	add	r25, r25
 500:	99 0f       	add	r25, r25
								((uint16_t)isLedOn[LED_CH2] << 4)	|
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << (8+0))			|
								((uint16_t)isLedOn[LED_A] << (8+1))	|
 502:	28 2b       	or	r18, r24
 504:	39 2b       	or	r19, r25
								((uint16_t)isLedOn[LED_B] << (8+2))	|
								((uint16_t)isLedOn[LED_PWR_GRN] << (8+3))	|
 506:	88 85       	ldd	r24, Y+8	; 0x08
 508:	90 e0       	ldi	r25, 0x00	; 0
 50a:	98 2f       	mov	r25, r24
 50c:	88 27       	eor	r24, r24
 50e:	99 0f       	add	r25, r25
 510:	99 0f       	add	r25, r25
 512:	99 0f       	add	r25, r25
								((uint16_t)isLedOn[LED_CH4] << 5)	|
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << (8+0))			|
								((uint16_t)isLedOn[LED_A] << (8+1))	|
								((uint16_t)isLedOn[LED_B] << (8+2))	|
 514:	28 2b       	or	r18, r24
 516:	39 2b       	or	r19, r25
								((uint16_t)isLedOn[LED_PWR_GRN] << (8+3))	|
								((uint16_t)isLedOn[LED_PWR_RED] << (8+4))	|
 518:	99 85       	ldd	r25, Y+9	; 0x09
 51a:	89 2f       	mov	r24, r25
 51c:	90 e0       	ldi	r25, 0x00	; 0
 51e:	98 2f       	mov	r25, r24
 520:	88 27       	eor	r24, r24
 522:	92 95       	swap	r25
 524:	90 7f       	andi	r25, 0xF0	; 240
								(0 << 6)					|
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << (8+0))			|
								((uint16_t)isLedOn[LED_A] << (8+1))	|
								((uint16_t)isLedOn[LED_B] << (8+2))	|
								((uint16_t)isLedOn[LED_PWR_GRN] << (8+3))	|
 526:	28 2b       	or	r18, r24
 528:	39 2b       	or	r19, r25
								((uint16_t)isLedOn[LED_PWR_RED] << (8+4))	|
								((uint16_t)isLedOn[LED_LOOP] << (8+5))		|
 52a:	4d 81       	ldd	r20, Y+5	; 0x05
 52c:	50 e0       	ldi	r21, 0x00	; 0
 52e:	54 2f       	mov	r21, r20
 530:	44 27       	eor	r20, r20
 532:	52 95       	swap	r21
 534:	55 0f       	add	r21, r21
 536:	50 7e       	andi	r21, 0xE0	; 224
								((uint16_t)RELAY_8_16 << 7)			|
								((uint16_t)RELAY_2_4 << (8+0))			|
								((uint16_t)isLedOn[LED_A] << (8+1))	|
								((uint16_t)isLedOn[LED_B] << (8+2))	|
								((uint16_t)isLedOn[LED_PWR_GRN] << (8+3))	|
								((uint16_t)isLedOn[LED_PWR_RED] << (8+4))	|
 538:	24 2b       	or	r18, r20
 53a:	35 2b       	or	r19, r21
								((uint16_t)isLedOn[LED_LOOP] << (8+5))		|
								((uint16_t)RELAY_AB << (8+6)) |
 53c:	80 91 43 01 	lds	r24, 0x0143	; 0x800143 <RELAY_AB>
 540:	90 e0       	ldi	r25, 0x00	; 0
 542:	90 e4       	ldi	r25, 0x40	; 64
 544:	89 9f       	mul	r24, r25
 546:	90 2d       	mov	r25, r0
 548:	88 27       	eor	r24, r24
 54a:	11 24       	eor	r1, r1
								(0 << (8+7));

	writeShiftRegs(resultSendWord);
 54c:	82 2b       	or	r24, r18
 54e:	93 2b       	or	r25, r19
 550:	52 d8       	rcall	.-3932   	; 0xfffff5f6 <__eeprom_end+0xff7ef5f6>
 552:	29 96       	adiw	r28, 0x09	; 9
 554:	0f b6       	in	r0, 0x3f	; 63
 556:	f8 94       	cli
 558:	de bf       	out	0x3e, r29	; 62
 55a:	0f be       	out	0x3f, r0	; 63
 55c:	cd bf       	out	0x3d, r28	; 61
 55e:	df 91       	pop	r29
 560:	cf 91       	pop	r28
 562:	08 95       	ret

Disassembly of section .text.UART_init:

00001b10 <UART_init>:
	// Rx INT: On
	// Tx INT: On
	// Receiver: On
	// Transmitter: On
	
	UCSR0B = (1<<RXCIE0) | (1<<TXCIE0) | (1<<RXEN0) | (1<<TXEN0); //UCSR1B=0x98;
    1b10:	88 ed       	ldi	r24, 0xD8	; 216
    1b12:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7fe0c1>
	
	// 8 Data, 1 Stop, No Parity
	UCSR0C= (1<<UCSZ01) | (1<<UCSZ00); 
    1b16:	86 e0       	ldi	r24, 0x06	; 6
    1b18:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7fe0c2>
	
	// USART0 Mode: Asynchronous
	// USART Baud Rate: Fosc/320 = Fosc/16(UBRR+1)
	UBRR0H=0;
    1b1c:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7fe0c5>
	UBRR0L=19;
    1b20:	83 e1       	ldi	r24, 0x13	; 19
    1b22:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7fe0c4>
    1b26:	08 95       	ret

Disassembly of section .text.__vector_18:

000012ac <__vector_18>:
uint8_t rx_wr_index, rx_rd_index, rx_counter;

bool rx_buffer_overflow;

ISR(USART_RX_vect)
{
    12ac:	1f 92       	push	r1
    12ae:	1f b6       	in	r1, 0x3f	; 63
    12b0:	1f 92       	push	r1
    12b2:	11 24       	eor	r1, r1
    12b4:	8f 93       	push	r24
    12b6:	9f 93       	push	r25
    12b8:	ef 93       	push	r30
    12ba:	ff 93       	push	r31
	uint8_t status, data;
	status = UCSR0A;
    12bc:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fe0c0>
	data = UDR0;
    12c0:	90 91 c6 00 	lds	r25, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fe0c6>
	
	if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
    12c4:	8c 71       	andi	r24, 0x1C	; 28
    12c6:	d1 f4       	brne	.+52     	; 0x12fc <__vector_18+0x50>
	{
		rx_buffer0[rx_wr_index++] = data;
    12c8:	e0 91 66 01 	lds	r30, 0x0166	; 0x800166 <rx_wr_index>
    12cc:	81 e0       	ldi	r24, 0x01	; 1
    12ce:	8e 0f       	add	r24, r30
    12d0:	80 93 66 01 	sts	0x0166, r24	; 0x800166 <rx_wr_index>
    12d4:	f0 e0       	ldi	r31, 0x00	; 0
    12d6:	ee 58       	subi	r30, 0x8E	; 142
    12d8:	fe 4f       	sbci	r31, 0xFE	; 254
    12da:	90 83       	st	Z, r25
		
		if (rx_wr_index == RX_BUFFER_SIZE) rx_wr_index=0;
    12dc:	80 31       	cpi	r24, 0x10	; 16
    12de:	11 f4       	brne	.+4      	; 0x12e4 <__vector_18+0x38>
    12e0:	10 92 66 01 	sts	0x0166, r1	; 0x800166 <rx_wr_index>
		
		if (++rx_counter == RX_BUFFER_SIZE)
    12e4:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <rx_counter>
    12e8:	8f 5f       	subi	r24, 0xFF	; 255
    12ea:	80 93 71 01 	sts	0x0171, r24	; 0x800171 <rx_counter>
    12ee:	80 31       	cpi	r24, 0x10	; 16
    12f0:	29 f4       	brne	.+10     	; 0x12fc <__vector_18+0x50>
		{
			rx_counter=0;
    12f2:	10 92 71 01 	sts	0x0171, r1	; 0x800171 <rx_counter>
			rx_buffer_overflow=1;
    12f6:	81 e0       	ldi	r24, 0x01	; 1
    12f8:	80 93 67 01 	sts	0x0167, r24	; 0x800167 <rx_buffer_overflow>
		}
	}
}
    12fc:	ff 91       	pop	r31
    12fe:	ef 91       	pop	r30
    1300:	9f 91       	pop	r25
    1302:	8f 91       	pop	r24
    1304:	1f 90       	pop	r1
    1306:	1f be       	out	0x3f, r1	; 63
    1308:	1f 90       	pop	r1
    130a:	18 95       	reti

Disassembly of section .text.UART_PopWord:

000017fe <UART_PopWord>:

uint8_t UART_PopWord()
{
	uint8_t data;
	
	while (rx_counter == 0); // blocking
    17fe:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <rx_counter>
    1802:	88 23       	and	r24, r24
    1804:	e1 f3       	breq	.-8      	; 0x17fe <UART_PopWord>
	
	data = rx_buffer0[rx_rd_index++];
    1806:	e0 91 82 01 	lds	r30, 0x0182	; 0x800182 <rx_rd_index>
    180a:	91 e0       	ldi	r25, 0x01	; 1
    180c:	9e 0f       	add	r25, r30
    180e:	90 93 82 01 	sts	0x0182, r25	; 0x800182 <rx_rd_index>
    1812:	f0 e0       	ldi	r31, 0x00	; 0
    1814:	ee 58       	subi	r30, 0x8E	; 142
    1816:	fe 4f       	sbci	r31, 0xFE	; 254
    1818:	80 81       	ld	r24, Z
	
	#if RX_BUFFER_SIZE != 256
		if (rx_rd_index == RX_BUFFER_SIZE) rx_rd_index = 0;
    181a:	90 31       	cpi	r25, 0x10	; 16
    181c:	11 f4       	brne	.+4      	; 0x1822 <UART_PopWord+0x24>
    181e:	10 92 82 01 	sts	0x0182, r1	; 0x800182 <rx_rd_index>
	#endif
	
	cpu_irq_disable();
    1822:	f8 94       	cli
	--rx_counter;
    1824:	90 91 71 01 	lds	r25, 0x0171	; 0x800171 <rx_counter>
    1828:	91 50       	subi	r25, 0x01	; 1
    182a:	90 93 71 01 	sts	0x0171, r25	; 0x800171 <rx_counter>
	cpu_irq_enable();
    182e:	78 94       	sei
	return data;
}
    1830:	08 95       	ret

Disassembly of section .text.UART_RxBufferNotEmpty:

00001bb8 <UART_RxBufferNotEmpty>:

bool UART_RxBufferNotEmpty()
{
	return (bool)rx_counter;
    1bb8:	81 e0       	ldi	r24, 0x01	; 1
    1bba:	90 91 71 01 	lds	r25, 0x0171	; 0x800171 <rx_counter>
    1bbe:	91 11       	cpse	r25, r1
    1bc0:	01 c0       	rjmp	.+2      	; 0x1bc4 <UART_RxBufferNotEmpty+0xc>
    1bc2:	80 e0       	ldi	r24, 0x00	; 0
}
    1bc4:	08 95       	ret

Disassembly of section .text.__vector_20:

00001402 <__vector_20>:
uint8_t tx_buffer[TX_BUFFER_SIZE];
uint8_t tx_wr_index, tx_rd_index, tx_counter;

// USART Transmitter interrupt service routine
ISR(USART_TX_vect)
{
    1402:	1f 92       	push	r1
    1404:	1f b6       	in	r1, 0x3f	; 63
    1406:	1f 92       	push	r1
    1408:	11 24       	eor	r1, r1
    140a:	8f 93       	push	r24
    140c:	ef 93       	push	r30
    140e:	ff 93       	push	r31
	if (tx_counter)
    1410:	80 91 68 01 	lds	r24, 0x0168	; 0x800168 <tx_counter>
    1414:	88 23       	and	r24, r24
    1416:	a9 f0       	breq	.+42     	; 0x1442 <__vector_20+0x40>
	{
		--tx_counter;
    1418:	81 50       	subi	r24, 0x01	; 1
    141a:	80 93 68 01 	sts	0x0168, r24	; 0x800168 <tx_counter>
		UDR0=tx_buffer[tx_rd_index++];
    141e:	e0 91 83 01 	lds	r30, 0x0183	; 0x800183 <tx_rd_index>
    1422:	81 e0       	ldi	r24, 0x01	; 1
    1424:	8e 0f       	add	r24, r30
    1426:	80 93 83 01 	sts	0x0183, r24	; 0x800183 <tx_rd_index>
    142a:	f0 e0       	ldi	r31, 0x00	; 0
    142c:	e7 59       	subi	r30, 0x97	; 151
    142e:	fe 4f       	sbci	r31, 0xFE	; 254
    1430:	80 81       	ld	r24, Z
    1432:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fe0c6>
		
		#if TX_BUFFER_SIZE != 256
			if (tx_rd_index == TX_BUFFER_SIZE) tx_rd_index = 0;
    1436:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <tx_rd_index>
    143a:	88 30       	cpi	r24, 0x08	; 8
    143c:	11 f4       	brne	.+4      	; 0x1442 <__vector_20+0x40>
    143e:	10 92 83 01 	sts	0x0183, r1	; 0x800183 <tx_rd_index>
		#endif
	}
}
    1442:	ff 91       	pop	r31
    1444:	ef 91       	pop	r30
    1446:	8f 91       	pop	r24
    1448:	1f 90       	pop	r1
    144a:	1f be       	out	0x3f, r1	; 63
    144c:	1f 90       	pop	r1
    144e:	18 95       	reti

Disassembly of section .text.UART_PushWord:

0000152c <UART_PushWord>:

// Write a character to the USART Transmitter buffer
void UART_PushWord(uint8_t c)
{	
	while (tx_counter == TX_BUFFER_SIZE);
    152c:	90 91 68 01 	lds	r25, 0x0168	; 0x800168 <tx_counter>
    1530:	98 30       	cpi	r25, 0x08	; 8
    1532:	e1 f3       	breq	.-8      	; 0x152c <UART_PushWord>
	
	cpu_irq_disable();
    1534:	f8 94       	cli
	
	if (tx_counter || ((UCSR0A & DATA_REGISTER_EMPTY)==0))
    1536:	90 91 68 01 	lds	r25, 0x0168	; 0x800168 <tx_counter>
    153a:	91 11       	cpse	r25, r1
    153c:	04 c0       	rjmp	.+8      	; 0x1546 <UART_PushWord+0x1a>
    153e:	20 91 c0 00 	lds	r18, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7fe0c0>
    1542:	25 fd       	sbrc	r18, 5
    1544:	12 c0       	rjmp	.+36     	; 0x156a <UART_PushWord+0x3e>
	{
		tx_buffer[tx_wr_index++] = c;
    1546:	e0 91 84 01 	lds	r30, 0x0184	; 0x800184 <tx_wr_index>
    154a:	21 e0       	ldi	r18, 0x01	; 1
    154c:	2e 0f       	add	r18, r30
    154e:	20 93 84 01 	sts	0x0184, r18	; 0x800184 <tx_wr_index>
    1552:	f0 e0       	ldi	r31, 0x00	; 0
    1554:	e7 59       	subi	r30, 0x97	; 151
    1556:	fe 4f       	sbci	r31, 0xFE	; 254
    1558:	80 83       	st	Z, r24
		
		#if TX_BUFFER_SIZE0 != 256
			if (tx_wr_index == TX_BUFFER_SIZE) tx_wr_index=0;
    155a:	28 30       	cpi	r18, 0x08	; 8
    155c:	11 f4       	brne	.+4      	; 0x1562 <UART_PushWord+0x36>
    155e:	10 92 84 01 	sts	0x0184, r1	; 0x800184 <tx_wr_index>
		#endif
		
		++tx_counter;
    1562:	9f 5f       	subi	r25, 0xFF	; 255
    1564:	90 93 68 01 	sts	0x0168, r25	; 0x800168 <tx_counter>
    1568:	02 c0       	rjmp	.+4      	; 0x156e <UART_PushWord+0x42>
	}
	else UDR0=c;
    156a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7fe0c6>
	
	cpu_irq_enable();
    156e:	78 94       	sei
    1570:	08 95       	ret

Disassembly of section .text:

00000f2a <__floatunsisf>:
 f2a:	e8 94       	clt
 f2c:	09 c0       	rjmp	.+18     	; 0xf40 <__floatsisf+0x12>

00000f2e <__floatsisf>:
 f2e:	97 fb       	bst	r25, 7
 f30:	3e f4       	brtc	.+14     	; 0xf40 <__floatsisf+0x12>
 f32:	90 95       	com	r25
 f34:	80 95       	com	r24
 f36:	70 95       	com	r23
 f38:	61 95       	neg	r22
 f3a:	7f 4f       	sbci	r23, 0xFF	; 255
 f3c:	8f 4f       	sbci	r24, 0xFF	; 255
 f3e:	9f 4f       	sbci	r25, 0xFF	; 255
 f40:	99 23       	and	r25, r25
 f42:	a9 f0       	breq	.+42     	; 0xf6e <__floatsisf+0x40>
 f44:	f9 2f       	mov	r31, r25
 f46:	96 e9       	ldi	r25, 0x96	; 150
 f48:	bb 27       	eor	r27, r27
 f4a:	93 95       	inc	r25
 f4c:	f6 95       	lsr	r31
 f4e:	87 95       	ror	r24
 f50:	77 95       	ror	r23
 f52:	67 95       	ror	r22
 f54:	b7 95       	ror	r27
 f56:	f1 11       	cpse	r31, r1
 f58:	f8 cf       	rjmp	.-16     	; 0xf4a <__floatsisf+0x1c>
 f5a:	fa f4       	brpl	.+62     	; 0xf9a <__floatsisf+0x6c>
 f5c:	bb 0f       	add	r27, r27
 f5e:	11 f4       	brne	.+4      	; 0xf64 <__floatsisf+0x36>
 f60:	60 ff       	sbrs	r22, 0
 f62:	1b c0       	rjmp	.+54     	; 0xf9a <__floatsisf+0x6c>
 f64:	6f 5f       	subi	r22, 0xFF	; 255
 f66:	7f 4f       	sbci	r23, 0xFF	; 255
 f68:	8f 4f       	sbci	r24, 0xFF	; 255
 f6a:	9f 4f       	sbci	r25, 0xFF	; 255
 f6c:	16 c0       	rjmp	.+44     	; 0xf9a <__floatsisf+0x6c>
 f6e:	88 23       	and	r24, r24
 f70:	11 f0       	breq	.+4      	; 0xf76 <__floatsisf+0x48>
 f72:	96 e9       	ldi	r25, 0x96	; 150
 f74:	11 c0       	rjmp	.+34     	; 0xf98 <__floatsisf+0x6a>
 f76:	77 23       	and	r23, r23
 f78:	21 f0       	breq	.+8      	; 0xf82 <__floatsisf+0x54>
 f7a:	9e e8       	ldi	r25, 0x8E	; 142
 f7c:	87 2f       	mov	r24, r23
 f7e:	76 2f       	mov	r23, r22
 f80:	05 c0       	rjmp	.+10     	; 0xf8c <__floatsisf+0x5e>
 f82:	66 23       	and	r22, r22
 f84:	71 f0       	breq	.+28     	; 0xfa2 <__floatsisf+0x74>
 f86:	96 e8       	ldi	r25, 0x86	; 134
 f88:	86 2f       	mov	r24, r22
 f8a:	70 e0       	ldi	r23, 0x00	; 0
 f8c:	60 e0       	ldi	r22, 0x00	; 0
 f8e:	2a f0       	brmi	.+10     	; 0xf9a <__floatsisf+0x6c>
 f90:	9a 95       	dec	r25
 f92:	66 0f       	add	r22, r22
 f94:	77 1f       	adc	r23, r23
 f96:	88 1f       	adc	r24, r24
 f98:	da f7       	brpl	.-10     	; 0xf90 <__floatsisf+0x62>
 f9a:	88 0f       	add	r24, r24
 f9c:	96 95       	lsr	r25
 f9e:	87 95       	ror	r24
 fa0:	97 f9       	bld	r25, 7
 fa2:	08 95       	ret

Disassembly of section .text:

00001c14 <__gesf2>:
    1c14:	67 dc       	rcall	.-1842   	; 0x14e4 <__fp_cmp>
    1c16:	08 f4       	brcc	.+2      	; 0x1c1a <__gesf2+0x6>
    1c18:	8f ef       	ldi	r24, 0xFF	; 255
    1c1a:	08 95       	ret

Disassembly of section .text:

000014e4 <__fp_cmp>:
    14e4:	99 0f       	add	r25, r25
    14e6:	00 08       	sbc	r0, r0
    14e8:	55 0f       	add	r21, r21
    14ea:	aa 0b       	sbc	r26, r26
    14ec:	e0 e8       	ldi	r30, 0x80	; 128
    14ee:	fe ef       	ldi	r31, 0xFE	; 254
    14f0:	16 16       	cp	r1, r22
    14f2:	17 06       	cpc	r1, r23
    14f4:	e8 07       	cpc	r30, r24
    14f6:	f9 07       	cpc	r31, r25
    14f8:	c0 f0       	brcs	.+48     	; 0x152a <__fp_cmp+0x46>
    14fa:	12 16       	cp	r1, r18
    14fc:	13 06       	cpc	r1, r19
    14fe:	e4 07       	cpc	r30, r20
    1500:	f5 07       	cpc	r31, r21
    1502:	98 f0       	brcs	.+38     	; 0x152a <__fp_cmp+0x46>
    1504:	62 1b       	sub	r22, r18
    1506:	73 0b       	sbc	r23, r19
    1508:	84 0b       	sbc	r24, r20
    150a:	95 0b       	sbc	r25, r21
    150c:	39 f4       	brne	.+14     	; 0x151c <__fp_cmp+0x38>
    150e:	0a 26       	eor	r0, r26
    1510:	61 f0       	breq	.+24     	; 0x152a <__fp_cmp+0x46>
    1512:	23 2b       	or	r18, r19
    1514:	24 2b       	or	r18, r20
    1516:	25 2b       	or	r18, r21
    1518:	21 f4       	brne	.+8      	; 0x1522 <__fp_cmp+0x3e>
    151a:	08 95       	ret
    151c:	0a 26       	eor	r0, r26
    151e:	09 f4       	brne	.+2      	; 0x1522 <__fp_cmp+0x3e>
    1520:	a1 40       	sbci	r26, 0x01	; 1
    1522:	a6 95       	lsr	r26
    1524:	8f ef       	ldi	r24, 0xFF	; 255
    1526:	81 1d       	adc	r24, r1
    1528:	81 1d       	adc	r24, r1
    152a:	08 95       	ret

Disassembly of section .text.libgcc:

00001aae <__movmemx_qi>:
    1aae:	99 27       	eor	r25, r25

00001ab0 <__movmemx_hi>:
    1ab0:	77 fd       	sbrc	r23, 7
    1ab2:	05 c0       	rjmp	.+10     	; 0x1abe <__movmemx_hi+0xe>
    1ab4:	05 90       	lpm	r0, Z+
    1ab6:	0d 92       	st	X+, r0
    1ab8:	01 97       	sbiw	r24, 0x01	; 1
    1aba:	e1 f7       	brne	.-8      	; 0x1ab4 <__movmemx_hi+0x4>
    1abc:	08 95       	ret
    1abe:	01 90       	ld	r0, Z+
    1ac0:	0d 92       	st	X+, r0
    1ac2:	01 97       	sbiw	r24, 0x01	; 1
    1ac4:	e1 f7       	brne	.-8      	; 0x1abe <__movmemx_hi+0xe>
    1ac6:	08 95       	ret

Disassembly of section .text.__dummy_fini:

00001c58 <_fini>:
    1c58:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

00001c5a <__funcs_on_exit>:
    1c5a:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

00001c5c <__simulator_exit>:
    1c5c:	08 95       	ret

Disassembly of section .text.exit:

00001bc6 <exit>:
    1bc6:	ec 01       	movw	r28, r24
    1bc8:	48 d0       	rcall	.+144    	; 0x1c5a <__funcs_on_exit>
    1bca:	46 d0       	rcall	.+140    	; 0x1c58 <_fini>
    1bcc:	ce 01       	movw	r24, r28
    1bce:	46 d0       	rcall	.+140    	; 0x1c5c <__simulator_exit>
    1bd0:	ce 01       	movw	r24, r28
    1bd2:	45 d0       	rcall	.+138    	; 0x1c5e <_Exit>

Disassembly of section .text._Exit:

00001c5e <_Exit>:
    1c5e:	34 d2       	rcall	.+1128   	; 0x20c8 <__TEXT_REGION_LENGTH__+0xc8>

Disassembly of section .text.avrlibc:

00001994 <eeprom_read_block>:
    1994:	ba 01       	movw	r22, r20
    1996:	a9 01       	movw	r20, r18
    1998:	dc 01       	movw	r26, r24
    199a:	cb 01       	movw	r24, r22

0000199c <eeprom_read_blraw>:
    199c:	fc 01       	movw	r30, r24
    199e:	f9 99       	sbic	0x1f, 1	; 31
    19a0:	fe cf       	rjmp	.-4      	; 0x199e <eeprom_read_blraw+0x2>
    19a2:	06 c0       	rjmp	.+12     	; 0x19b0 <eeprom_read_blraw+0x14>
    19a4:	f2 bd       	out	0x22, r31	; 34
    19a6:	e1 bd       	out	0x21, r30	; 33
    19a8:	f8 9a       	sbi	0x1f, 0	; 31
    19aa:	31 96       	adiw	r30, 0x01	; 1
    19ac:	00 b4       	in	r0, 0x20	; 32
    19ae:	0d 92       	st	X+, r0
    19b0:	41 50       	subi	r20, 0x01	; 1
    19b2:	50 40       	sbci	r21, 0x00	; 0
    19b4:	b8 f7       	brcc	.-18     	; 0x19a4 <eeprom_read_blraw+0x8>
    19b6:	08 95       	ret

Disassembly of section .text.avrlibc:

00001b7c <eeprom_read_byte>:
    1b7c:	cb 01       	movw	r24, r22
    1b7e:	f9 99       	sbic	0x1f, 1	; 31
    1b80:	fe cf       	rjmp	.-4      	; 0x1b7e <eeprom_read_byte+0x2>
    1b82:	92 bd       	out	0x22, r25	; 34
    1b84:	81 bd       	out	0x21, r24	; 33
    1b86:	f8 9a       	sbi	0x1f, 0	; 31
    1b88:	99 27       	eor	r25, r25
    1b8a:	80 b5       	in	r24, 0x20	; 32
    1b8c:	08 95       	ret

Disassembly of section .text.avrlibc:

00001bec <eeprom_read_word>:
    1bec:	cb 01       	movw	r24, r22
    1bee:	a8 e1       	ldi	r26, 0x18	; 24
    1bf0:	b0 e0       	ldi	r27, 0x00	; 0
    1bf2:	42 e0       	ldi	r20, 0x02	; 2
    1bf4:	50 e0       	ldi	r21, 0x00	; 0
    1bf6:	d2 ce       	rjmp	.-604    	; 0x199c <eeprom_read_blraw>

Disassembly of section .text.avrlibc:

00001864 <eeprom_write_block>:
    1864:	cf 92       	push	r12
    1866:	df 92       	push	r13
    1868:	ef 92       	push	r14
    186a:	6b 01       	movw	r12, r22
    186c:	e8 2e       	mov	r14, r24
    186e:	ca 01       	movw	r24, r20
    1870:	42 2f       	mov	r20, r18
    1872:	73 2f       	mov	r23, r19
    1874:	09 c0       	rjmp	.+18     	; 0x1888 <eeprom_write_block+0x24>
    1876:	f6 01       	movw	r30, r12
    1878:	5e 2d       	mov	r21, r14
    187a:	c3 d1       	rcall	.+902    	; 0x1c02 <__xload_1>
    187c:	26 2f       	mov	r18, r22
    187e:	0a d1       	rcall	.+532    	; 0x1a94 <eeprom_write_r18>
    1880:	3f ef       	ldi	r19, 0xFF	; 255
    1882:	c3 1a       	sub	r12, r19
    1884:	d3 0a       	sbc	r13, r19
    1886:	e3 0a       	sbc	r14, r19
    1888:	41 50       	subi	r20, 0x01	; 1
    188a:	70 40       	sbci	r23, 0x00	; 0
    188c:	a0 f7       	brcc	.-24     	; 0x1876 <eeprom_write_block+0x12>
    188e:	ef 90       	pop	r14
    1890:	df 90       	pop	r13
    1892:	cf 90       	pop	r12
    1894:	08 95       	ret

Disassembly of section .text.avrlibc:

00001a92 <eeprom_write_byte>:
    1a92:	26 2f       	mov	r18, r22

00001a94 <eeprom_write_r18>:
    1a94:	f9 99       	sbic	0x1f, 1	; 31
    1a96:	fe cf       	rjmp	.-4      	; 0x1a94 <eeprom_write_r18>
    1a98:	1f ba       	out	0x1f, r1	; 31
    1a9a:	92 bd       	out	0x22, r25	; 34
    1a9c:	81 bd       	out	0x21, r24	; 33
    1a9e:	20 bd       	out	0x20, r18	; 32
    1aa0:	0f b6       	in	r0, 0x3f	; 63
    1aa2:	f8 94       	cli
    1aa4:	fa 9a       	sbi	0x1f, 2	; 31
    1aa6:	f9 9a       	sbi	0x1f, 1	; 31
    1aa8:	0f be       	out	0x3f, r0	; 63
    1aaa:	01 96       	adiw	r24, 0x01	; 1
    1aac:	08 95       	ret

Disassembly of section .text.avrlibc:

00001c4c <eeprom_write_word>:
    1c4c:	22 df       	rcall	.-444    	; 0x1a92 <eeprom_write_byte>
    1c4e:	27 2f       	mov	r18, r23
    1c50:	21 cf       	rjmp	.-446    	; 0x1a94 <eeprom_write_r18>

Disassembly of section .text.libgcc:

00001c02 <__xload_1>:
    1c02:	57 fd       	sbrc	r21, 7
    1c04:	60 81       	ld	r22, Z
    1c06:	57 ff       	sbrs	r21, 7
    1c08:	64 91       	lpm	r22, Z
    1c0a:	08 95       	ret
